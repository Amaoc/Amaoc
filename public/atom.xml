<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Amaoc</title>
  
  <subtitle>blog</subtitle>
  <link href="http://www.amaoc.cn/atom.xml" rel="self"/>
  
  <link href="http://www.amaoc.cn/"/>
  <updated>2024-03-04T10:17:03.829Z</updated>
  <id>http://www.amaoc.cn/</id>
  
  <author>
    <name>Amaoc</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>事件循环(Event Loop)</title>
    <link href="http://www.amaoc.cn/2023/11/28/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/"/>
    <id>http://www.amaoc.cn/2023/11/28/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/</id>
    <published>2023-11-28T03:44:24.508Z</published>
    <updated>2024-03-04T10:17:03.829Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一-为什么javascript是单线程"><a class="markdownIt-Anchor" href="#一-为什么javascript是单线程"></a> 一、为什么JavaScript是单线程？</h3><p>JavaScript语言的一大特点就是单线程，也就是说，同一个时间只能做一件事。那么，为什么JavaScript不能有多个线程呢？这样能提高效率啊。</p><p>JavaScript的单线程，与它的用途有关。作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。比如，假定JavaScript同时有两个线程，一个线程在某个DOM节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？</p><p>所以，为了避免复杂性，从一诞生，JavaScript就是单线程，这已经成了这门语言的核心特征，将来也不会改变。</p><p>为了利用多核CPU的计算能力，HTML5提出Web Worker标准，允许JavaScript脚本创建多个线程，但是子线程完全受主线程控制，且不得操作DOM。所以，这个新标准并没有改变JavaScript单线程的本质。</p><h3 id="二-任务队列"><a class="markdownIt-Anchor" href="#二-任务队列"></a> 二、任务队列</h3><p>单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。如果前一个任务耗时很长，后一个任务就不得不一直等着。</p><p>如果排队是因为计算量大，CPU忙不过来，倒也算了，但是很多时候CPU是闲着的，因为IO设备（输入输出设备）很慢（比如Ajax操作从网络读取数据），不得不等着结果出来，再往下执行。</p><p>JavaScript语言的设计者意识到，这时主线程完全可以不管IO设备，挂起处于等待中的任务，先运行排在后面的任务。等到IO设备返回了结果，再回过头，把挂起的任务继续执行下去。</p><p>于是，所有任务可以分成两种，一种是同步任务（synchronous），另一种是异步任务（asynchronous）。同步任务指的是，在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；异步任务指的是，不进入主线程、而进入&quot;任务队列&quot;（task queue）的任务，只有&quot;任务队列&quot;通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。</p><p>具体来说，异步执行的运行机制如下。（同步执行也是如此，因为它可以被视为没有异步任务的异步执行。）</p><blockquote><p>（1）所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。<br />（2）主线程之外，还存在一个&quot;任务队列&quot;（task queue）。只要异步任务有了运行结果，就在&quot;任务队列&quot;之中放置一个事件。<br />（3）一旦&quot;执行栈&quot;中的所有同步任务执行完毕，系统就会读取&quot;任务队列&quot;，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。<br />（4）主线程不断重复上面的第三步。</p></blockquote><p>下图就是主线程和任务队列的示意图。<br /><img src="/imgs/queue.jpg" alt="任务队列" /><br />只要主线程空了，就会去读取&quot;任务队列&quot;，这就是JavaScript的运行机制。这个过程会不断重复。</p><h3 id="三-事件和回调函数"><a class="markdownIt-Anchor" href="#三-事件和回调函数"></a> 三、事件和回调函数</h3><p>“任务队列&quot;是一个事件的队列（也可以理解成消息的队列），IO设备完成一项任务，就在&quot;任务队列&quot;中添加一个事件，表示相关的异步任务可以进入&quot;执行栈&quot;了。主线程读取&quot;任务队列”，就是读取里面有哪些事件。</p><p>“任务队列&quot;中的事件，除了IO设备的事件以外，还包括一些用户产生的事件（比如鼠标点击、页面滚动等等）。只要指定过回调函数，这些事件发生时就会进入&quot;任务队列”，等待主线程读取。</p><p>所谓&quot;回调函数&quot;（callback），就是那些会被主线程挂起来的代码。异步任务必须指定回调函数，当主线程开始执行异步任务，就是执行对应的回调函数。</p><p>&quot;任务队列&quot;是一个先进先出的数据结构，排在前面的事件，优先被主线程读取。主线程的读取过程基本上是自动的，只要执行栈一清空，&quot;任务队列&quot;上第一位的事件就自动进入主线程。但是，由于存在后文提到的&quot;定时器&quot;功能，主线程首先要检查一下执行时间，某些事件只有到了规定的时间，才能返回主线程。</p><h3 id="四-event-loop"><a class="markdownIt-Anchor" href="#四-event-loop"></a> 四、Event Loop</h3><p>主线程从&quot;任务队列&quot;中读取事件，这个过程是循环不断的，所以整个的这种运行机制又称为Event Loop（事件循环）。</p><p>为了更好地理解Event Loop，请看下图<br /><img src="/imgs/event-loop.png" alt="Event Loop" /><br />上图中，主线程运行的时候，产生堆（heap）和栈（stack），栈中的代码调用各种外部API，它们在&quot;任务队列&quot;中加入各种事件（click，load，done）。只要栈中的代码执行完毕，主线程就会去读取&quot;任务队列&quot;，依次执行那些事件所对应的回调函数。</p><p>执行栈中的代码（同步任务），总是在读取&quot;任务队列&quot;（异步任务）之前执行。</p><h3 id="五-nodejs的event-loop"><a class="markdownIt-Anchor" href="#五-nodejs的event-loop"></a> 五、Node.js的Event Loop</h3><p>Node.js也是单线程的Event Loop，但是它的运行机制不同于浏览器环境。</p><p>请看下面的示意图<br /><img src="/imgs/node-event-loop.png" alt="node-event-loop" /><br />根据上图，Node.js的运行机制如下:</p><blockquote><p>（1）V8引擎解析JavaScript脚本。<br />（2）解析后的代码，调用Node API。<br />（3）libuv库负责Node API的执行。它将不同的任务分配给不同的线程，形成一个Event Loop（事件循环），以异步的方式将任务的执行结果返回给V8引擎。<br />（4）V8引擎再将结果返回给用户。</p></blockquote><h3 id="参考文档"><a class="markdownIt-Anchor" href="#参考文档"></a> 参考文档</h3><blockquote><ol><li><a href="https://www.ruanyifeng.com/blog/2014/10/event-loop.html">JavaScript 运行机制详解：再谈Event Loop</a></li></ol></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;一-为什么javascript是单线程&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#一-为什么javascript是单线程&quot;&gt;&lt;/a&gt; 一、为什么JavaScript是单线程？&lt;/h3&gt;
&lt;p&gt;JavaScript语言的一大特点就是单</summary>
      
    
    
    
    <category term="前端开发" scheme="http://www.amaoc.cn/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="js" scheme="http://www.amaoc.cn/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>前端开发规范</title>
    <link href="http://www.amaoc.cn/2023/11/28/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/"/>
    <id>http://www.amaoc.cn/2023/11/28/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/</id>
    <published>2023-11-28T03:37:46.759Z</published>
    <updated>2024-03-04T14:49:57.115Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-命名规范"><a class="markdownIt-Anchor" href="#一-命名规范"></a> 一、命名规范</h2><p><font color="red">注意： 项目名，文件名不能包含 /:?&lt;&gt;| 等特殊符号（windows系统不兼容）</font></p><!-- 安心 npm 私有库组件命名规则为 “@anxin/xxx”。 --><h3 id="1-前端业务项目命名"><a class="markdownIt-Anchor" href="#1-前端业务项目命名"></a> 1. 前端业务项目命名</h3><blockquote><ol><li>全部采用小写方式， 并以中划线&quot;-&quot;分隔。</li><li>以对应的业务组名开头，如：“saas-”，“axcloud-”，“market-”，“tools-platform-”开头。</li><li>中间部分必须和后端同学，或者对应的master沟通好之后命名（怕命名重复，或命名不统一，前后端同一项目，命名不同）。</li><li>根据应用场景，以“-web”，“-h5”，“-pc”，“-admin”结尾。<br />例如：saas-xxx-admin</li></ol></blockquote><h3 id="2-其他前端项目命名"><a class="markdownIt-Anchor" href="#2-其他前端项目命名"></a> 2. 其他前端项目命名</h3><blockquote><ol><li>全部采用小写方式， 并以中划线&quot;-&quot;分隔。</li><li>模版项目以”-template“结尾。<br />例如：xxx-template</li></ol></blockquote><h3 id="3-目录命名"><a class="markdownIt-Anchor" href="#3-目录命名"></a> 3. 目录命名</h3><blockquote><ol><li>全部采用小驼峰格式 。</li><li>有复数结构时，要采用复数命名法，缩写不用复数。<br />正例：scripts / styles / components / images / utils / layouts / demo-styles / demo-scripts / img / doc / api<br />反例：script / style / demoScripts / demoStyles / imgs / docs / apis</li><li>【特殊】VUE项目中的components组件目录，使用大驼峰命名<br />正例：HeadSearch / PageLoading</li><li>【特殊】VUE的项目中的除了components组件目录外的所有目录也使用小驼峰格式命名。<br />正例：pageOne / shoppingCar / userManagement<br />反例：ShopingCar / UserManagement</li></ol></blockquote><h3 id="4-js-css-scss-html-png文件命名"><a class="markdownIt-Anchor" href="#4-js-css-scss-html-png文件命名"></a> 4. js、css、scss、HTML、PNG文件命名</h3><blockquote><p>全部采用小驼峰格式命名。</p></blockquote><h3 id="5-使用vue或者react技术栈组件component命名"><a class="markdownIt-Anchor" href="#5-使用vue或者react技术栈组件component命名"></a> 5 使用Vue或者React技术栈，组件Component命名</h3><blockquote><p>全部采用大驼峰格式命名。<br />例：MyComponent.vue</p></blockquote><h3 id="命名的严谨性"><a class="markdownIt-Anchor" href="#命名的严谨性"></a> 命名的严谨性</h3><blockquote><p>代码中的命名严禁使用拼音与英文混合的方式，更不允许直接使用中文的方式。<br />说明：正确的英文拼写和语法可以让阅读者更易于理解，避免歧义。<br />注意：即使纯拼音命名方式也要避免采用。<br />正例：henan / luoyang /rmb 等国际通用的名称，可视为英文。<br />反例：DaZhePromotion [打折] / getPingFenByName [评分] / int 某变量 = 3</p></blockquote><h3 id="杜绝完全不规范的缩写避免望文不知义"><a class="markdownIt-Anchor" href="#杜绝完全不规范的缩写避免望文不知义"></a> 杜绝完全不规范的缩写，避免望文不知义</h3><blockquote><p>需做到望文知义<br />反例：AbstractClass —&gt; AbsClass，condition —&gt; condi<br />此类随意缩写严重降低例代码的可阅读性。<br />如果太长，要用缩写，必须把原来的英文放在注释里。</p></blockquote><h2 id="二-html规范vue-template同样适用"><a class="markdownIt-Anchor" href="#二-html规范vue-template同样适用"></a> 二、HTML规范（Vue Template同样适用）</h2><h3 id="1-html类型"><a class="markdownIt-Anchor" href="#1-html类型"></a> 1. HTML类型</h3><blockquote><p>推荐使用HTML5的文档类型声明：<br />（建议使用text/html格式的HTML。避免使用XHTML。XHTML以及它的属性，比如application/xhtml + xml在浏览器中的应用支持与优化空间都十分有限）。</p><ul><li>规定字符编码</li><li>IE兼容模式</li><li>doctype大写</li></ul><p>正例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=Edge&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Page Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;images/company-logo.png&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;Company&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></blockquote><h3 id="2-缩进"><a class="markdownIt-Anchor" href="#2-缩进"></a> 2. 缩进</h3><blockquote><ol><li>缩进使用2个空格（1个tab）</li><li>嵌套的节点应该缩进。</li></ol></blockquote><h3 id="3-分块注释"><a class="markdownIt-Anchor" href="#3-分块注释"></a> 3. 分块注释</h3><blockquote><p>在每一个块状元素，列表元素和表格元素后，加上一对HTML注释。<br />注释格式：<br />&lt;!– 英文 / 中文 start --&gt;<br />&lt;!– 英文 / 中文 end --&gt;<br />正例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 头部 start --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=Edge&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Page Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 头部 end --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- body start --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 图片会把a标签给撑开，所以不用设置a标签的大小 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;images/company-logo.png&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;Company&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- body end --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></blockquote><h3 id="4-语义化标签"><a class="markdownIt-Anchor" href="#4-语义化标签"></a> 4. 语义化标签</h3><blockquote><p>HTML5中新增很多语义化标签，所以优先使用语义化标签，避免一个页面都是div或者p标签<br />正例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">header</span>&gt;</span><span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">footer</span>&gt;</span><span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br></pre></td></tr></table></figure><p>反例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></blockquote><h3 id="5-引号"><a class="markdownIt-Anchor" href="#5-引号"></a> 5. 引号</h3><blockquote><ul><li>使用双引号(“”)</li><li>不使用单引号(‘’)</li></ul></blockquote><h3 id="6-引入css-js"><a class="markdownIt-Anchor" href="#6-引入css-js"></a> 6. 引入CSS, JS</h3><blockquote><p>根据HTML5规范, 通常在引入CSS和JS时不需要指明 type，因为 text/css和 text/javascript 分别是他们的默认值。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- External CSS --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;code_guide.css&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- In-document CSS --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">  </span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- External JS --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;code_guide.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- In-document JS --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="comment">// ...</span></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></blockquote><h3 id="7-属性顺序"><a class="markdownIt-Anchor" href="#7-属性顺序"></a> 7. 属性顺序</h3><blockquote><p>属性名全小写，用中划线做分隔符</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 由prettier格式化</span></span><br><span class="line">class</span><br><span class="line"><span class="built_in">id</span></span><br><span class="line">name</span><br><span class="line">data-*</span><br><span class="line">src, <span class="keyword">for</span>, <span class="built_in">type</span>, href, value , max-length, max, min, pattern</span><br><span class="line">placeholder, title, alt</span><br><span class="line">aria-*, role</span><br><span class="line">required, <span class="built_in">readonly</span>, disabled</span><br><span class="line"></span><br><span class="line">class是为高可复用组件设计的，所以应处在第一位；</span><br><span class="line"><span class="built_in">id</span> 具体且应该尽量少使用，所以将它放在第二位。</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">&quot;...&quot;</span> <span class="attr">id</span>=<span class="string">&quot;...&quot;</span> <span class="attr">data-modal</span>=<span class="string">&quot;toggle&quot;</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>Example link<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">class</span>=<span class="string">&quot;form-control&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;...&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;...&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></blockquote><h3 id="8-减少标签数量"><a class="markdownIt-Anchor" href="#8-减少标签数量"></a> 8. 减少标签数量</h3><blockquote><p>需要尽量避免多余的父节点；</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 不建议这么做 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;avatar&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;...&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 建议这么做 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">class</span>=<span class="string">&quot;avatar&quot;</span> <span class="attr">src</span>=<span class="string">&quot;...&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></blockquote><h3 id="9-其他"><a class="markdownIt-Anchor" href="#9-其他"></a> 9. 其他</h3><blockquote><ol><li>标签必须要关闭</li><li>p标签不允许嵌套div等标签</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 例 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 部分浏览器会解析成 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure></blockquote><h2 id="三-cssscss规范"><a class="markdownIt-Anchor" href="#三-cssscss规范"></a> 三、CSS/SCSS规范</h2><ul><li>缩进统一为2个空格</li><li>不允许有空的规则出现；</li><li>元素选择器用小写字母；</li><li>样式的顺序通过prettier来修改；</li></ul><h3 id="css规范"><a class="markdownIt-Anchor" href="#css规范"></a> CSS规范</h3><h3 id="1-命名"><a class="markdownIt-Anchor" href="#1-命名"></a> 1. 命名</h3><blockquote><ul><li>类名使用小写字母，以中划线分隔</li><li>id采用驼峰试命名</li><li>scss中的变量、函数、混合、placeholder采用驼峰式命名<br />id和class的名称总是使用可以反应元素目的和用途的名称，或其他通用的名称，代替表象和晦涩难懂的名称</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 不推荐： */</span></span><br><span class="line"><span class="selector-class">.fw-800</span> &#123;</span><br><span class="line">  <span class="attribute">font-weight</span>: <span class="number">800</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.red</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 推荐 */</span></span><br><span class="line"><span class="selector-class">.heavy</span> &#123;</span><br><span class="line">  <span class="attribute">font-weight</span>: <span class="number">800</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.important</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h3 id="2-选择器"><a class="markdownIt-Anchor" href="#2-选择器"></a> 2. 选择器</h3><blockquote><ol><li>css选择器中避免使用标签名<br />从结构、表现、行为分离的原则来看，应该尽量避开css中出现的HTML标签，并且在css选择器中出现标签名会存在潜在的问题。</li><li>很多前端开发人员写选择器链的时候，不使用直接子选择器（注：直接子选择器和后代选择器的区别）。有时，这可能会导致疼痛的设计问题，并且有时候可能会很耗性能。然而，在任何情况下，这个是一个非常不好的做法。如果你不写很通用，需要匹配到DOM末端的选择器，你应该总是考虑直接子选择器。</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 不推荐 */</span></span><br><span class="line"><span class="selector-class">.content</span> <span class="selector-class">.title</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">2rem</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 推荐 */</span></span><br><span class="line"><span class="selector-class">.content</span> &gt; <span class="selector-class">.title</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">2rem</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h3 id="3-尽量使用缩写属性"><a class="markdownIt-Anchor" href="#3-尽量使用缩写属性"></a> 3. 尽量使用缩写属性</h3><blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 不推荐 */</span></span><br><span class="line"><span class="selector-class">.title</span> &#123;</span><br><span class="line">  <span class="attribute">border-top-style</span>: none;</span><br><span class="line">  <span class="attribute">font-family</span>: palatino, georgia, serif;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">1.6</span>;</span><br><span class="line">  <span class="attribute">padding-bottom</span>: <span class="number">2em</span>;</span><br><span class="line">  <span class="attribute">padding-left</span>: <span class="number">2em</span>;</span><br><span class="line">  <span class="attribute">padding-right</span>: <span class="number">2em</span>;</span><br><span class="line">  <span class="attribute">padding-top</span>: <span class="number">2em</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 推荐 */</span></span><br><span class="line"><span class="selector-class">.title</span> &#123;</span><br><span class="line">  <span class="attribute">border-top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">font</span>: <span class="number">100%</span>/<span class="number">1.6</span> palatino, georgia, serif;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">2em</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h3 id="4-每个选择器及属性独占一行"><a class="markdownIt-Anchor" href="#4-每个选择器及属性独占一行"></a> 4. 每个选择器及属性独占一行</h3><blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 不推荐 */</span></span><br><span class="line"><span class="selector-class">.title</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;<span class="attribute">height</span>: <span class="number">50px</span>; <span class="attribute">color</span>: <span class="number">#fff</span>; <span class="attribute">background</span>: <span class="number">#00a0e9</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 推荐 */</span></span><br><span class="line"><span class="selector-class">.title</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">50px</span>;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#00a0e9</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h3 id="5-省略0后面的单位"><a class="markdownIt-Anchor" href="#5-省略0后面的单位"></a> 5. 省略0后面的单位</h3><blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 不推荐 */</span></span><br><span class="line"><span class="selector-class">.title</span> &#123;</span><br><span class="line">  <span class="attribute">padding-bottom</span>: <span class="number">0px</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0em</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 推荐 */</span></span><br><span class="line"><span class="selector-class">.title</span> &#123;</span><br><span class="line">  <span class="attribute">padding-bottom</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h3 id="6-避免使用id选择器及全局标签选择器防止污染全局样式"><a class="markdownIt-Anchor" href="#6-避免使用id选择器及全局标签选择器防止污染全局样式"></a> 6. 避免使用ID选择器及全局标签选择器，防止污染全局样式</h3><blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 不推荐 */</span></span><br><span class="line"><span class="selector-id">#title</span> &#123;</span><br><span class="line">  <span class="attribute">padding-bottom</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 推荐 */</span></span><br><span class="line"><span class="selector-class">.title</span> &#123;</span><br><span class="line">  <span class="attribute">padding-bottom</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h3 id="scss规范"><a class="markdownIt-Anchor" href="#scss规范"></a> SCSS规范</h3><h3 id="1-将公共的scss文件放置在style文件夹内"><a class="markdownIt-Anchor" href="#1-将公共的scss文件放置在style文件夹内"></a> 1. 将公共的scss文件放置在style文件夹内</h3><blockquote><ol><li>放置在项目的/src/styles内</li><li>nuxt项目可以直接放到/styles内</li></ol></blockquote><h3 id="2-按以下顺序组织"><a class="markdownIt-Anchor" href="#2-按以下顺序组织"></a> 2. 按以下顺序组织</h3><blockquote><ol><li>@import;</li><li>变量声明；</li><li>样式声明；</li></ol><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@import</span> <span class="string">&quot;styles/size.scss&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@default-text-color</span>: <span class="number">#333</span>;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.page</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">960px</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h3 id="3-避免嵌套层级过多"><a class="markdownIt-Anchor" href="#3-避免嵌套层级过多"></a> 3. 避免嵌套层级过多</h3><blockquote><ol><li>将嵌套深度限制在3级。对于超过4级的嵌套，给予重新评估，这可以避免出现过于祥实的CSS选择器；</li><li>避免大量的嵌套规则。当可读性受到影响时，将之打断。推荐避免出现多于20行的嵌套规则出现；</li></ol><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 不推荐 */</span></span><br><span class="line"><span class="selector-class">.main</span> &#123;</span><br><span class="line">  <span class="selector-class">.title</span> &#123;</span><br><span class="line">    <span class="selector-class">.name</span> &#123;</span><br><span class="line">      <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 推荐 */</span></span><br><span class="line"><span class="selector-class">.main-title</span> &#123;</span><br><span class="line">  <span class="selector-class">.name</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h2 id="四-javascript规范"><a class="markdownIt-Anchor" href="#四-javascript规范"></a> 四、JavaScript规范</h2><h3 id="1-命名-2"><a class="markdownIt-Anchor" href="#1-命名-2"></a> 1. 命名</h3><blockquote><ol><li>采用小写驼峰命名lowerCamelCase，代码中的命名均不能以 “_” 开头，也不能以 “_” 或者 “$” 结束；</li></ol><blockquote><p>反例：_name / name_ / name$；</p></blockquote><ol start="2"><li>方法名、参数名、成员变量、局部变量都统一用lowerCamelCase风格，必须遵从驼峰形式；</li></ol><blockquote><p>正例：localValue / getHttpMessage() / inputUserId</p></blockquote><ol start="3"><li>*** 其中method方法命名必须是 “动词” 或者 “动词 + 名词” 的形式 ***</li></ol><blockquote><p>正例：saveShopCarData / openShopCarInfoDialog<br />反例：save / open / show / go</p></blockquote><ol start="4"><li>*** 特此说，增删改查，详情统一使用如下5个单词，不得使用其他 *** （目的是为了统一各个端）</li></ol><blockquote><p>add  / delete / update / get / detail</p></blockquote><ol start="5"><li>常量命名全部大写，单词间用下划线隔开，力求语义表达完整清楚，不要嫌弃名字长。</li></ol><blockquote><p>正例：MAX_STOCK_COUNT<br />反例：MAX_COUNTs</p></blockquote></blockquote><blockquote><h5 id="附函数方法常用的动词"><a class="markdownIt-Anchor" href="#附函数方法常用的动词"></a> 附：函数方法常用的动词</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">handle 处理</span><br><span class="line">toggle 切换</span><br><span class="line">reset 重置</span><br><span class="line">init 初始化</span><br><span class="line">get 获取 / <span class="built_in">set</span> 设置</span><br><span class="line">add 增加 / remove 删除</span><br><span class="line">create 创建 / destory 移除</span><br><span class="line">start 开始 / stop 停止</span><br><span class="line">start 开始 / finish 完成</span><br><span class="line">begin 开始 / end 结束</span><br><span class="line">open 打开 / close 关闭</span><br><span class="line"><span class="built_in">read</span> 读取 / write 写入</span><br><span class="line">load 载入 / save 保存</span><br><span class="line">create 创建 / destroy 销毁</span><br><span class="line">backup 备份 / restore 恢复</span><br><span class="line">import 导入 / <span class="built_in">export</span> 导出</span><br><span class="line"><span class="built_in">split</span> 分割 / merge 合并</span><br><span class="line">inject 注入 / extract 提取</span><br><span class="line">attach 附着 / detach 脱离</span><br><span class="line"><span class="built_in">bind</span> 绑定 / separate 分离</span><br><span class="line">view 查看 / browse 浏览</span><br><span class="line">edit 编辑 / modify 修改</span><br><span class="line"><span class="keyword">select</span> 选取 / mark 标记</span><br><span class="line">copy 复制 / <span class="built_in">paste</span> 粘贴</span><br><span class="line">undo 撤销 / redo 重做</span><br><span class="line">insert 插入 / delete 移除</span><br><span class="line">add 加入 / append 添加</span><br><span class="line">clean 清理 / clear 清除</span><br><span class="line">index 索引 / <span class="built_in">sort</span> 排序</span><br><span class="line">find 查找 / search 搜索</span><br><span class="line">increase 增加 / decrease 减少</span><br><span class="line">play 播放 / pause 暂停</span><br><span class="line">launch 启动 / run 运行</span><br><span class="line">compile 编译 / execute 执行</span><br><span class="line">debug 调试 / trace 跟踪</span><br><span class="line">observe 观察 / listen 监听</span><br><span class="line">build 构建 / publish 发布</span><br><span class="line">input 输入 / output 输出</span><br><span class="line">encode 编码 / decode 解码</span><br><span class="line">encrypt 加密 / decrypt 解密</span><br><span class="line">compress 压缩 / decompress 解压缩</span><br><span class="line">pack 打包 / unpack 解包</span><br><span class="line">parse 解析 / emit 生成 / build 构建</span><br><span class="line">generate 生成 / emit 发射</span><br><span class="line">connect 连接 / disconnect 断开</span><br><span class="line">send 发送 / receive 接收</span><br><span class="line">download 下载 / upload 上传</span><br><span class="line">refresh 刷新 / synchronize 同步</span><br><span class="line">update 更新 / revert 复原</span><br><span class="line">lock 锁定 / unlock 解锁</span><br><span class="line">check out 签出 / check <span class="keyword">in</span> 签入</span><br><span class="line">submit 提交 / commit 交付</span><br><span class="line">push 推 / pull 拉</span><br><span class="line"><span class="built_in">expand</span> 展开 / collapse 折叠</span><br><span class="line">enter 进入 / <span class="built_in">exit</span> 退出</span><br><span class="line">abort 放弃 / quit 离开</span><br><span class="line">obsolete 废弃 / depreciate 废旧</span><br><span class="line">collect 收集 / aggregate 聚集</span><br><span class="line">shim 衬垫 / sham 伪装</span><br><span class="line">pick 拿取 / seek 寻找</span><br><span class="line">translate 平移/翻译 / rotate 旋转</span><br><span class="line">zoom 变焦 / scale 缩放</span><br><span class="line">skew 歪曲 / shear 剪切</span><br><span class="line"></span><br><span class="line">涉及返回逻辑值的函数可以使用is，can，has，contains等表示逻辑的词语代替动词</span><br></pre></td></tr></table></figure></blockquote><blockquote><h5 id="附2一些其他变量命名常用规范仅供参考"><a class="markdownIt-Anchor" href="#附2一些其他变量命名常用规范仅供参考"></a> 附2：一些其他变量命名常用规范（仅供参考）</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">* s：表示字符串。例如：sName，sHtml；</span><br><span class="line">* n：表示数字。例如：nPage，nTotal；</span><br><span class="line">* b：表示逻辑。例如：bChecked，bHasLogin；</span><br><span class="line">* a：表示数组。例如：aList，aGroup；</span><br><span class="line">* r：表示正则表达式。例如：rDomain，rEmail；</span><br><span class="line">* f：表示函数。例如：fGetHtml，fInit；</span><br><span class="line">* o：表示以上未涉及到的其他对象，例如：oButton，oDate；</span><br><span class="line">* g：表示全局变量，例如：gUserName，gLoginTime； </span><br></pre></td></tr></table></figure></blockquote><blockquote><h5 id="附3按照前缀区分仅供参考"><a class="markdownIt-Anchor" href="#附3按照前缀区分仅供参考"></a> 附3：按照前缀区分（仅供参考）</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">* $：表示Jquery对象。例如：$Content，$Module；</span><br><span class="line">  一种比较广泛的Jquery对象变量命名规范。</span><br><span class="line">* j：表示Jquery对象。例如：jContent， jModule；</span><br><span class="line">  另一种Jquery对象变量命名方式。</span><br><span class="line">* fn：表示函数。例如：fnGetName，fnSetAge；</span><br><span class="line">  和上面函数的前缀略有不同，改用fn来代替，个人认为fn能够更好的区分普通变量和函数变量。</span><br><span class="line">* dom：表示Dom对象，例如：domForm，domInput；</span><br><span class="line">  项目中很多地方会用到原生的Dom方法及属性，可以根据团队需要适当修改。</span><br></pre></td></tr></table></figure></blockquote><h3 id="2-代码格式"><a class="markdownIt-Anchor" href="#2-代码格式"></a> 2. 代码格式</h3><blockquote><ol><li>使用2个空格进行缩进；</li></ol><blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (x &lt; y) &#123;</span><br><span class="line">  x += <span class="number">10</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  x += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><ol start="2"><li>不同逻辑、不同语义，不同业务的代码之间插入一个空行分隔开来，以提升可读性；</li></ol><blockquote><p>说明：任何情形，没有必要插入多个空行进行隔开。</p></blockquote><ol start="3"><li>字符串统一使用单引号(')，而不使用双引号(&quot;)。这在创建HTML字符串非常有好处，单引号的处理速度也比双引号快；</li></ol><blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正例</span></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;foo&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> testDiv = <span class="string">&#x27;&lt;div id=&quot;test&quot;&gt;&lt;/div&gt;&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 反例</span></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;foo&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> testDiv = <span class="string">&quot;&lt;div id=&#x27;test&#x27;&gt;&lt;/div&gt;&quot;</span>;</span><br></pre></td></tr></table></figure></blockquote></blockquote><h3 id="4-对象声明"><a class="markdownIt-Anchor" href="#4-对象声明"></a> 4. 对象声明</h3><blockquote><ol><li>使用字面值创建对象；</li></ol><blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正例</span></span><br><span class="line"><span class="keyword">let</span> user = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 反例</span></span><br><span class="line"><span class="keyword">let</span> user = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br></pre></td></tr></table></figure></blockquote><ol start="2"><li>使用字面量来代替对象构造器；</li></ol><blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正例</span></span><br><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  <span class="attr">age</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="attr">name</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">city</span>: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 反例</span></span><br><span class="line"><span class="keyword">let</span> user = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">user.<span class="property">age</span> = <span class="number">0</span>;</span><br><span class="line">user.<span class="property">name</span> = <span class="number">1</span>;</span><br><span class="line">user.<span class="property">city</span> = <span class="number">2</span>;</span><br></pre></td></tr></table></figure></blockquote></blockquote><h3 id="5-使用es67"><a class="markdownIt-Anchor" href="#5-使用es67"></a> 5. 使用ES6,7</h3><blockquote><p>必须优先使用ES6,7中新增的语法糖和函数。这将简化你的程序，并让你的代码更加灵活和可复用。</p><blockquote><p>必须强制使用ES6，ES7的新语法，比如箭头函数，await/async，解构，let，for…of等等。</p></blockquote></blockquote><h3 id="6-括号"><a class="markdownIt-Anchor" href="#6-括号"></a> 6. 括号</h3><blockquote><p>下列关键字后必须有大括号（即使代码块的内容只有一行）：</p><blockquote><p>if, else, for, while, do, switch, try, catch, finally, with。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正例</span></span><br><span class="line"><span class="keyword">if</span> (condition) &#123;</span><br><span class="line">  <span class="title function_">doSomething</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 反例</span></span><br><span class="line"><span class="keyword">if</span> (condition) <span class="title function_">doSomething</span>();</span><br></pre></td></tr></table></figure></blockquote></blockquote><h3 id="7-undefined-判断"><a class="markdownIt-Anchor" href="#7-undefined-判断"></a> 7. undefined 判断</h3><blockquote><ol><li>永远不要直接使用undefined进行变量判断；</li><li>使用typeof和字符串’undefined’对变量进行判断；</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正例</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> person === <span class="string">&#x27;undefined&#x27;</span>) &#123;</span><br><span class="line">  <span class="comment">// do...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 反例</span></span><br><span class="line"><span class="keyword">if</span> (person === <span class="literal">undefined</span>) &#123;</span><br><span class="line">  <span class="comment">// do...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h3 id="8-条件判断和循环最多三层"><a class="markdownIt-Anchor" href="#8-条件判断和循环最多三层"></a> 8. 条件判断和循环最多三层</h3><blockquote><p>条件判断能使用三元运算符和逻辑运算符解决的，就不要使用条件判断，但是谨记不要写太长的三元运算符。</p><blockquote><p>如果超过3层，请抽成函数，并写清楚注释。</p></blockquote></blockquote><h3 id="9-this-的转换命名"><a class="markdownIt-Anchor" href="#9-this-的转换命名"></a> 9. this 的转换命名</h3><blockquote><p>对上下文 this 的引用只能使用’self’来命名。</p></blockquote><h3 id="10-慎用-consolelog"><a class="markdownIt-Anchor" href="#10-慎用-consolelog"></a> 10. 慎用 console.log</h3><blockquote><p>因 console.log 的大量使用会有性能问题，所以在非webpack项目中谨慎使用log功能。</p></blockquote><h3 id="其他"><a class="markdownIt-Anchor" href="#其他"></a> 其他</h3><h4 id="1缩进-2个空格"><a class="markdownIt-Anchor" href="#1缩进-2个空格"></a> 1）缩进 2个空格</h4><h4 id="2属性末尾加分号"><a class="markdownIt-Anchor" href="#2属性末尾加分号"></a> 2）属性末尾加分号</h4><h4 id="3-空格-在对象数组括号与文字之间加空格"><a class="markdownIt-Anchor" href="#3-空格-在对象数组括号与文字之间加空格"></a> 3) 空格  在对象，数组括号与文字之间加空格</h4><p>通过配置prettier实现</p><h4 id="4注释"><a class="markdownIt-Anchor" href="#4注释"></a> 4）注释</h4><p>单行：双斜线后，必须跟一个空格；缩进与下一行代码保持一致；可位于一个代码行的末尾，与代码间隔一个空格。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if (condition) &#123;</span><br><span class="line">    // if you made it here, then all security checks passed</span><br><span class="line">    allowed();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var zhangsan = &#x27;zhangsan&#x27;; // one space after code</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>多行：最少三行, '*'后跟一个空格</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * one space after &#x27;*&#x27;</span><br><span class="line"> */</span><br><span class="line">var x = 1;</span><br></pre></td></tr></table></figure><p>方法注释</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 我是一个方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; p1 参数1的说明</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; p2 参数2的说明，比较长</span></span><br><span class="line"><span class="comment"> *     那就换行了.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number=</span>&#125; p3 参数3的说明（可选）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">Object</span>&#125; 返回值描述</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fun</span>(<span class="params">p1, p2, p3</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-变量命名"><a class="markdownIt-Anchor" href="#5-变量命名"></a> 5) 变量命名</h4><ul><li>标准变量采用驼峰式命名</li><li>'ID’在变量名中全大写</li><li>'URL’在变量名中全大写</li><li>'Android’在变量名中大写第一个字母</li><li>'iOS’在变量名中小写第一个，大写后两个字母</li><li>常量全大写，用下划线连接</li><li>构造函数，大写第一个字母</li></ul><h4 id="6函数"><a class="markdownIt-Anchor" href="#6函数"></a> 6)函数</h4><p>无论是函数声明还是函数表达式，'(‘前不要空格，但’{'前一定要有空格；</p><p>函数调用括号前不需要空格；</p><p>立即执行函数外必须包一层括号；</p><p>不要给inline function命名；</p><p>参数之间用’, '分隔，注意逗号后有一个空格。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">// no space before &#x27;(&#x27;, but one space before&#x27;&#123;&#x27;</span><br><span class="line">var doSomething = function(item) &#123;</span><br><span class="line">    // do something</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function doSomething(item) &#123;</span><br><span class="line">    // do something</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// not good</span><br><span class="line">doSomething (item);</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">doSomething(item);</span><br><span class="line"></span><br><span class="line">// requires parentheses around immediately invoked function expressions</span><br><span class="line">(function() &#123;</span><br><span class="line">    return 1;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">// not good</span><br><span class="line">[1, 2].forEach(function x() &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">[1, 2].forEach(function() &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// not good</span><br><span class="line">var a = [1, 2, function a() &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">var a = [1, 2, function() &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">// use &#x27;, &#x27; between function parameters</span><br><span class="line">var doSomething = function(a, b, c) &#123;</span><br><span class="line">    // do something</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="7-数组-对象"><a class="markdownIt-Anchor" href="#7-数组-对象"></a> 7) 数组、对象</h4><p>对象属性名不需要加引号；</p><p>对象以缩进的形式书写，不要写在一行；</p><p>数组、对象最后不要有逗号。<br />可通过prettier 配置实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// not good</span><br><span class="line">var a = &#123;</span><br><span class="line">    &#x27;b&#x27;: 1</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var a = &#123;b: 1&#125;;</span><br><span class="line"></span><br><span class="line">var a = &#123;</span><br><span class="line">    b: 1,</span><br><span class="line">    c: 2,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">var a = &#123;</span><br><span class="line">    b: 1,</span><br><span class="line">    c: 2</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="8-括号"><a class="markdownIt-Anchor" href="#8-括号"></a> 8) 括号</h4><p>下列关键字后必须有大括号（即使代码块的内容只有一行）：if, else,for, while, do, switch, try, catch, finally, with。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// not good</span><br><span class="line">if (condition)</span><br><span class="line">    doSomething();</span><br><span class="line"></span><br><span class="line">// good</span><br><span class="line">if (condition) &#123;</span><br><span class="line">    doSomething();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="其他-2"><a class="markdownIt-Anchor" href="#其他-2"></a> 其他</h3><ul><li>不要混用tab和space；</li><li>不要在一处使用多个tab或space；</li><li>换行符统一用’LF’；</li><li>对上下文this的引用只能使用’_this’, ‘that’, 'self’其中一个来命名；</li><li>行尾不要有空白字符；</li><li>switch的falling through和no default的情况一定要有注释特别说明；</li><li>不允许有空的代码块。</li></ul><h2 id="五-vue规范"><a class="markdownIt-Anchor" href="#五-vue规范"></a> 五、VUE规范</h2><p>vue 项目规范以Vue官网规范（ <a href="https://cn.vuejs.org/v2/style-guide">https://cn.vuejs.org/v2/style-guide</a> ）中的A规范为基础，在其上班进行项目开发，故所以代码均遵守该规范。</p><blockquote><p>请仔仔细细阅读Vue官方规范，切记，此为第一步。</p></blockquote><h3 id="1-组件规范"><a class="markdownIt-Anchor" href="#1-组件规范"></a> 1. 组件规范</h3><ol><li>组件名为多个单词；</li></ol><blockquote><p>组件名应该始终是多个单词组成（大于等于2），且命名规范为KebabCase格式。<br />这样做可以避免跟现有的以及未来的HTML元素冲突，因为所以的HTML元素名称都是单个单词的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正例</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;TodoItem&#x27;</span>,</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 反例</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Todo&#x27;</span>,</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;todo-item&#x27;</span>,</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><ol start="2"><li>组件文件名为大驼峰格式；</li></ol><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 正例</span></span><br><span class="line">components /</span><br><span class="line">|- MyComponent.vue</span><br><span class="line"></span><br><span class="line"><span class="comment"># 反例</span></span><br><span class="line">components /</span><br><span class="line">|- myComponent.vue</span><br><span class="line">|- my-component.vue</span><br></pre></td></tr></table></figure></blockquote><ol start="3"><li>基础组件文件名为base开头，使用完整单词，而不是缩写；</li></ol><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 正例</span></span><br><span class="line">components /</span><br><span class="line">|- base-button.vue</span><br><span class="line">|- base-table.vue</span><br><span class="line">|- base-icon.vue</span><br><span class="line"></span><br><span class="line"><span class="comment"># 反例</span></span><br><span class="line">components /</span><br><span class="line">|- MyButton.vue</span><br><span class="line">|- VueTable.vue</span><br><span class="line">|- Icon.vue</span><br></pre></td></tr></table></figure></blockquote><ol start="4"><li>和父组件紧密耦合的子组件应该以父组件名作为前缀命名；</li></ol><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 正例</span></span><br><span class="line">components /</span><br><span class="line">|- todo-list.vue</span><br><span class="line">|- todo-list-item.vue</span><br><span class="line">|- todo-list-item-button.vue</span><br><span class="line">|- user-profile-options.vue  <span class="comment"># (完整单词)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 反例</span></span><br><span class="line">components /</span><br><span class="line">|- TodoList.vue</span><br><span class="line">|- TodoItem.vue</span><br><span class="line">|- TodoButton.vue</span><br><span class="line">|- UProfOpts.vue           <span class="comment"># (使用来缩写)</span></span><br></pre></td></tr></table></figure></blockquote><ol start="5"><li>在template 模版中使用组件，应使用PascalCase模式，并且使用自闭组件；</li></ol><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 正例 --&gt;</span><br><span class="line">&lt;!-- 在单文件组件、字符串模版和JSX中 --&gt;</span><br><span class="line">&lt;MyComponent /&gt;</span><br><span class="line">&lt;Row&gt;&lt;table :column=&quot;data&quot; /&gt;&lt;/Row&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 反例 --&gt;</span><br><span class="line">&lt;my-component /&gt;</span><br><span class="line">&lt;row&gt;&lt;table :column=&quot;data&quot; /&gt;&lt;/row&gt;</span><br></pre></td></tr></table></figure></blockquote><ol start="6"><li>组件的data必须是一个函数；</li></ol><blockquote><p>当在组件中使用data属性的时候（除了new Vue外的任何地方），它的值必须是返回一个对象的函数。<br />因为如果直接是一个对象的化，子组件之间的属性值会相互影响。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正例</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  data () &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&#x27;jack&#x27;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 反例</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;jack&#x27;</span>,</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><ol start="7"><li>Prop 定义应该尽量详细</li></ol><blockquote><ol><li>必须使用camelCase驼峰命名；</li><li>必须指定类型；</li><li>必须加上注释，表面其含义；</li><li>必须加上required 或者 default，两者二选其一；</li><li>如果有业务需要，必须加上validator 验证；</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正例</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">props</span>: &#123;</span><br><span class="line">    <span class="comment">// 组件状态，用于控制组件的颜色</span></span><br><span class="line">    <span class="attr">status</span>: &#123;</span><br><span class="line">      <span class="attr">type</span>: <span class="title class_">String</span>,</span><br><span class="line">      <span class="attr">required</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">validator</span>: <span class="keyword">function</span> (<span class="params">value</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> [</span><br><span class="line">          <span class="string">&#x27;succ&#x27;</span>,</span><br><span class="line">          <span class="string">&#x27;info&#x27;</span>,</span><br><span class="line">          <span class="string">&#x27;error&#x27;</span>,</span><br><span class="line">        ].<span class="title function_">indexOf</span>(vaule) !== -<span class="number">1</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 用户级别，用于显示皇冠个数</span></span><br><span class="line">    <span class="attr">userLevel</span>: &#123;</span><br><span class="line">      <span class="attr">type</span>: <span class="title class_">String</span>,</span><br><span class="line">      <span class="attr">required</span>: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><ol start="8"><li>为组件样式设置作用域</li></ol><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;button class=&quot;btn btn-close&quot;&gt;X&lt;/button&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 正例：使用‘scoped’特性 --&gt;</span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">.btn-close &#123;</span><br><span class="line">  color: red</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure></blockquote><ol start="9"><li>如果特性元素较多时，应该主动换行。</li></ol><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 正例 --&gt;</span><br><span class="line">&lt;MyComponent </span><br><span class="line">  foo=&quot;a&quot;</span><br><span class="line">  bar=&quot;b&quot;</span><br><span class="line">  baz=&quot;c&quot;</span><br><span class="line">/&gt;</span><br><span class="line">&lt;!-- 反例 --&gt;</span><br><span class="line">&lt;MyComponent foo=&quot;a&quot; bar=&quot;b&quot; baz=&quot;c&quot; /&gt;</span><br></pre></td></tr></table></figure></blockquote><h3 id="2-模版中使用简单的表达式"><a class="markdownIt-Anchor" href="#2-模版中使用简单的表达式"></a> 2. 模版中使用简单的表达式</h3><p>组件模版应该只包含简单的表达式，复杂的表达式则应该重构为计算属性或方法。</p><blockquote><p>复杂的表达式会让你的模版变得不那么声明式，我们应该尽量描述应该出现的是什么，而非如何计算那个值，而且计算属性和方法使得代码可以重用。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 正例 --&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;p&gt;&#123;&#123; normalizedFullName &#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  // 复杂表达式已经移入一个计算属性</span><br><span class="line">  computed: &#123;</span><br><span class="line">    normalizedFullName () &#123;</span><br><span class="line">      return this.fullName.split(&#x27; &#x27;).map((word) =&gt; word[0].toUpperCase() + word.slice(1)).join(&#x27; &#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 反例 --&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;p&gt;&#123;&#123; fullName.split(&#x27; &#x27;).map((word) =&gt; word[0].toUpperCase() + word.slice(1)).join(&#x27; &#x27;) &#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><h3 id="3-指令都使用缩写形式"><a class="markdownIt-Anchor" href="#3-指令都使用缩写形式"></a> 3. 指令都使用缩写形式</h3><p>指令推荐都使用缩写形式</p><ul><li>用&quot;:“表示&quot;v-bind”</li><li>用&quot;@“表示&quot;v-on”</li><li>用&quot;#“表示&quot;v-slot”</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 正例 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> </span></span><br><span class="line"><span class="tag">  @<span class="attr">input</span>=<span class="string">&quot;onInput&quot;</span></span></span><br><span class="line"><span class="tag">  @<span class="attr">focus</span>=<span class="string">&quot;onFocus&quot;</span></span></span><br><span class="line"><span class="tag">/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 反例 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> </span></span><br><span class="line"><span class="tag">  <span class="attr">v-on:input</span>=<span class="string">&quot;onInput&quot;</span></span></span><br><span class="line"><span class="tag">  @<span class="attr">focus</span>=<span class="string">&quot;onFocus&quot;</span></span></span><br><span class="line"><span class="tag">/&gt;</span></span><br></pre></td></tr></table></figure><h3 id="4-标签顺序必须保持一致"><a class="markdownIt-Anchor" href="#4-标签顺序必须保持一致"></a> 4. 标签顺序必须保持一致</h3><p>单文件组件应该总是让标签顺序保持为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;&lt;/template&gt;</span><br><span class="line">&lt;script&gt;&lt;/script&gt;</span><br><span class="line">&lt;style&gt;&lt;/style&gt;</span><br></pre></td></tr></table></figure><h3 id="5-必须为-v-for-设置健值-key"><a class="markdownIt-Anchor" href="#5-必须为-v-for-设置健值-key"></a> 5. 必须为 v-for 设置健值 key</h3><h3 id="6-v-show-与-v-if-选择"><a class="markdownIt-Anchor" href="#6-v-show-与-v-if-选择"></a> 6. v-show 与 v-if 选择</h3><blockquote><p>如果运行时，需要非常频繁地切换，使用v-show；<br />如果运行时，条件很少改变，使用 v-if；</p></blockquote><h3 id="7-避免-v-if-和-v-for-用在一起"><a class="markdownIt-Anchor" href="#7-避免-v-if-和-v-for-用在一起"></a> 7. 避免 v-if 和 v-for 用在一起</h3><blockquote><h4 id="永远不要把-v-if-和-v-for-同时用在同一个元素上"><a class="markdownIt-Anchor" href="#永远不要把-v-if-和-v-for-同时用在同一个元素上"></a> 永远不要把 v-if 和 v-for 同时用在同一个元素上。</h4><p>一般我们在两种常见的情况下会倾向于这样做：</p><ul><li>为了过滤一个列表中的项目 (比如 v-for=“user in users” v-if=“user.isActive”)。在这种情形下，请将 users 替换为一个计算属性 (比如 activeUsers)，让其返回过滤后的列表。</li><li>为了避免渲染本应该被隐藏的列表 (比如 v-for=“user in users” v-if=“shouldShowUsers”)。这种情形下，请将 v-if 移动至容器元素上 (比如 ul、ol)。</li></ul></blockquote><h3 id="8-script标签内部结构顺序"><a class="markdownIt-Anchor" href="#8-script标签内部结构顺序"></a> 8. script标签内部结构顺序</h3><blockquote><p>components &gt; props &gt; data &gt; computed &gt; watch &gt; filter &gt; 钩子函数(钩子函数按其执行顺序) &gt; methods</p></blockquote><h2 id="vue-router-规范"><a class="markdownIt-Anchor" href="#vue-router-规范"></a> Vue Router 规范</h2><h3 id="1-页面跳转数据传递使用路由参数"><a class="markdownIt-Anchor" href="#1-页面跳转数据传递使用路由参数"></a> 1. 页面跳转数据传递使用路由参数</h3><blockquote><p>页面跳转，例如 A 页面跳转到 B 页面，需要将 A 页面的数据传递到 B 页面，推荐使用路由参数进行传参，而不是将需要传递的数据保存 vuex，然后在 B 页面取出 vuex 的数据，因为如果在 B 页面刷新会导致 vuex 数据丢失，导致 B 页面无法正常显示数据。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> id = <span class="string">&#x27;123&#x27;</span>;</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">push</span>(&#123; <span class="attr">name</span>: <span class="string">&#x27;userCenter&#x27;</span>, <span class="attr">query</span>: &#123; <span class="attr">id</span>: id &#125; &#125;);</span><br></pre></td></tr></table></figure></blockquote><h3 id="2-使用路由懒加载延迟加载机制"><a class="markdownIt-Anchor" href="#2-使用路由懒加载延迟加载机制"></a> 2. 使用路由懒加载（延迟加载）机制</h3><blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">path</span>: <span class="string">&#x27;/uploadAttachment&#x27;</span>,</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;uploadAttachment&#x27;</span>,</span><br><span class="line">  <span class="attr">meta</span>: &#123;</span><br><span class="line">    <span class="attr">title</span>: <span class="string">&#x27;上传组件&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;@/views/uploadAttachment.vue&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h3 id="3-router-中的命名规范"><a class="markdownIt-Anchor" href="#3-router-中的命名规范"></a> 3. router 中的命名规范</h3><blockquote><ol><li>path、chilrenPoints 命名规范采用 kebab-case 命名规范（尽量vue文件的目录结构保持一致，因为目录、文件名都是 kebab-case，这样很方便找到对应的文件）</li><li>name 命名规范采用 kebabCase 命名规范，且和 component 组件名保持一致！（因为要保持 keep-alive 特性，keep-alive 按照 component 的 name 进行缓存，所以两者必须高度保持一致）</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 动态加载</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> reload = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;/reload&#x27;</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;reload&#x27;</span>,</span><br><span class="line">    <span class="attr">component</span>: <span class="title class_">Main</span>,</span><br><span class="line">    <span class="attr">meta</span>: &#123;</span><br><span class="line">      <span class="attr">title</span>: <span class="string">&#x27;动态加载&#x27;</span>,</span><br><span class="line">      <span class="attr">icon</span>: <span class="string">&#x27;icon iconfont&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">children</span>: &#123;</span><br><span class="line">      <span class="attr">path</span>: <span class="string">&#x27;/reload/smart-reload-list&#x27;</span>,</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&#x27;smartReloadList&#x27;</span>,</span><br><span class="line">      <span class="attr">component</span>: <span class="title class_">Main</span>,</span><br><span class="line">      <span class="attr">meta</span>: &#123;</span><br><span class="line">        <span class="attr">title</span>: <span class="string">&#x27;动态加载&#x27;</span>,</span><br><span class="line">        <span class="attr">icon</span>: <span class="string">&#x27;icon iconfont&#x27;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;@/views/reload/smart-reload-list.vue&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></blockquote><h3 id="vue-项目目录规范"><a class="markdownIt-Anchor" href="#vue-项目目录规范"></a> Vue 项目目录规范</h3><h3 id="1-基础"><a class="markdownIt-Anchor" href="#1-基础"></a> 1. 基础</h3><blockquote><p>vue项目中的所有命名一定要和后端命名统一；</p><blockquote><p>比如权限：后端privilege，前端物理router，store，api等都必须使用privielege单词</p></blockquote></blockquote><h3 id="2-使用-vue-cli-脚手架"><a class="markdownIt-Anchor" href="#2-使用-vue-cli-脚手架"></a> 2. 使用 vue-cli 脚手架</h3><blockquote><p>使用 vue-cli4 版本的脚手架来初始化项目。</p></blockquote><h3 id="3-目录说明"><a class="markdownIt-Anchor" href="#3-目录说明"></a> 3. 目录说明</h3><blockquote><p>目录名按照上面的命名规范，其中 components 组件用大写驼峰，其余除 components 组件目录外的所以目录均使用 kebab-case 命名。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">- mock    <span class="comment"># mock服务，后期会添加mockjs，加强mock的能力</span></span><br><span class="line">- publish <span class="comment"># 公共目录，可以放一些需要放跟目录下文件可以直接拷贝到这边</span></span><br><span class="line">- src     <span class="comment"># 源代码目录</span></span><br><span class="line">    - api        <span class="comment"># 公共的api接口文件夹，放组件里的接口或其他公共地方需要使用的接口，即非页面级的接口，方便统一管理</span></span><br><span class="line">    - assets     <span class="comment"># 静态资源目录</span></span><br><span class="line">    - components <span class="comment"># 公共组件目录，非页面级组件目录</span></span><br><span class="line">    - filters    <span class="comment"># vue的filters组件目录</span></span><br><span class="line">    - layout     <span class="comment"># 项目的layout放置目录</span></span><br><span class="line">      - index.js <span class="comment"># 默认的layout 可以给多个layout使用，前提需在router/index.js上配置</span></span><br><span class="line">    - router     <span class="comment"># 路由目录</span></span><br><span class="line">      - index.js <span class="comment"># 当有新的layout出现时，需在此文件添加你的layout，并指定layout</span></span><br><span class="line">      - routes.js <span class="comment"># 会自动去找views目录下的routes.js文件，并通过layout参数区分不同的routes</span></span><br><span class="line">    - styles     <span class="comment"># 公共样式目录</span></span><br><span class="line">    - utils      <span class="comment"># 公共工具目录</span></span><br><span class="line">    - views      <span class="comment"># 项目页面</span></span><br><span class="line">      - admin    <span class="comment"># layout为默认的layout，命名为admin的页面目录，访问路径为：/admin/xxx/xxx</span></span><br><span class="line">        - home   <span class="comment"># layout 为admin的某一导航栏内容，包括改导航栏的一二级导航， 访问路径为：/admin/home/xxx</span></span><br><span class="line">      - login    <span class="comment"># 页面的登录页面，后期单点登录项目上线后，会修改</span></span><br><span class="line">      - <span class="built_in">test</span>     <span class="comment"># 供给大家参考的目录，包括两个列表页面，后期会添加更多页面供大家拷贝，查看页面路径：/test</span></span><br><span class="line">    - App.vue    <span class="comment"># vue的入口文件</span></span><br><span class="line">    - main.js    <span class="comment"># 项目的入口文件</span></span><br><span class="line">    - defaultSettings.js <span class="comment"># 公共的配置文件</span></span><br><span class="line">    - registerServiceWorker.js <span class="comment"># pwa文件</span></span><br></pre></td></tr></table></figure></blockquote><h3 id="4-views-页面结构说明"><a class="markdownIt-Anchor" href="#4-views-页面结构说明"></a> 4. views 页面结构说明</h3><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">views/xxx <span class="comment"># layout名字一样的集合，admin为admin的集合，test为test的集合，命名是在views下面的route.js里</span></span><br><span class="line">views/test/xxx <span class="comment"># test集合下的某一级导航，里面包含各种二级页面</span></span><br><span class="line">views/test/list <span class="comment"># test集合下的list测试列表</span></span><br><span class="line">  - components <span class="comment"># 该级下的组件文件夹</span></span><br><span class="line">  - api.js     <span class="comment"># 该级下的api集合</span></span><br><span class="line">  - index.vue,detail.vue <span class="comment"># 该级下的页面，也可以建一个目录放置</span></span><br><span class="line">  - mock.js    <span class="comment"># 该级下的本地mock数据，目前只是简单的mock，后期会添加mockjs加强处理mock数据</span></span><br><span class="line">  - routes.js  <span class="comment"># 该级下的路由，使用参考/views/test/list/routes.js</span></span><br></pre></td></tr></table></figure></blockquote><h3 id="5-注释说明"><a class="markdownIt-Anchor" href="#5-注释说明"></a> 5. 注释说明</h3><blockquote><p>整理必须加注释的地方</p><ul><li>公共组件使用说明</li><li>api目录的接口js文件必须加注释</li><li>store 中的 state，mutation，action 等必须加注释</li><li>vue 文件中的template 必须加注释，若文件较大加start，end注释</li><li>vue 文件的methods，每个method必须加注释</li><li>vue 文件的data，非常常见的单词要加注释</li></ul></blockquote><h3 id="6-其他"><a class="markdownIt-Anchor" href="#6-其他"></a> 6. 其他</h3><blockquote><ol><li>尽量不要手动操作 DOM</li></ol><blockquote><p>因使用vue框架，所以在项目开发中，尽量使用 vue 的数据驱动更新 DOM，尽量（不到万不得已）不要手动操作 DOM，包括：增删改 DOM 的元素，以及更改样式，添加事件等。</p></blockquote><ol start="2"><li>删除无用代码</li></ol><blockquote><p>因使用了 git 代码管理工具，对于无用代码必须及时删除，例如：一些调用的 console 语句、无用的弃用功能代码。</p></blockquote></blockquote><h3 id="参考文档"><a class="markdownIt-Anchor" href="#参考文档"></a> 参考文档</h3><blockquote><ol><li><a href="https://www.cnblogs.com/Hsong/p/9016950.html">js命名规范</a></li><li><a href="https://blog.51cto.com/13507333/2052369">前端开发规范：命名规范、html规范、css规范、js规范</a></li></ol></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一-命名规范&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#一-命名规范&quot;&gt;&lt;/a&gt; 一、命名规范&lt;/h2&gt;
&lt;p&gt;&lt;font color=&quot;red&quot;&gt;注意： 项目名，文件名不能包含 /:?&amp;lt;&amp;gt;| 等特殊符号（windows</summary>
      
    
    
    
    <category term="前端开发" scheme="http://www.amaoc.cn/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="开发规范" scheme="http://www.amaoc.cn/tags/%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/"/>
    
  </entry>
  
  <entry>
    <title>深拷贝与浅拷贝</title>
    <link href="http://www.amaoc.cn/2023/11/28/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D/"/>
    <id>http://www.amaoc.cn/2023/11/28/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D/</id>
    <published>2023-11-28T03:37:46.759Z</published>
    <updated>2024-03-04T10:17:19.337Z</updated>
    
    <content type="html"><![CDATA[<h2 id="如何区分深拷贝和浅拷贝"><a class="markdownIt-Anchor" href="#如何区分深拷贝和浅拷贝"></a> 如何区分深拷贝和浅拷贝</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">假设B复制了A;</span><br><span class="line">当修改了A时，看B是否会发生变化;</span><br><span class="line">如果B也跟着变了，说明这是浅拷贝;</span><br><span class="line">如果B没变，那就是深拷贝。</span><br></pre></td></tr></table></figure><h2 id="基本数据与复杂引用数据"><a class="markdownIt-Anchor" href="#基本数据与复杂引用数据"></a> 基本数据与复杂（引用）数据</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">基本数据类型：number,string,boolean,null,undefined,symbol(ES6),BigInt(ES10);  </span><br><span class="line">引用数据类型：Object,Array,function</span><br></pre></td></tr></table></figure><h3 id="1基本数据类型名值存储在栈内存中"><a class="markdownIt-Anchor" href="#1基本数据类型名值存储在栈内存中"></a> 1.基本数据类型名值存储在栈内存中</h3><p>例如： let a = 1;<br /><img src="/imgs/1.jpg" alt="图片" /></p><p>当你b=a复制时，栈内存会新开辟一个内存<br /><img src="/imgs/2.jpg" alt="图片" /></p><p>所以当你此时修改a=2时，对b并不会对a造成影响，所以深拷贝本身只针对较为复杂的引用数据类型。</p><h3 id="2引用数据类型名存在栈内存中而值却存在于堆内存中栈内存会提供一个引用的地址指向堆内存中的值"><a class="markdownIt-Anchor" href="#2引用数据类型名存在栈内存中而值却存在于堆内存中栈内存会提供一个引用的地址指向堆内存中的值"></a> 2.引用数据类型名存在栈内存中，而值却存在于堆内存中，栈内存会提供一个引用的地址指向堆内存中的值</h3><p>例如： let a = [0,1,2,3,4]<br /><img src="/imgs/3.jpg" alt="图片" /></p><p>当b=a进行拷贝时，其实复制的是a的引用地址，而并非是堆内存里面的值<br /><img src="/imgs/4.jpg" alt="图片" /></p><p>而当我们修改a[0]=1时，由于a与b指向的是同一个地址，所以自然b也受到了影响，这就是浅拷贝了。<br /><img src="/imgs/5.jpg" alt="图片" /></p><p>那么，我们如何在堆内存中也开辟一个新的内存专门为b存放值，就像基本类型一样，就能达到深拷贝了。<br /><img src="/imgs/6.jpg" alt="图片" /></p><h2 id="如何实现浅拷贝"><a class="markdownIt-Anchor" href="#如何实现浅拷贝"></a> 如何实现浅拷贝</h2><ol><li>for…in只循环第一层</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只复制第一层的浅拷贝</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">simpleCopy</span>(<span class="params">obj1</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> obj2 = <span class="title class_">Array</span>.<span class="title function_">isArray</span>(obj1)?[]:&#123;&#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> obj1) &#123;</span><br><span class="line">    obj2[i] = obj1[i]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> obj2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;<span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>, <span class="attr">c</span>: &#123; <span class="attr">d</span>: <span class="number">3</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">var</span> obj2 = <span class="title function_">simpleCopy</span>(obj1);</span><br><span class="line">obj2.<span class="property">a</span> = <span class="number">3</span>;</span><br><span class="line">obj2.<span class="property">c</span>.<span class="property">d</span> = <span class="number">4</span>;</span><br><span class="line"><span class="comment">// # obj1.a       1;</span></span><br><span class="line"><span class="comment">// # obj2.a       3;</span></span><br><span class="line"><span class="comment">// # obj1.c.d     4;</span></span><br><span class="line"><span class="comment">// # obj2.c.d     4;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>Object.assign</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>&#125;</span><br><span class="line"><span class="keyword">var</span> obj1 = <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, obj);</span><br><span class="line"></span><br><span class="line">obj1.<span class="property">a</span> = <span class="number">3</span>;</span><br><span class="line"><span class="comment">// # obj.a       1;</span></span><br></pre></td></tr></table></figure><ol start="3"><li>直接用=赋值</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line"><span class="keyword">let</span> b = a;</span><br><span class="line"></span><br><span class="line"><span class="comment">// # a === b       true;</span></span><br><span class="line">a[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// # b[0]        1;</span></span><br></pre></td></tr></table></figure><h2 id="如何实现深拷贝"><a class="markdownIt-Anchor" href="#如何实现深拷贝"></a> 如何实现深拷贝</h2><ol><li>采用递归去拷贝所以层级属性</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">deepClone</span> (obj) &#123;</span><br><span class="line">  <span class="keyword">let</span> objClone = <span class="title class_">Array</span>.<span class="title function_">isArray</span>(obj) ? [] : &#123;&#125;;</span><br><span class="line">  <span class="keyword">if</span>(obj &amp;&amp; <span class="keyword">typeof</span> obj === <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">      <span class="keyword">if</span>(obj.<span class="title function_">hasOwnProperty</span>(key)) &#123;</span><br><span class="line">        <span class="comment">// # 判断obj子元素是否为对象，如果是，递归复制</span></span><br><span class="line">        <span class="keyword">if</span>(obj[key] &amp;&amp; type obj[key] === <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">          objClone[key] = <span class="title function_">deepClone</span>(obj[key]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// # 如果不是，简单复制</span></span><br><span class="line">          objClone[key] = obj[key];</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> objClone;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line"><span class="keyword">let</span> b = <span class="title function_">deepClone</span>(a);</span><br><span class="line">a[<span class="number">0</span>] = <span class="number">2</span>;</span><br><span class="line"><span class="comment">// # b[0]   1;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>通过JSON对象来实现深拷贝</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">deepClone2</span> (obj) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(obj));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>缺点：无法实现对象中方法的深拷贝，会显示为undefined;</p><ol start="3"><li>通过Jquery的extend方法实现深拷贝</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line"><span class="keyword">let</span> newArr = $.<span class="title function_">extend</span>(<span class="literal">true</span>, [], arr);</span><br></pre></td></tr></table></figure><ol start="4"><li>通过lodash函数实现深拷贝</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result = _.<span class="title function_">cloneDeep</span>(test);</span><br></pre></td></tr></table></figure><ol start="5"><li>Reflect法</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// # 代理法</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">deepClone</span> (obj) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="title function_">isObject</span>(obj)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;obj 不是一个对象&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> isArray = <span class="title class_">Array</span>.<span class="title function_">isArray</span>(obj);</span><br><span class="line">  <span class="keyword">let</span> cloneObj = isArray ? [...obj] : &#123; ...obj &#125;;</span><br><span class="line">  <span class="title class_">Reflect</span>.<span class="title function_">ownKeys</span>(cloneObj).<span class="title function_">forEach</span>(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">    cloneObj[key] = <span class="title function_">isObject</span>(obj[key]) ? <span class="title function_">deepClone</span>(obj[key]) : obj[key];</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> cloneObj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考文案"><a class="markdownIt-Anchor" href="#参考文案"></a> 参考文案</h2><ol><li><a href="https://www.jianshu.com/p/1c142ec2ca45">js浅拷贝与深拷贝的区别和实现方式</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;如何区分深拷贝和浅拷贝&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#如何区分深拷贝和浅拷贝&quot;&gt;&lt;/a&gt; 如何区分深拷贝和浅拷贝&lt;/h2&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;</summary>
      
    
    
    
    <category term="前端开发" scheme="http://www.amaoc.cn/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="js" scheme="http://www.amaoc.cn/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>观察者模式和发布-订阅模式</title>
    <link href="http://www.amaoc.cn/2023/11/28/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%8F%91%E5%B8%83(%E8%AE%A2%E9%98%85)%E6%A8%A1%E5%BC%8F/"/>
    <id>http://www.amaoc.cn/2023/11/28/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%8F%91%E5%B8%83(%E8%AE%A2%E9%98%85)%E6%A8%A1%E5%BC%8F/</id>
    <published>2023-11-28T03:37:46.759Z</published>
    <updated>2023-11-28T03:37:46.760Z</updated>
    
    <content type="html"><![CDATA[<h2 id="观察者模式和发布订阅模式"><a class="markdownIt-Anchor" href="#观察者模式和发布订阅模式"></a> 观察者模式和发布/订阅模式</h2><blockquote><h3 id="观察者模式"><a class="markdownIt-Anchor" href="#观察者模式"></a> 观察者模式</h3><p>目标和观察者是基类，目标提供维护观察者的一系列方法，观察者提供更新接口。具体观察者和具体目标继承各自的基类，然后具体观察者把自己注册到具体目标里，在具体目标发生变化时候，调度观察者的更新方法。<br /><img src="/imgs/1.png" alt="观察者模式" /><br />观察者模式实现代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 观察者列表</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">ObserverList</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">observerList</span> = [];</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">ObserverList</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">add</span> = <span class="keyword">function</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">observerList</span>.<span class="title function_">push</span>(obj);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">ObserverList</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">count</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">observerList</span>.<span class="property">length</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">ObserverList</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">get</span> = <span class="keyword">function</span>(<span class="params">index</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span>(index &gt; -<span class="number">1</span> &amp;&amp; index &lt; <span class="variable language_">this</span>.<span class="property">observerList</span>.<span class="property">length</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">observerList</span>[index];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">ObserverList</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">indexOf</span> = <span class="keyword">function</span>(<span class="params">obj, startIndex</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> i = startIndex || <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(i &lt; <span class="variable language_">this</span>.<span class="property">observerList</span>.<span class="property">length</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="property">observerList</span>[i] === obj) &#123;</span><br><span class="line">      <span class="keyword">return</span> i</span><br><span class="line">    &#125;</span><br><span class="line">    i++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">ObserverList</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">removeAt</span> = <span class="keyword">function</span>(<span class="params">index</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">observerList</span>.<span class="title function_">splice</span>(index, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.目标</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Subject</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">observers</span> = <span class="keyword">new</span> <span class="title class_">ObserverList</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Subject</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">addObserver</span> = <span class="keyword">function</span>(<span class="params">observer</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">observers</span>.<span class="title function_">add</span>(observer);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Subject</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">removeObserver</span> = <span class="keyword">function</span>(<span class="params">observer</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">observers</span>.<span class="title function_">removeAt</span>(<span class="variable language_">this</span>.<span class="property">observers</span>.<span class="title function_">indexOf</span>(observer, <span class="number">0</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Subject</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">notify</span> = <span class="keyword">function</span>(<span class="params">context</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> observerCount = <span class="variable language_">this</span>.<span class="property">observers</span>.<span class="title function_">count</span>();</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; observerCount; i++) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">observers</span>.<span class="title function_">get</span>(i).<span class="title function_">update</span>(context);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.观察者</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Observer</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">update</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用范例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// html </span></span><br><span class="line"><span class="comment">// &lt;button id=&quot;addNewObjserver&quot;&gt;add New Observer checkBox&lt;/button&gt;</span></span><br><span class="line"><span class="comment">// </span></span><br></pre></td></tr></table></figure></blockquote><blockquote><h3 id="发布订阅模式"><a class="markdownIt-Anchor" href="#发布订阅模式"></a> 发布/订阅模式</h3><p>订阅者把自己想订阅的事件注册到调度中心，当该事件触发的时候，发布者发布该事件到调度中心，由调度中心同意调度订阅者注册到调度中心的处理代码。<br /><img src="/imgs/2.png" alt="发布/订阅模式" /><br />发布/订阅模式实现代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pubsub = &#123;&#125;;</span><br><span class="line">(<span class="keyword">function</span>(<span class="params">myObject</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> topics = &#123;&#125;;</span><br><span class="line">  <span class="keyword">var</span> subUid = -<span class="number">1</span>;</span><br><span class="line">  myObject.<span class="property">publish</span> = <span class="keyword">function</span>(<span class="params">topic, args</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!topics[topic]) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> subscribers = topics[topic];</span><br><span class="line">    <span class="keyword">var</span> len = subscribers ? subscribers.<span class="property">length</span> : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (len--) &#123;</span><br><span class="line">      subscribers[len].<span class="title function_">func</span>(topic, func);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">  myObject.<span class="property">subscribe</span> = <span class="keyword">function</span>(<span class="params">topic, func</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!topics[topic]) &#123;</span><br><span class="line">      topics[topic] = [];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> token = (++subUid).<span class="title function_">toString</span>();</span><br><span class="line">    topics[topic].<span class="title function_">push</span>(&#123;</span><br><span class="line">      <span class="attr">token</span>: token,</span><br><span class="line">      <span class="attr">func</span>: func</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> token;</span><br><span class="line">  &#125;</span><br><span class="line">  myObject.<span class="property">unsubscribe</span> = <span class="keyword">function</span>(<span class="params">token</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> m <span class="keyword">in</span> topics) &#123;</span><br><span class="line">      <span class="keyword">if</span>(topics[m]) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>, j = topics[m].<span class="property">length</span>; i &lt; j; i++) &#123;</span><br><span class="line">          <span class="keyword">if</span>(topics[m][i].<span class="property">token</span> === token) &#123;</span><br><span class="line">            topics[m].<span class="title function_">splice</span>(i, <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> token;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)(pubsub)</span><br></pre></td></tr></table></figure></blockquote><blockquote><h3 id="参考文档"><a class="markdownIt-Anchor" href="#参考文档"></a> 参考文档</h3><ol><li><a href="https://www.jianshu.com/p/594f018b68e7">观察者模式和发布订阅模式的区别</a></li><li><a href="https://www.jianshu.com/p/9f2c8ae57cac">设计模式学习之观察者模式和发布订阅模式</a></li><li><a href="https://www.cnblogs.com/lovesong/p/5272752.html">观察者模式与发布/订阅模式区别</a></li><li><a href="https://www.jianshu.com/p/2f94d7596522">JS设计模式2-发布／订阅模式和观察者模式</a></li></ol></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;观察者模式和发布订阅模式&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#观察者模式和发布订阅模式&quot;&gt;&lt;/a&gt; 观察者模式和发布/订阅模式&lt;/h2&gt;
&lt;blockquote&gt;
&lt;h3 id=&quot;观察者模式&quot;&gt;&lt;a class=&quot;markdo</summary>
      
    
    
    
    <category term="前端开发" scheme="http://www.amaoc.cn/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="js" scheme="http://www.amaoc.cn/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>domain实现跨域</title>
    <link href="http://www.amaoc.cn/2023/11/28/domain%E4%BD%BF%E7%94%A8/"/>
    <id>http://www.amaoc.cn/2023/11/28/domain%E4%BD%BF%E7%94%A8/</id>
    <published>2023-11-28T03:37:46.758Z</published>
    <updated>2023-11-28T03:37:46.758Z</updated>
    
    <content type="html"><![CDATA[<h2 id="domain实现跨域"><a class="markdownIt-Anchor" href="#domain实现跨域"></a> domain实现跨域</h2><blockquote><p>因项目需要，需要跨域，而且是在同一个基础域名下，就选择domain来实现，过程较为简单。</p></blockquote><h3 id="前提条件"><a class="markdownIt-Anchor" href="#前提条件"></a> 前提条件</h3><blockquote><p>需跨域的两个域名必须属于同一个基础域名，而且所用的协议(http或https)，端口号必须要一致。否则无法利用document.domain进行跨域。</p><blockquote><ol><li>JavaScript出于对安全性的考虑，而禁止两个或者多个不同域名的页面进行相互操作。</li><li>相同的页面在相互操作的时候，是不会任何有问题的。</li></ol></blockquote></blockquote><h3 id="iframe之间的操作"><a class="markdownIt-Anchor" href="#iframe之间的操作"></a> iframe之间的操作</h3><blockquote><p>例如：</p><blockquote><p>aaa.com的一个网页中（a.html），利用iframe引入来一个bbb.com里的页面（b.html）<br />这时候在a.html中可以看到b.html的内容，但是却不能利用javascript来操作它。因为这两个页面属于不同的域，在操作之前，js会检测两个页面的域是否相等，如果相等，就允许操作，如果不相等，就会拒绝操作。<br />这里不可能把a.html与b.html利用JavaScript改成同一个域。因为它们的基础域名不相等。（强制用JavaScript将它们改成相等的域的话，会报“参数无效错误。”）</p></blockquote><p>另外一种情况：</p><blockquote><p>如果两个子域名：<a href="http://aaa.xxx.xn--combbb-k76j.xxx.com">aaa.xxx.com和bbb.xxx.com</a>；aaa里的页面（a.html）引入里bbb里的一个网页（b.html），这时a.html里同样不能操作b.html里面的内容。因为document.domain不一样，<a href="http://xn--aaa-p18dohm08k.xxx.com">一个是aaa.xxx.com</a>，<a href="http://xn--bbb-p18doh593avnjqk1a.xxx.com">另外一个是bbb.xxx.com</a>。</p></blockquote><p>这时我们就可以通过JavaScript，将两个页面的domain改成一样的。</p><blockquote><p>只需要在a.html里与b.html里都加入</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="property">domain</span> = <span class="string">&#x27;xxx.com&#x27;</span>;</span><br></pre></td></tr></table></figure></blockquote><p>这样两个页面就可以相互操作了。也就实现了同一基础域名之间的“跨域”；</p></blockquote><h3 id="cookie的domain"><a class="markdownIt-Anchor" href="#cookie的domain"></a> cookie的domain</h3><blockquote><p>cookie虽然是由一个网页所创建，但并不只是创建cookie的网页才能读取该cookie。<br />在默认情况下，与创建cookie的网页在同一个目录或者子目录下的所有网页都可以读取该cookie。但是如果在这个目录下还有子目录，要使在子目录中也可以访问。则需要使用path参数设置cookie。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test目录可以访问</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">cookie</span> = <span class="string">&quot;name=&quot;</span> + <span class="built_in">escape</span>(<span class="string">&quot;zhangsan&quot;</span>) + <span class="string">&quot;; path=/test&quot;</span></span><br><span class="line"><span class="comment">// 整个域名下都可以访问</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">cookie</span> = <span class="string">&quot;name=&quot;</span> + <span class="built_in">escape</span>(<span class="string">&quot;zhangsan&quot;</span>) + <span class="string">&quot;; path=/&quot;</span></span><br></pre></td></tr></table></figure></blockquote><blockquote><p>当如果在bbb.xxx.com域名下访问aaa.xxx.com里的cookie，就需要是用domain参数了。<br />例如，在aaa.xxx.com里设置cookie的domain，在bbb.xxx.com里就可以访问到了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意：domian基础域名参数前面最好带一个.</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">cookie</span> = <span class="string">&quot;name=&quot;</span> + <span class="built_in">escape</span>(<span class="string">&quot;zhangsan&quot;</span>) + <span class="string">&quot;; path=/; domain=.xxx.com&quot;</span></span><br></pre></td></tr></table></figure></blockquote><h3 id="参考文档"><a class="markdownIt-Anchor" href="#参考文档"></a> 参考文档</h3><blockquote><ol><li><a href="https://www.jb51.net/article/66497.htm">js设置document.domain实现跨域的注意点分析</a></li><li><a href="https://www.cnblogs.com/ricky_li/p/3365064.html">JavaScript中cookie的路径(path)和域(domain)</a></li></ol></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;domain实现跨域&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#domain实现跨域&quot;&gt;&lt;/a&gt; domain实现跨域&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;因项目需要，需要跨域，而且是在同一个基础域名下，就选择domain来实</summary>
      
    
    
    
    <category term="前端开发" scheme="http://www.amaoc.cn/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="js" scheme="http://www.amaoc.cn/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>js中null、undefined浅谈</title>
    <link href="http://www.amaoc.cn/2023/11/28/js%E4%B8%ADnull%E3%80%81undefined%E6%B5%85%E8%B0%88/"/>
    <id>http://www.amaoc.cn/2023/11/28/js%E4%B8%ADnull%E3%80%81undefined%E6%B5%85%E8%B0%88/</id>
    <published>2023-11-28T03:37:46.758Z</published>
    <updated>2024-03-04T10:18:12.805Z</updated>
    
    <content type="html"><![CDATA[<p>大多数计算机语言，有且只有一个表示“无”的值，比如，C语言的NULL，Java语言的null，Python语言的None，Ruby语言的nil。<br />为啥JavaScript语言居然有两个表示“无”的值：undefined和null</p><h3 id="历史原因"><a class="markdownIt-Anchor" href="#历史原因"></a> 历史原因</h3><p>1995年JavaScript诞生时，最初像Java一样，只设置了null作为表示“无”的值。<br />根据C语言的传统，null被设计成可以自动转为0。</p><p>但是Brendan Eich觉得这样做还不够，有两个原因：</p><ol><li><p>null像在Java里一样，被当成一个对象。但是，JavaScript的数据类型分成原始类型（primitive）和合成类型（complex）两大类，Brendan Eich觉得表示“无”的值最好不是对象。</p></li><li><p>JavaScript的最初版本没有包括错误处理机制，发生数据类型不匹配时，往往时自动转换类型或者默默地失败。Brendan Eich觉得，如果null自动转为0，很不容易发现错误。</p></li></ol><p>因此，Brendan Eich又设计了一个undefined。</p><h3 id="最初设计"><a class="markdownIt-Anchor" href="#最初设计"></a> 最初设计</h3><p>JavaScript的最初版本时这样区分的：</p><ol><li>null 是一个表示“无”的对象，转为数值时为0；</li><li>undefined 是一个表示“无”的原始值，转为数值是为NAN；</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Number</span>(<span class="literal">null</span>)</span><br><span class="line"><span class="comment">// # 0</span></span><br><span class="line"></span><br><span class="line"><span class="number">5</span> + <span class="literal">null</span></span><br><span class="line"><span class="comment">// # 5</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Number</span>(<span class="literal">undefined</span>)</span><br><span class="line"><span class="comment">// # NAN</span></span><br><span class="line"></span><br><span class="line"><span class="number">5</span> + <span class="literal">undefined</span></span><br><span class="line"><span class="comment">// # NAN</span></span><br></pre></td></tr></table></figure><h3 id="目前的用法"><a class="markdownIt-Anchor" href="#目前的用法"></a> 目前的用法</h3><p>按照最初的设计区分，在实践中很快就被证明不可行。实践中有很多需要注意的地方。</p><ol><li><p>null<br />null 是基本数据类型之一，值仅有一个，即为null。表示“空对象”（因此类型检测返回对象），即如果有对象就会是一个具体的对象，如果没有对象，就是null。<br />典型用法：</p><ol><li>作为函数的参数，表示该函数的参数不是对象；</li><li>作为对象的原型链的终点。</li></ol> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>)  <span class="comment">// null</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span>      <span class="comment">// Object</span></span><br></pre></td></tr></table></figure><p>如果定义一个变量准备在将来用来保存对象，那么最好将该变量初始化为null而不是其他值。</p></li><li><p>undefined<br />undefined 是基本数据类型之一，值仅有一个，即为undefined。表示“缺少值”（因此类型检测返回 undefined），即此处应该有一个值，但是还没有定义。<br />典型的用法：</p><ol><li>变量被声明来，但没有赋值是，就等于 undefined 。</li><li>调用函数时，应该提供的参数没有提供，该参数就是undefined。</li><li>对象没有赋值的属性，该属性的值为 undefined。</li><li>函数没有返回值，默认返回 undefined。</li></ol> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i;</span><br><span class="line"><span class="comment">// i undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">x</span>) &#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(x)&#125;</span><br><span class="line"><span class="title function_">f</span>()</span><br><span class="line"><span class="comment">// x undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="comment">// o.p undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x = <span class="title function_">f</span>();</span><br><span class="line"><span class="comment">// x undefined</span></span><br></pre></td></tr></table></figure></li><li><p>如何检测undefined</p></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="keyword">typeof</span> abc == <span class="string">&#x27;undefined&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="keyword">if</span>(abc === <span class="literal">undefined</span>)</span><br></pre></td></tr></table></figure><p>ps: typeof有两种用法: typeof(x) 或者 typeof x</p><ol start="4"><li>如何检测null</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!abc &amp;&amp; <span class="keyword">typeof</span> abc != <span class="string">&#x27;undefined&#x27;</span> &amp;&amp; abc !== <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (abc === <span class="literal">null</span>)</span><br></pre></td></tr></table></figure><h3 id="参考文档"><a class="markdownIt-Anchor" href="#参考文档"></a> 参考文档</h3><ol><li><a href="https://www.cnblogs.com/haishen/p/10718715.html">null 和 undefined 的区别</a></li><li><a href="https://cloud.tencent.com/developer/article/1534974">null 和 undefined</a></li><li><a href="http://www.ruanyifeng.com/blog/2014/03/undefined-vs-null.html">null 和 undefined 的区别</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;大多数计算机语言，有且只有一个表示“无”的值，比如，C语言的NULL，Java语言的null，Python语言的None，Ruby语言的nil。&lt;br /&gt;
为啥JavaScript语言居然有两个表示“无”的值：undefined和null&lt;/p&gt;
&lt;h3 id=&quot;历史原因</summary>
      
    
    
    
    <category term="前端开发" scheme="http://www.amaoc.cn/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="js" scheme="http://www.amaoc.cn/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>js中的内存管理</title>
    <link href="http://www.amaoc.cn/2023/11/28/js%E4%B8%AD%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <id>http://www.amaoc.cn/2023/11/28/js%E4%B8%AD%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</id>
    <published>2023-11-28T03:37:46.758Z</published>
    <updated>2024-03-04T10:18:01.416Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-内存的生命周期"><a class="markdownIt-Anchor" href="#1-内存的生命周期"></a> 1. 内存的生命周期</h3><blockquote><p><img src="/imgs/1.jpeg" alt="内存生命周期" /><br />不管什么语言，内存生命周期基本是一致的：</p><ol><li>分配你所需的内存</li><li>使用分配到的内存（读，写）</li><li>不需要时将其释放/归还<br />在C语言中，有专门的内存管理接口，像malloc() 和 free()。而在js中，没有专门的内存管理接口，所有的内存管理都是“自动”的。<br />js在创建变量时，自动分配内存，并在不使用的时候，自动释放。</li></ol></blockquote><h3 id="2-js中的内存回收"><a class="markdownIt-Anchor" href="#2-js中的内存回收"></a> 2. JS中的内存回收</h3><p>引用</p><blockquote><p>垃圾回收算法主要依赖于引用的概念，在内存管理的环境中，一个对象如果有访问另一个对象的权限（隐式或显式），叫做一个对象引用另一个对象。<br />例如：一个Javascript对象具有堆它原型的引用（隐式引用）和它属性的引用（显式引用）。</p></blockquote><ol><li>引用计数垃圾收集</li></ol><blockquote><p>这是最简单的垃圾回收机制算法。此算法把“对象是否不再需要”简化定义为“对象有没有其他对象引用到它”。如果没有引用指向对象（零引用，对象将被垃圾回收机制回收）<br />例：</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line">arr = <span class="literal">null</span>; <span class="comment">// [1, 2, 3, 4]这时没有被引用，会被自动回收</span></span><br></pre></td></tr></table></figure><ol start="2"><li>限制：循环引用</li></ol><blockquote><p>两个对象被创建并相互引用，就造成零循环引用。它们被调用之后不会离开函数的作用域，所以它们已经没用零，可以被回收了。然而，引用计数算法考虑它们相互都有至少一次引用，所以它们不会被回收<br />例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> o1 = &#123;&#125;;</span><br><span class="line">  <span class="keyword">var</span> o2 = &#123;&#125;;</span><br><span class="line">  o1.<span class="property">p</span> = o2; <span class="comment">// o1 引用了 o2</span></span><br><span class="line">  o2.<span class="property">p</span> = o1; <span class="comment">// o2 引用了 o1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">f</span>();</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div;</span><br><span class="line"><span class="variable language_">window</span>.<span class="property">onload</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  div = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myDivElement&quot;</span>);</span><br><span class="line">  div.<span class="property">circularReference</span> = div;</span><br><span class="line">  div.<span class="property">lotsOfData</span> = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">10000</span>).<span class="title function_">join</span>(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面的例子里，myDivElement这个Dom元素的circularRerence属性引用了myDivElement造成了循环引用。IE6，7使用引用计数方式对DOM对象进行垃圾回收。该方法常常造成对象被循环引用时内存发生泄露。现代浏览器通过使用标记-清除内存回收算法，来解决这一个问题。</p></blockquote><ol start="3"><li>标记-清楚算法</li></ol><blockquote><p>这个算法把“对象是否不再需要”简化定义为“对象是否可以获得”。</p><p>这个算法假定设置一个叫根root的对象（在JavaScript里，根是全局对象）。垃圾回收器将从根开始定期的找所有从根开始引用的对象，然后找这些对象引用的对象，从根开始，垃圾回收器将找到所有可以获得的对象和所有不能获得的对象。</p><p>从2012年起，所有现代浏览器都使用了标记-清除内存回收算法。所有对JavaScript垃圾回收算法的改进都是基于标记-清除算法。</p><p><img src="/imgs/img2.webp" alt="标记-清除算法" /></p></blockquote><ol start="4"><li>自动GC垃圾回收机制</li></ol><blockquote><p>尽管自动GC很方便，但是我们不知道GC什么时候会进行。这意味着如果我们在使用过程中使用了大量的内存，而GC没有运行的情况下，或者GC无法回收这些内存的情况下，程序就有可能假死，这个就需要我们在程序中手动做一些操作来触发内存回收了。</p></blockquote><h3 id="3-什么是内存泄露"><a class="markdownIt-Anchor" href="#3-什么是内存泄露"></a> 3. 什么是内存泄露？</h3><blockquote><p>程序的运行需要内存，程序运行中的各种操作需要消耗资源和内存，程序运行中生成的各种数据也需要内存。若不及时释放内存，则内存的占用越来越高，轻则影响程序和系统的性能，重则导致进程或系统的崩溃。<br />没有即使释放不再使用的内存，就称为内存泄漏。<br />本质的讲，内存泄露就是不再被需要的内存，由于某种原因，无法被释放。</p></blockquote><h3 id="4-哪些内容是垃圾"><a class="markdownIt-Anchor" href="#4-哪些内容是垃圾"></a> 4. 哪些内容是“垃圾”？</h3><p>JS的垃圾回收机制会定期（周期性）找出那些不再用到的内存（变量），然后释放其内存。 很简单，对于我们不再使用的内容，就会视为垃圾处理掉。而对于不再使用的值，则会被垃圾回收。（注意可访问性）</p><ul><li>有用的值：</li></ul><blockquote><p>本地函数的局部变量和参数<br />调用链上的其他函数的变量和参数<br />全局变量<br />可访问的值</p></blockquote><ul><li>无用的值：</li></ul><blockquote><p>地址或值为 null 的值<br />函数的局部作用域中的变量和参数（函数完成后）</p></blockquote><p>等等等等。</p><h3 id="5-常见的内存泄露案例"><a class="markdownIt-Anchor" href="#5-常见的内存泄露案例"></a> 5. 常见的内存泄露案例</h3><ol><li>全局变量</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span> (arg) &#123;</span><br><span class="line">  bar = <span class="string">&quot;some text&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在js中处理未被声明的变量，上述范例中的bar时，会把bar定义到全局对象中，在浏览器中就是window上。在页面中的全局变量，只有当页面被关闭后才会被销毁。所以这种写法就会造成内存泄露，当然这个例子中的泄露的只是一个简单的字符串，但是在实际的代码中，往往情况会更加糟糕。</p><p>另外一种意外创建全局变量的情况。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span> () &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">var1</span> = <span class="string">&quot;potential accidental global&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// foo 被调用时，this指向全局变量window</span></span><br><span class="line"><span class="title function_">foo</span>();</span><br></pre></td></tr></table></figure><blockquote><p>这种情况下调用foo，this被指向了全局变量window，意外的创建了全局变量。</p><p>我们谈到了一些意外情况下定义的全局变量，代码中也有一些我们明确定义的全局变量。如果使用这些全局变量用来暂存大量的数据，记得在使用后，对其重新赋值为null。</p></blockquote><ol start="2"><li>未销毁的定时器和回调函数</li></ol><blockquote><p>很多库中，如果使用了观察者模式，都会提供回调方法，来调用一些回调函数。要记得回收这些回调函数。例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> serverData = <span class="title function_">loadData</span>();</span><br><span class="line"><span class="built_in">setInterval</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> renderer = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;renderer&#x27;</span>);</span><br><span class="line">  <span class="keyword">if</span> (renderer) &#123;</span><br><span class="line">    renderer.<span class="property">innerHTML</span> = <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(serverData);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, <span class="number">5000</span>); <span class="comment">// 每5秒调用一次</span></span><br></pre></td></tr></table></figure><p>如果后续renderer元素被移除，整个定时器实际上没有任何作用。但是如果你没有回收定时器，整个定时器依然有效，不但定时器无法被内存回收，定时器函数中的依赖也无法回收(serverData也无法被回收)。</p></blockquote><ol start="3"><li>闭包</li></ol><blockquote><p>在js开发中，我们经常会用到内部函数，有权访问包含它的外部函数的变量。<br />注意下面这种情况，闭包也会造成内存泄露</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> theThing = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">var</span> replaceThing = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> originalThing = theThing;</span><br><span class="line">  <span class="keyword">var</span> unused = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (originalThing) &#123; <span class="comment">// 对于‘originalThing’的引用</span></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hi&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  theThing = &#123;</span><br><span class="line">    <span class="attr">longStr</span>: <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">1000000</span>).<span class="title function_">join</span>(<span class="string">&#x27;*&#x27;</span>),</span><br><span class="line">    <span class="attr">someMethod</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;message&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">setInterval</span>(replaceThing, <span class="number">10000</span>);</span><br></pre></td></tr></table></figure><p>每次调用replaceThing时，theThing获得了包含一个巨大的数组和一个对于新闭包someMethod的对象，同时unused是一个引用了originalThing的闭包。<br />闭包之间是共享作用域的，尽管unused可能一只都没有被调用，但是someMethod可能会被调用，就会导致内存无法对其进行回收。</p></blockquote><ol start="4"><li>DOM引用</li></ol><blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> elements = &#123;</span><br><span class="line">  <span class="attr">image</span>: <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;image&#x27;</span>)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">doStuff</span>(<span class="params"></span>) &#123;</span><br><span class="line">  elements.<span class="property">image</span>.<span class="property">src</span> = <span class="string">&#x27;http://example.com/img.png&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">removeImage</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">removeChild</span>(<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;image&#x27;</span>));</span><br><span class="line">  <span class="comment">// 这个时候，我们对于#image 仍然有一个引用，Image元素仍然无法被内存回收。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：<br />如果我们引用了一个表格中的td元素，一旦在DOM中删除了整个表格，我们直观的认为内存回收应该回收了除了有引用的td外的其他元素，但是事实上，这个td元素是整个表格的一个子元素，并保留对于其父元素的引用。这个就会导致整个表格都无法进行内存回收。所以我们要小心处理DOM元素的引用。</p></blockquote><h3 id="es6"><a class="markdownIt-Anchor" href="#es6"></a> ES6</h3><blockquote><p>ES中引入了WeakSet和WeakMap两个新概念，来解决引用造成的内存回收问题。WeakSet和WeakMap对于值的引用可以忽略不计，它们对于值的引用都是弱引用，内存回收机制不会考虑这种引用。当其他引用被消除之后，引用就会被内存中释放。</p></blockquote><h2 id="参考文档"><a class="markdownIt-Anchor" href="#参考文档"></a> 参考文档</h2><ol><li><a href="https://www.jianshu.com/p/b31c7d5e8311">JS中的内存管理</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1-内存的生命周期&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#1-内存的生命周期&quot;&gt;&lt;/a&gt; 1. 内存的生命周期&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;img src=&quot;/imgs/1.jpeg&quot; alt=&quot;内存生命周期&quot; </summary>
      
    
    
    
    <category term="前端开发" scheme="http://www.amaoc.cn/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="js" scheme="http://www.amaoc.cn/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>js中的栈内存和堆内存</title>
    <link href="http://www.amaoc.cn/2023/11/28/js%E4%B8%AD%E7%9A%84%E6%A0%88%E5%86%85%E5%AD%98%E5%92%8C%E5%A0%86%E5%86%85%E5%AD%98/"/>
    <id>http://www.amaoc.cn/2023/11/28/js%E4%B8%AD%E7%9A%84%E6%A0%88%E5%86%85%E5%AD%98%E5%92%8C%E5%A0%86%E5%86%85%E5%AD%98/</id>
    <published>2023-11-28T03:37:46.758Z</published>
    <updated>2024-03-04T10:18:07.846Z</updated>
    
    <content type="html"><![CDATA[<p>JavaScript的内存空间分为栈(stack)、堆(heap)、池(或叫栈中);</p><h3 id="栈内存和堆内存简介"><a class="markdownIt-Anchor" href="#栈内存和堆内存简介"></a> 栈内存和堆内存简介</h3><p>JavaScript中并没有严格意义上区分栈内存和堆内存。</p><ol><li>栈数据结构<br />执行上下文的执行顺序借用了栈数据结构的存取方式；<br />栈空间的特点：先进后出，后进先出；<br /><img src="/imgs/1.webp" alt="栈数据结构" /><br />由于栈具有后入先出的特点，所以任何不在栈顶的元素都无法访问。<br />为了得到栈底的元素，必须先拿掉上面的元素；<br />类似乒乓球盒子来分析栈的存取方式。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">栈会自动分配内存空间，物理内存是连续的，可以存放基本类型（Boolean,Number,String,undefined,null,Symbol），简单的数据段，引用类型的物理地址；</span><br><span class="line">占用空间小（大小固定），通过按值来访问，属于被频繁使用的数据。  </span><br><span class="line"></span><br><span class="line">PS：闭包中的基本数据类型变量不会保存在栈内存中，而是保存在堆内存中。</span><br></pre></td></tr></table></figure><ol start="2"><li>堆数据结构<br />堆是一种经过排序的树形数据结构，每个结点都有一个值。<br />通常我们所属的堆的数据结构，是指二叉堆。<br />堆的特点是根结点的值最小（或最大），且根结点的两个子树也是一个堆。<br />这种树状结构，它的存储数据的方式是随意的，与书架与书非常相似。我们不关心书的放置顺序是怎样的，只需要知道书的名字就可以取出我们想要的书了。<br />虽然书的摆放是有顺序的，但我们想取任意一本时不必像栈一样，先取出前面的所有书。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">引用数据类型（Array,Object, Function）存储在堆内存中，因为引用数据类型占据空间大（大小不固定），如果存储在栈中，将会影响程序运行的性能。</span><br><span class="line">引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。</span><br><span class="line">当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。</span><br><span class="line"></span><br><span class="line">堆内存是动态分配的内存，物理地址不连续，大小不定也不会自动释放内存；</span><br></pre></td></tr></table></figure><ol start="3"><li>队列<br />在Javascript中，理解队列数据结构的目的主要是为了清晰的明白事件循环（Event Loop）的机制<br />队列的特点：先进先出，后进后出。<br /><img src="/imgs/2.webp" alt="队列数据结构" /></li></ol><h3 id="栈内存和堆内存的区别"><a class="markdownIt-Anchor" href="#栈内存和堆内存的区别"></a> 栈内存和堆内存的区别</h3><ol><li><p>栈内存：所有在方法中定义的变量都是放在栈内存中，随着方法的执行结束，这个方法的内存栈也自然销毁。<br />优点：存取速度比堆快，仅次于直接位于CPU中的寄存器，数据可共享；<br />缺点：存在栈中的数据大小与生存期必须是确定的，缺乏灵活性。</p></li><li><p>堆内存：堆内存中的对象不会随方法的结束而销毁，即使方法结束后，这个对象海可能被另一个引用变量所引用（参数传递）</p></li></ol><h3 id="赋值与赋址"><a class="markdownIt-Anchor" href="#赋值与赋址"></a> 赋值与赋址</h3><p>引擎不能直接操作堆内存中的数据，这就造成了对同一个变量赋不同类型的值，会出现完全不同的效果：<br />为一个变量赋基本值时，实际上是创建一个新值，然后把该值赋给新变量，可以说这是一种真正意义上的“赋值”；<br />为一个变量赋引用值时，实际上是为新变量添加一个指针，指向堆内存中的一个对象，属于一直“赋址”操作。<br /><img src="/imgs/7.png" alt="图片" /></p><h3 id="内存分配和垃圾回收"><a class="markdownIt-Anchor" href="#内存分配和垃圾回收"></a> 内存分配和垃圾回收</h3><p>一般来说栈内存线性有序存储，容量小，系统分配效率高。而堆内存首先要在堆内存新分配存储区域，之后又要把指针存储到栈内存中，效率相对就要比较低一些。<br />垃圾回收方面，栈内存变量基本上用完了就回收了，而堆内存中的变量因为存在很多不确定的引用，只有当所有调用的变量全部销毁之后才能回收。</p><h3 id="脑洞"><a class="markdownIt-Anchor" href="#脑洞"></a> 脑洞</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. const 定义的基本类型不能改变，但是定义的对象是可以通过修改对象属性等方法来改变的。</span><br><span class="line">因为我们定义一个const对象的时候，，我们说的常量其实是一个指针，就是说const对象对应的堆内存指向是不变的，但是堆内存中的数据本身的大小或者属性是可变的。</span><br></pre></td></tr></table></figure><h2 id="参考文案"><a class="markdownIt-Anchor" href="#参考文案"></a> 参考文案</h2><ol><li><a href="https://www.cnblogs.com/heioray/p/9487093.html">浅析js中的栈内存和堆内存</a></li><li><a href="https://blog.csdn.net/a59612/article/details/93661354">中高级前端必须了解的–JS中的栈内存和堆内存</a></li><li><a href="https://www.jianshu.com/p/0b18e120955b">JavaScript栈内存与堆内存</a></li><li><a href="https://www.jb51.net/article/159120.htm">详解JavaScript栈内存与堆内存</a></li><li><a href="https://blog.csdn.net/qq_36747861/article/details/84958366">js中的栈内存和堆内存</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;JavaScript的内存空间分为栈(stack)、堆(heap)、池(或叫栈中);&lt;/p&gt;
&lt;h3 id=&quot;栈内存和堆内存简介&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#栈内存和堆内存简介&quot;&gt;&lt;/a&gt; 栈内存和堆内存简介&lt;/h3&gt;
&lt;p&gt;J</summary>
      
    
    
    
    <category term="前端开发" scheme="http://www.amaoc.cn/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="js" scheme="http://www.amaoc.cn/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>js的原型和原型链</title>
    <link href="http://www.amaoc.cn/2023/11/28/js%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
    <id>http://www.amaoc.cn/2023/11/28/js%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/</id>
    <published>2023-11-28T03:37:46.758Z</published>
    <updated>2023-11-28T03:37:46.758Z</updated>
    
    <content type="html"><![CDATA[<h2 id="js的原型和原型链"><a class="markdownIt-Anchor" href="#js的原型和原型链"></a> js的原型和原型链</h2><h3 id="普通函数和函数对象"><a class="markdownIt-Anchor" href="#普通函数和函数对象"></a> 普通函数和函数对象</h3><blockquote><p>JavaScript中，万物皆对象！但是对象也是有区别的。分为普通函数和函数对象，Object、Function是JS中自带的函数对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o1 = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> o2 = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="keyword">var</span> o3 = <span class="keyword">new</span> <span class="title function_">f1</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f1</span>(<span class="params"></span>) &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> f2 = <span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> f3 = <span class="keyword">new</span> <span class="title class_">Function</span>(<span class="string">&#x27;str&#x27;</span>, <span class="string">&#x27;console.log(str)&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="title class_">Object</span>); <span class="comment">// function</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="title class_">Function</span>); <span class="comment">// function</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> f1); <span class="comment">// function</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> f2); <span class="comment">// function</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> f3); <span class="comment">// function</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> o1); <span class="comment">// object</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> o2); <span class="comment">// object</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> o3); <span class="comment">// object</span></span><br></pre></td></tr></table></figure><p>在上面的例子中，o1、o2、o3为普通的对象，f1、f2、f3为函数对象。<br />怎么区分？其实很简单：<br />凡是通过new Function() 创建的对象都是函数对象，其他的都是普通对象。f1、f2归根结底都是通过new Function() 的方式进行创建的。Function Object也都是通过new Function() 创建的。</p></blockquote><h3 id="构造函数"><a class="markdownIt-Anchor" href="#构造函数"></a> 构造函数</h3><blockquote><p>我们先复习一下构造函数的知识：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, age, job</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">job</span> = job;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;zhangsan&#x27;</span>, <span class="number">28</span>, <span class="string">&#x27;Software Engineer&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;lisi&#x27;</span>, <span class="number">23</span>, <span class="string">&#x27;Doctor&#x27;</span>);</span><br></pre></td></tr></table></figure><p>上面的例子中的person1和person2都是Person的实例。这两个实例都有一个constructor（构造函数）的属性，该属性(是一个指针)指向Person。即：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person1.<span class="property">constructor</span> === <span class="title class_">Person</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person2.<span class="property">constructor</span> === <span class="title class_">Person</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>我们要记住两个概念（构造函数，实例）：<br />person1和person2都是构造函数Person的实例。<br />一个公式：<br />实例的构造函数属性（constructor）指向构造函数。</p></blockquote><h3 id="原型对象"><a class="markdownIt-Anchor" href="#原型对象"></a> 原型对象</h3><blockquote><p>在JavaScript中，每当定义一个对象（函数也是对象）的时候，对象中都会包含一些预定义的属性。其中每个函数对象都有一个prototype属性，这个属性指向函数的原型对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123;&#125;;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">name</span> = <span class="string">&#x27;zhangsan&#x27;</span>;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">age</span> = <span class="number">28</span>;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">job</span> = <span class="string">&#x27;Softwar Engineer&#x27;</span>;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">person1.<span class="title function_">sayName</span>(); <span class="comment">// &#x27;zhangsan&#x27;;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">person2.<span class="title function_">sayName</span>(); <span class="comment">// &#x27;zhangsan&#x27;;</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person1.<span class="property">sayName</span> === person2.<span class="property">sayName</span>); <span class="comment">// true; </span></span><br></pre></td></tr></table></figure><p>我们得到了文本第一【定律】：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">每个对象都有__proto__属性，但只有函数对象才有prototype属性。</span><br></pre></td></tr></table></figure><p>那什么是原型对象呢？<br />我们把上面的例子改一改就会明白了：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;zhangsan&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">28</span>,</span><br><span class="line">  <span class="attr">job</span>: <span class="string">&#x27;Software&#x27;</span>,</span><br><span class="line">  <span class="attr">sayName</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原型对象，顾名思义，它就是一个普通对象。<br />在上面我们给A添加了四个属性：name，age，job，sayName。其实它还有一个默认属性：constructor。</p><blockquote><p>在默认情况下，所有的原型对象都会自动获得一个constructor（构造函数）的属性，这个属性（是一个指针）指向prototype属性所在的函数（Person）。<br />即 Person.prototype.constructor === Person;</p></blockquote></blockquote><h3 id="参考文档"><a class="markdownIt-Anchor" href="#参考文档"></a> 参考文档</h3><blockquote><ol><li><a href="https://www.jianshu.com/p/dee9f8b14771">最详尽的 JS 原型与原型链终极详解，没有「可能是」。（一）</a></li><li><a href="https://www.jianshu.com/p/652991a67186">最详尽的 JS 原型与原型链终极详解，没有「可能是」。（二）</a></li><li><a href="https://www.jianshu.com/p/a4e1e7b6f4f8">最详尽的 JS 原型与原型链终极详解，没有「可能是」。（三）</a></li></ol></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;js的原型和原型链&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#js的原型和原型链&quot;&gt;&lt;/a&gt; js的原型和原型链&lt;/h2&gt;
&lt;h3 id=&quot;普通函数和函数对象&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;</summary>
      
    
    
    
    <category term="前端开发" scheme="http://www.amaoc.cn/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="js" scheme="http://www.amaoc.cn/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>stylelint 初次使用（vue）</title>
    <link href="http://www.amaoc.cn/2023/11/28/stylelint%E5%88%9D%E6%AC%A1%E4%BD%BF%E7%94%A8/"/>
    <id>http://www.amaoc.cn/2023/11/28/stylelint%E5%88%9D%E6%AC%A1%E4%BD%BF%E7%94%A8/</id>
    <published>2023-11-28T03:37:46.758Z</published>
    <updated>2023-11-28T03:37:46.759Z</updated>
    
    <content type="html"><![CDATA[<h3 id="stylelint-初次使用vue"><a class="markdownIt-Anchor" href="#stylelint-初次使用vue"></a> stylelint 初次使用（vue）</h3><blockquote><p>很早就知道样式校验了，但是一直都没有去了解，因公司对样式比较关怀，所以特意去研究了一下，效果倍爽。。。</p></blockquote><h3 id="安装"><a class="markdownIt-Anchor" href="#安装"></a> 安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">yarn add stylelint stylelint-config-standard stylelint-config-rational-order stylelint-order stylelint-scss stylelint-webpack-plugin --save-dev</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">npm install stylelint stylelint-config-standard stylelint-config-rational-order stylelint-order stylelint-scss stylelint-webpack-plugin --save-dev</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>stylelint是运行工具<br />stylelint-config-standard(stylelint-config-recommentded)是stylelint的推荐配置<br />stylelint-order是css属性排序插件，并且每个规则都支持自动修复（stylelint --fix）<br />stylelint-scss引入了特定的scss规则，是stylelint更好的支持scss语法<br />stylelint-config-rational-order是stylelint配置，通过按照以下顺序将相关属性声明进行分组来对它们进行排序：</p><ol><li>Positioning；</li><li>Box Model；</li><li>Typography；</li><li>Visual；</li><li>Animation；</li><li>Misc；</li></ol><p>stylelint-webpack-plugin是webpack插件，使用stylelint检查css/scss代码。<br />注意：用vue-cli2构建的项目(webpack3.0)，stylelint-wepack-plugin的版本记得选用0.10.5的版本。</p></blockquote><h3 id="配置规则"><a class="markdownIt-Anchor" href="#配置规则"></a> 配置规则</h3><blockquote><p>stylelint配置顺序：</p><blockquote><ol><li>会去找package.json里的stylelint配置</li><li>没有找到package.json的配置，会找.stylelintrc（或者.stylelintrc.json, .stylelintrc.yaml, .stylelintrc.yml, .stylelintrc.js）中的配置</li><li>找stylelint.config.js中的配置</li></ol></blockquote><p>我们一般选用第二个，创建一个.stylelintrc.json文件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;extends&quot;</span>: [<span class="string">&quot;stylelint-config-standard&quot;</span>, <span class="string">&quot;stylelint-config-rational-order&quot;</span>],</span><br><span class="line">  <span class="string">&quot;plugins&quot;</span>: [<span class="string">&quot;stylelint-scss&quot;</span>, <span class="string">&quot;stylelint-order&quot;</span>],</span><br><span class="line">  <span class="string">&quot;rules&quot;</span>: &#123;</span><br><span class="line">    <span class="comment">// 因为开发原因，不可能每个css都给排序，太影响开发效率，所以排序禁用</span></span><br><span class="line">    <span class="string">&quot;no-descending-specificity&quot;</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="comment">// 因为项目中用到里px2rem，不需要转rem的单位我们都用大写的PX来做单位（注释会被scss-loader及stylelint去掉），所以忽略单位大小写</span></span><br><span class="line">    <span class="string">&quot;unit-case&quot;</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="comment">// 嵌套层写5层，太少会影响之前项目代码</span></span><br><span class="line">    <span class="string">&quot;max-nesting-depth&quot;</span>: <span class="number">5</span>,</span><br><span class="line">    <span class="string">&quot;order/order&quot;</span>: [</span><br><span class="line">      <span class="string">&quot;custom-properties&quot;</span>,</span><br><span class="line">      <span class="string">&quot;dollar-variables&quot;</span>,</span><br><span class="line">      <span class="string">&quot;declarations&quot;</span>,</span><br><span class="line">      <span class="string">&quot;rules&quot;</span>,</span><br><span class="line">      <span class="string">&quot;at-rules&quot;</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建忽略stylelint代码文件，.stylelintignore忽略指定目录或文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/dist/</span><br><span class="line">/test/</span><br><span class="line"></span><br><span class="line">*.min.css</span><br><span class="line"></span><br><span class="line">*.js</span><br><span class="line">*.ts</span><br><span class="line">*.png</span><br><span class="line">*.jpg</span><br><span class="line">*.webp</span><br><span class="line">*.ttf</span><br><span class="line">*.woff</span><br></pre></td></tr></table></figure></blockquote><h3 id="配置"><a class="markdownIt-Anchor" href="#配置"></a> 配置</h3><blockquote><ol><li>使用webpack插件校验.vue文件中的style，在vue.config.js中添加</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">configureWebpack</span>: <span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="title class_">StyleLintPlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;stylelint-webpack-plugin&#x27;</span>)</span><br><span class="line">  config.<span class="property">plugins</span>.<span class="title function_">push</span>(</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">StyleLintPlugin</span>(&#123;</span><br><span class="line">      <span class="attr">files</span>: [<span class="string">&#x27;src/**/*.&#123;vue,html,css,scss,sass,less&#125;&#x27;</span>],</span><br><span class="line">      <span class="attr">failOnError</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">cache</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">fix</span>: <span class="literal">true</span>,</span><br><span class="line">    &#125;)</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>用vue-cli2构建的项目中，在/build/webpack.prod.conf.js中添加</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">StyleLintPlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;stylelint-webpack-plugin&#x27;</span>)</span><br><span class="line"><span class="comment">// 在plugins中</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">StyleLintPlugin</span>(&#123;</span><br><span class="line">      <span class="string">&#x27;files&#x27;</span>: [<span class="string">&#x27;src/**/*.&#123;vue,css,sass,scss&#125;&#x27;</span>],</span><br><span class="line">      <span class="string">&#x27;fix&#x27;</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="string">&#x27;cache&#x27;</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="string">&#x27;emitErrors&#x27;</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="string">&#x27;failOnError&#x27;</span>: <span class="literal">false</span></span><br><span class="line">    &#125;),</span><br></pre></td></tr></table></figure><ol start="3"><li>stylelint与eslint同时使用git-hooks配置<br />在package.json中配置</li></ol><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">   <span class="comment">// ...</span></span><br><span class="line">   <span class="attr">&quot;lint-staged&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">       <span class="attr">&quot;*.&#123;vue,js&#125;&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">           <span class="string">&quot;eslint --fix&quot;</span><span class="punctuation">,</span></span><br><span class="line">           <span class="string">&quot;git add&quot;</span></span><br><span class="line">       <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">       <span class="attr">&quot;*.&#123;html,vue,css,sass,scss&#125;&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">           <span class="string">&quot;stylelint --fix&quot;</span><span class="punctuation">,</span></span><br><span class="line">           <span class="string">&quot;git add&quot;</span><span class="punctuation">,</span></span><br><span class="line">       <span class="punctuation">]</span></span><br><span class="line">   <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">   <span class="attr">&quot;husky&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">       <span class="attr">&quot;hooks&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">           <span class="attr">&quot;pre-commit&quot;</span><span class="punctuation">:</span> <span class="string">&quot;lint-staged&quot;</span><span class="punctuation">,</span></span><br><span class="line">       <span class="punctuation">&#125;</span></span><br><span class="line">   <span class="punctuation">&#125;</span></span><br><span class="line"> <span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></blockquote><h3 id="rules规则"><a class="markdownIt-Anchor" href="#rules规则"></a> rules规则</h3><blockquote><p>Color<br />color-hex-case: 指定大写或小写十六进制的颜色。<br />color-hex-length: 指定十六进制颜色长或短的符号。<br />color-named: 需要（如果可能）或不允许命名的颜色。<br />color-no-hex: 不允许十六进制的颜色。<br />color-no-invalid-hex: 禁止无效的十六进制颜色。</p><p>font-family<br />font-family-name-quotes:指定是否引号应该围绕字体系列名称中使用。</p><p>function<br />function-blacklist:指定不允许的功能黑名单<br />function-calc-no-unspaced-operator:计算的函数中禁止的unspaced执行<br />function-comma-newline-after:要求一个新行或函数的逗号后禁止空白。<br />function-comma-newline-before: 要求一个新行或函数的逗号之前不允许空白。<br />function-comma-space-after: 要求一个空格或函数的逗号后禁止空白。<br />function-comma-space-before:要求一个空格或函数的逗号前禁止空白。<br />function-linear-gradient-no-nonstandard-direction:禁止在线性梯度方向值（），根据标准语法是无效的呼叫。<br />function-max-empty-lines: 限制方法中相邻的空行数<br />function-name-case: 指定大写或小写的函数名。<br />function-parentheses-newline-inside:要求一个新行或函数的括号内不允许空白。<br />function-parentheses-space-inside: 要求一个空格或函数的括号内不允许空白。<br />function-url-data-uris: 要求或禁止数据的URI的URL<br />function-url-no-scheme-relative:不允许文档相对的URL。<br />function-url-quotes: 要求或禁止对于网址报价<br />function-url-scheme-whitelist: 指定允许URL方案的白名单。<br />function-whitelist: 指定允许的功能的白名单。<br />function-whitespace-after: 要求方法后不允许空白。</p><p>Number<br />number-leading-zero:要求或分数低于1的数字禁止前导零。<br />number-max-precision:限制允许的小数位数的数目。<br />number-no-trailing-zeros: 禁止在数量尾随零。<br />String<br />string-no-newline: 禁止在字符串（转义）换行。<br />string-quotes: 指定字串，单或双引号。<br />Length<br />length-zero-no-unit: 禁止单位零长度。<br />Time<br />time-no-imperceptible: 禁止动画和过渡小于或等于100毫秒。<br />Unit<br />unit-blacklist: 指定不允许使用单位的黑名单。<br />unit-case: 指定大写或小写的单位。<br />unit-no-unknown: 禁止未知的单位。<br />unit-whitelist: 指定允许单位的白名单&gt;<br />Value<br />value-keyword-case: 指定大写或小写关键字的值。<br />value-no-vendor-prefix: 不允许供应商前缀值。<br />Value list<br />value-list-comma-newline-after: 逗号后需要一个换行符或不允许空白值列表。<br />value-list-comma-newline-before: 逗号前需要一个换行符或不允许空白值列表。<br />value-list-comma-space-after: 需要一个空格或者逗号后不允许空白值列表。<br />value-list-comma-space-before:需要一个空格或者逗号前不允许空白值列表。<br />value-list-max-empty-lines: 限制相邻的数量值列表内空行。<br />Custom property<br />custom-property-empty-line-before: 自定义属性之前equire或不允许空行。<br />custom-property-no-outside-root: 不允许自定义属性以外的:根规则。<br />custom-property-pattern: 为自定义属性指定一个模式。<br />Shorthand property<br />shorthand-property-no-redundant-values:不允许在简写属性冗余值。<br />Property<br />property-blacklist: 指定一个不允许属性的黑名单。<br />property-case: 为属性指定小写或大写。<br />property-no-unknown: 不允许未知属性。<br />property-no-vendor-prefix: 不允许前缀的属性。<br />property-whitelist: 指定一个白名单允许属性。<br />Keyframe declaration<br />keyframe-declaration-no-important: 不允许!important在关键帧声明。<br />Declaration<br />declaration-bang-space-after: bang声明之后需要一个空格或者不允许空白<br />declaration-bang-space-before: bang声明之前需要一个空格或者不允许空白<br />declaration-colon-newline-after: 冒号后的声明需要一个换行符或不允许空白。<br />declaration-colon-space-after: 冒号后的声明需要一个空格或不允许空白。<br />declaration-colon-space-before: 冒号之前的声明需要一个空格或不允许空白。<br />declaration-empty-line-before: 要求声明前不允许空一行。<br />declaration-no-important: 不允许!important声明。<br />declaration-property-unit-blacklist: 指定一个黑名单内不允许声明属性。<br />declaration-property-unit-whitelist: 指定一个白名单内允许声明属性。<br />declaration-property-value-blacklist: 指定一个黑名单,不允许在声明属性和值对。<br />declaration-property-value-whitelist: 指定一个允许属性和值对声明的白名单。<br />Declaration block<br />declaration-block-no-duplicate-properties: 不允许复制属性块中声明<br />declaration-block-no-ignored-properties:不允许被忽略是因为另一个属性值的属性值相同的规则。<br />declaration-block-no-redundant-longhand-properties: 不允许手写属性,可以组合成一个简写属性。<br />declaration-block-no-shorthand-property-overrides: 不允许简写属性覆盖相关手写属性声明块。<br />declaration-block-properties-order: 声明块中指定的顺序属性。<br />declaration-block-semicolon-newline-after: 要求一个换行符或不允许空白块分号后。<br />declaration-block-semicolon-newline-before: 要求一个换行符或不允许空白块分号之前的声明。<br />declaration-block-semicolon-space-after: 要求一个空间或不允许空白块分号后的声明。<br />declaration-block-semicolon-space-before: 要求一个空间或不允许空白块分号之前的声明<br />declaration-block-single-line-max-declarations: 限制声明在一行声明块的数量<br />declaration-block-trailing-semicolon: 要求或不允许在声明块后面的分号。<br />Block<br />block-closing-brace-empty-line-before: 要求或不允许关闭括号前空一行。<br />block-closing-brace-newline-after: 需要一个换行符或不允许关闭括号后的空白。<br />block-closing-brace-newline-before: 需要一个换行符或不允许空白关闭括号前的块。<br />block-closing-brace-space-after: 需要一个空间或不允许关闭括号后的空白块。<br />block-closing-brace-space-before: 在关闭括号前的块需要一个空格或者不允许空白。<br />block-no-empty: 不允许空块<br />block-no-single-line: 不允许单行块<br />block-opening-brace-newline-after: 开括号的块之后需要新的一行。<br />block-opening-brace-newline-before: 开括号的块之后需要一个换行符或不允许空白<br />block-opening-brace-space-after: 开括号的块之后需要一个空格或不允许空白。<br />block-opening-brace-space-before: 开括号的块之前需要一个空格或不允许空白。<br />Selector<br />selector-attribute-brackets-space-inside: 在括号里的属性选择器需要一个空格或者不允许空白。<br />selector-attribute-operator-blacklist: 指定一个黑名单不允许属性的操作符。<br />selector-attribute-operator-space-after: 需要一个空间或不允许空格后运营商在属性选择器。<br />selector-attribute-operator-space-before: 需要一个空间或不允许空格内运营商之前属性选择器。<br />selector-attribute-operator-whitelist: 指定一个属性允许运营商的白名单。<br />selector-attribute-quotes: 需要或不允许引用属性值。<br />selector-class-pattern: 指定一个模式类选择符。<br />selector-combinator-space-after: 需要一个空间或不允许空格后的组合子选择器。<br />selector-combinator-space-before: 需要一个空间或不允许空格前的组合子选择器。<br />selector-descendant-combinator-no-non-space: 不允许的字符的后代组合子选择器进行技术改造。<br />selector-id-pattern: 指定一个模式,id选择器。<br />selector-max-compound-selectors: 在一个选择器里面限制复合选择器的数量。<br />selector-max-specificity: 限制的特异性选择器。<br />selector-nested-pattern: 指定一个模式选择器的规则嵌套规则。<br />selector-no-attribute: 不允许属性选择器。<br />selector-no-combinator: 不允许在选择器组合。<br />selector-no-id: 不允许id选择器。<br />selector-no-qualifying-type: 不允许符合条件的选择器的类型。<br />selector-no-type: 不允许类型选择器。<br />selector-no-universal: Disallow the universal selector.<br />selector-no-vendor-prefix: 不允许选择器的前缀。<br />selector-pseudo-class-blacklist: 指定一个黑名单禁止伪类选择器。<br />selector-pseudo-class-case: 为伪类选择器指定小写或大写。<br />selector-pseudo-class-no-unknown: 不允许未知的伪类选择器。<br />selector-pseudo-class-parentheses-space-inside: 需要一个空格或不允许空格在括号里面的伪类选择器。<br />selector-pseudo-class-whitelist: 伪类选择器允许指定一个白名单。<br />selector-pseudo-element-case: 为伪元素选择器指定小写或大写。<br />selector-pseudo-element-colon-notation: 为适用的伪元素指定单引号或双冒号符号。<br />selector-pseudo-element-no-unknown: 不允许未知的伪元素选择器。<br />selector-root-no-composition: 在选择器不允许根的构成。<br />selector-type-case: 指定小写或大写类型选择器。<br />selector-type-no-unknown: 不允许未知类型选择器。<br />selector-max-empty-lines: 限制内相邻的空行选择器的数量。<br />Selector list<br />selector-list-comma-newline-after: 需要一个换行符或不允许空白选择逗号后的列表。<br />selector-list-comma-newline-before: 逗号前需要一个换行符或不允许空白选择器列表。<br />selector-list-comma-space-after: 需要一个空格或者逗号后不允许空格选择器列表。<br />selector-list-comma-space-before: 需要一个空格或者逗号前不允许空格选择器列表。<br />Root rule<br />root-no-standard-properties: 根规则内不允许标准属性。<br />Rule<br />rule-nested-empty-line-before: 需要或不允许嵌套规则前空一行。<br />rule-non-nested-empty-line-before: 需要或不允许non-nested规则前空一行。<br />Media feature<br />media-feature-colon-space-after: 需要一个空间或不允许空格在冒号之后媒体的特性。<br />media-feature-colon-space-before: 需要一个空间或不允许空格在冒号之前媒体的特性。<br />media-feature-name-case: 为媒体特性名称指定小写或大写。<br />media-feature-name-no-unknown: 不允许未知的媒体功能的名字。<br />media-feature-name-no-vendor-prefix: 不允许媒体特性名称的前缀。<br />media-feature-no-missing-punctuation: 不允许标点non-boolean媒体功能<br />media-feature-parentheses-space-inside: 需要一个空间或不允许空格在括号里面的媒体功能。<br />media-feature-range-operator-space-after: 需要一个空间或不允许空白范围运算符后媒体的特性。<br />media-feature-range-operator-space-before: 之前需要一个空间或不允许空格符范围在媒体功能。<br />Custom media<br />custom-media-pattern: 为定制媒体查询名称指定一个模式。<br />Media query list<br />media-query-list-comma-newline-after: 需要一个换行符或不允许空格后媒体查询的逗号分隔列表。<br />media-query-list-comma-newline-before: 需要一个换行符或不允许空格之前媒体查询的逗号分隔列表<br />media-query-list-comma-space-after: 需要一个空间或不允许空格后媒体查询的逗号分隔列表。<br />media-query-list-comma-space-before:需要一个空间或不允许空格之前媒体查询的逗号分隔列表。<br />At-rule<br />at-rule-blacklist: 不允许at-rules指定一个黑名单。<br />at-rule-empty-line-before: 需要或不允许at-rules前空一行。<br />at-rule-name-case: 指定at-rules小写或大写的名字。<br />at-rule-name-newline-after: at-rule名称后需要一个换行符。<br />at-rule-name-space-after: 需要一个空格后at-rule名称。<br />at-rule-no-unknown: 不允许at-rules不明。<br />at-rule-no-vendor-prefix: 不允许at-rules前缀。<br />at-rule-semicolon-newline-after: 需要一个换行符之后at-rules的分号。<br />at-rule-whitelist: 指定允许at-rules的白名单。<br />stylelint-disable comment<br />stylelint-disable-reason: 需要一个理由stylelint-disable之前或之后的评论发表评论。<br />Comment<br />comment-empty-line-before: 需要或不允许评论之前一个空行。<br />comment-no-empty: 不允许空的评论。<br />comment-whitespace-inside:需要或不允许空格里面的注释标记。<br />comment-word-blacklist: 指定一个黑名单内不允许的话评论。<br />General / Sheet<br />indentation: 指定缩进。<br />max-empty-lines: 限制数量的相邻的空行。<br />max-line-length: 限制线的长度。<br />max-nesting-depth: 限制的深度嵌套。<br />no-browser-hacks: 不允许浏览器黑客,无关你目标的浏览器。<br />no-descending-specificity: 不允许选择器之后覆盖选择器的低特异性更高的特异性。<br />no-duplicate-selectors: 不允许重复的选择器。<br />no-empty-source: 不允许空的来源。<br />no-eol-whitespace: 不允许行尾空白。<br />no-extra-semicolons: 不允许额外的分号。<br />no-indistinguishable-colors: 不允许产品极其接近的颜色相同。<br />no-invalid-double-slash-comments: 不允许双斜杠注释(/ /…)不支持CSS。<br />no-missing-end-of-source-newline: 不允许丢失end-of-source换行。<br />no-unknown-animations: 不允许动画名称不对应@keyframes声明。<br />no-unsupported-browser-features: 不允许功能的浏览器不支持的目标</p></blockquote><h3 id="参考文档"><a class="markdownIt-Anchor" href="#参考文档"></a> 参考文档</h3><blockquote><ol><li><a href="https://blog.csdn.net/lfcss/article/details/82787113">stylelint rules</a></li><li><a href="https://blog.csdn.net/qq_42606051/article/details/85987840">如何为你的 Vue 项目添加配置 Stylelint</a></li><li><a href="https://www.cnblogs.com/huliang56/p/11933938.html">使用stylelint进行Vue项目样式检查</a></li><li><a href="https://stylelint.io/">stylelint官网</a></li></ol></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;stylelint-初次使用vue&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#stylelint-初次使用vue&quot;&gt;&lt;/a&gt; stylelint 初次使用（vue）&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;很早就知道样式校验了，但</summary>
      
    
    
    
    <category term="前端开发" scheme="http://www.amaoc.cn/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="css" scheme="http://www.amaoc.cn/tags/css/"/>
    
    <category term="stylelint" scheme="http://www.amaoc.cn/tags/stylelint/"/>
    
  </entry>
  
</feed>
