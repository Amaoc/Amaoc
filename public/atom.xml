<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Amaoc</title>
  
  <subtitle>blog</subtitle>
  <link href="http://www.amaoc.cn/atom.xml" rel="self"/>
  
  <link href="http://www.amaoc.cn/"/>
  <updated>2024-03-04T10:17:03.829Z</updated>
  <id>http://www.amaoc.cn/</id>
  
  <author>
    <name>Amaoc</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>事件循环(Event Loop)</title>
    <link href="http://www.amaoc.cn/2023/11/28/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/"/>
    <id>http://www.amaoc.cn/2023/11/28/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/</id>
    <published>2023-11-28T03:44:24.508Z</published>
    <updated>2024-03-04T10:17:03.829Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一-为什么javascript是单线程"><a class="markdownIt-Anchor" href="#一-为什么javascript是单线程"></a> 一、为什么JavaScript是单线程？</h3><p>JavaScript语言的一大特点就是单线程，也就是说，同一个时间只能做一件事。那么，为什么JavaScript不能有多个线程呢？这样能提高效率啊。</p><p>JavaScript的单线程，与它的用途有关。作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。比如，假定JavaScript同时有两个线程，一个线程在某个DOM节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？</p><p>所以，为了避免复杂性，从一诞生，JavaScript就是单线程，这已经成了这门语言的核心特征，将来也不会改变。</p><p>为了利用多核CPU的计算能力，HTML5提出Web Worker标准，允许JavaScript脚本创建多个线程，但是子线程完全受主线程控制，且不得操作DOM。所以，这个新标准并没有改变JavaScript单线程的本质。</p><h3 id="二-任务队列"><a class="markdownIt-Anchor" href="#二-任务队列"></a> 二、任务队列</h3><p>单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。如果前一个任务耗时很长，后一个任务就不得不一直等着。</p><p>如果排队是因为计算量大，CPU忙不过来，倒也算了，但是很多时候CPU是闲着的，因为IO设备（输入输出设备）很慢（比如Ajax操作从网络读取数据），不得不等着结果出来，再往下执行。</p><p>JavaScript语言的设计者意识到，这时主线程完全可以不管IO设备，挂起处于等待中的任务，先运行排在后面的任务。等到IO设备返回了结果，再回过头，把挂起的任务继续执行下去。</p><p>于是，所有任务可以分成两种，一种是同步任务（synchronous），另一种是异步任务（asynchronous）。同步任务指的是，在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；异步任务指的是，不进入主线程、而进入&quot;任务队列&quot;（task queue）的任务，只有&quot;任务队列&quot;通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。</p><p>具体来说，异步执行的运行机制如下。（同步执行也是如此，因为它可以被视为没有异步任务的异步执行。）</p><blockquote><p>（1）所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。<br />（2）主线程之外，还存在一个&quot;任务队列&quot;（task queue）。只要异步任务有了运行结果，就在&quot;任务队列&quot;之中放置一个事件。<br />（3）一旦&quot;执行栈&quot;中的所有同步任务执行完毕，系统就会读取&quot;任务队列&quot;，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。<br />（4）主线程不断重复上面的第三步。</p></blockquote><p>下图就是主线程和任务队列的示意图。<br /><img src="/imgs/queue.jpg" alt="任务队列" /><br />只要主线程空了，就会去读取&quot;任务队列&quot;，这就是JavaScript的运行机制。这个过程会不断重复。</p><h3 id="三-事件和回调函数"><a class="markdownIt-Anchor" href="#三-事件和回调函数"></a> 三、事件和回调函数</h3><p>“任务队列&quot;是一个事件的队列（也可以理解成消息的队列），IO设备完成一项任务，就在&quot;任务队列&quot;中添加一个事件，表示相关的异步任务可以进入&quot;执行栈&quot;了。主线程读取&quot;任务队列”，就是读取里面有哪些事件。</p><p>“任务队列&quot;中的事件，除了IO设备的事件以外，还包括一些用户产生的事件（比如鼠标点击、页面滚动等等）。只要指定过回调函数，这些事件发生时就会进入&quot;任务队列”，等待主线程读取。</p><p>所谓&quot;回调函数&quot;（callback），就是那些会被主线程挂起来的代码。异步任务必须指定回调函数，当主线程开始执行异步任务，就是执行对应的回调函数。</p><p>&quot;任务队列&quot;是一个先进先出的数据结构，排在前面的事件，优先被主线程读取。主线程的读取过程基本上是自动的，只要执行栈一清空，&quot;任务队列&quot;上第一位的事件就自动进入主线程。但是，由于存在后文提到的&quot;定时器&quot;功能，主线程首先要检查一下执行时间，某些事件只有到了规定的时间，才能返回主线程。</p><h3 id="四-event-loop"><a class="markdownIt-Anchor" href="#四-event-loop"></a> 四、Event Loop</h3><p>主线程从&quot;任务队列&quot;中读取事件，这个过程是循环不断的，所以整个的这种运行机制又称为Event Loop（事件循环）。</p><p>为了更好地理解Event Loop，请看下图<br /><img src="/imgs/event-loop.png" alt="Event Loop" /><br />上图中，主线程运行的时候，产生堆（heap）和栈（stack），栈中的代码调用各种外部API，它们在&quot;任务队列&quot;中加入各种事件（click，load，done）。只要栈中的代码执行完毕，主线程就会去读取&quot;任务队列&quot;，依次执行那些事件所对应的回调函数。</p><p>执行栈中的代码（同步任务），总是在读取&quot;任务队列&quot;（异步任务）之前执行。</p><h3 id="五-nodejs的event-loop"><a class="markdownIt-Anchor" href="#五-nodejs的event-loop"></a> 五、Node.js的Event Loop</h3><p>Node.js也是单线程的Event Loop，但是它的运行机制不同于浏览器环境。</p><p>请看下面的示意图<br /><img src="/imgs/node-event-loop.png" alt="node-event-loop" /><br />根据上图，Node.js的运行机制如下:</p><blockquote><p>（1）V8引擎解析JavaScript脚本。<br />（2）解析后的代码，调用Node API。<br />（3）libuv库负责Node API的执行。它将不同的任务分配给不同的线程，形成一个Event Loop（事件循环），以异步的方式将任务的执行结果返回给V8引擎。<br />（4）V8引擎再将结果返回给用户。</p></blockquote><h3 id="参考文档"><a class="markdownIt-Anchor" href="#参考文档"></a> 参考文档</h3><blockquote><ol><li><a href="https://www.ruanyifeng.com/blog/2014/10/event-loop.html">JavaScript 运行机制详解：再谈Event Loop</a></li></ol></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;一-为什么javascript是单线程&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#一-为什么javascript是单线程&quot;&gt;&lt;/a&gt; 一、为什么JavaScript是单线程？&lt;/h3&gt;
&lt;p&gt;JavaScript语言的一大特点就是单</summary>
      
    
    
    
    <category term="前端开发" scheme="http://www.amaoc.cn/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="js" scheme="http://www.amaoc.cn/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>前端开发规范</title>
    <link href="http://www.amaoc.cn/2023/11/28/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/"/>
    <id>http://www.amaoc.cn/2023/11/28/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/</id>
    <published>2023-11-28T03:37:46.759Z</published>
    <updated>2024-03-04T10:17:23.833Z</updated>
    
    <content type="html"><![CDATA[<h3 id="参考文档"><a class="markdownIt-Anchor" href="#参考文档"></a> 参考文档</h3><blockquote><ol><li><a href="https://www.cnblogs.com/Hsong/p/9016950.html">js命名规范</a></li><li><a href="https://blog.51cto.com/13507333/2052369">前端开发规范：命名规范、html规范、css规范、js规范</a></li></ol></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;参考文档&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#参考文档&quot;&gt;&lt;/a&gt; 参考文档&lt;/h3&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/Hsong/p/901695</summary>
      
    
    
    
    <category term="前端开发" scheme="http://www.amaoc.cn/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="开发规范" scheme="http://www.amaoc.cn/tags/%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/"/>
    
  </entry>
  
  <entry>
    <title>深拷贝与浅拷贝</title>
    <link href="http://www.amaoc.cn/2023/11/28/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D/"/>
    <id>http://www.amaoc.cn/2023/11/28/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D/</id>
    <published>2023-11-28T03:37:46.759Z</published>
    <updated>2024-03-04T10:17:19.337Z</updated>
    
    <content type="html"><![CDATA[<h2 id="如何区分深拷贝和浅拷贝"><a class="markdownIt-Anchor" href="#如何区分深拷贝和浅拷贝"></a> 如何区分深拷贝和浅拷贝</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">假设B复制了A;</span><br><span class="line">当修改了A时，看B是否会发生变化;</span><br><span class="line">如果B也跟着变了，说明这是浅拷贝;</span><br><span class="line">如果B没变，那就是深拷贝。</span><br></pre></td></tr></table></figure><h2 id="基本数据与复杂引用数据"><a class="markdownIt-Anchor" href="#基本数据与复杂引用数据"></a> 基本数据与复杂（引用）数据</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">基本数据类型：number,string,boolean,null,undefined,symbol(ES6),BigInt(ES10);  </span><br><span class="line">引用数据类型：Object,Array,function</span><br></pre></td></tr></table></figure><h3 id="1基本数据类型名值存储在栈内存中"><a class="markdownIt-Anchor" href="#1基本数据类型名值存储在栈内存中"></a> 1.基本数据类型名值存储在栈内存中</h3><p>例如： let a = 1;<br /><img src="/imgs/1.jpg" alt="图片" /></p><p>当你b=a复制时，栈内存会新开辟一个内存<br /><img src="/imgs/2.jpg" alt="图片" /></p><p>所以当你此时修改a=2时，对b并不会对a造成影响，所以深拷贝本身只针对较为复杂的引用数据类型。</p><h3 id="2引用数据类型名存在栈内存中而值却存在于堆内存中栈内存会提供一个引用的地址指向堆内存中的值"><a class="markdownIt-Anchor" href="#2引用数据类型名存在栈内存中而值却存在于堆内存中栈内存会提供一个引用的地址指向堆内存中的值"></a> 2.引用数据类型名存在栈内存中，而值却存在于堆内存中，栈内存会提供一个引用的地址指向堆内存中的值</h3><p>例如： let a = [0,1,2,3,4]<br /><img src="/imgs/3.jpg" alt="图片" /></p><p>当b=a进行拷贝时，其实复制的是a的引用地址，而并非是堆内存里面的值<br /><img src="/imgs/4.jpg" alt="图片" /></p><p>而当我们修改a[0]=1时，由于a与b指向的是同一个地址，所以自然b也受到了影响，这就是浅拷贝了。<br /><img src="/imgs/5.jpg" alt="图片" /></p><p>那么，我们如何在堆内存中也开辟一个新的内存专门为b存放值，就像基本类型一样，就能达到深拷贝了。<br /><img src="/imgs/6.jpg" alt="图片" /></p><h2 id="如何实现浅拷贝"><a class="markdownIt-Anchor" href="#如何实现浅拷贝"></a> 如何实现浅拷贝</h2><ol><li>for…in只循环第一层</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只复制第一层的浅拷贝</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">simpleCopy</span>(<span class="params">obj1</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> obj2 = <span class="title class_">Array</span>.<span class="title function_">isArray</span>(obj1)?[]:&#123;&#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> obj1) &#123;</span><br><span class="line">    obj2[i] = obj1[i]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> obj2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;<span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>, <span class="attr">c</span>: &#123; <span class="attr">d</span>: <span class="number">3</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">var</span> obj2 = <span class="title function_">simpleCopy</span>(obj1);</span><br><span class="line">obj2.<span class="property">a</span> = <span class="number">3</span>;</span><br><span class="line">obj2.<span class="property">c</span>.<span class="property">d</span> = <span class="number">4</span>;</span><br><span class="line"><span class="comment">// # obj1.a       1;</span></span><br><span class="line"><span class="comment">// # obj2.a       3;</span></span><br><span class="line"><span class="comment">// # obj1.c.d     4;</span></span><br><span class="line"><span class="comment">// # obj2.c.d     4;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>Object.assign</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>&#125;</span><br><span class="line"><span class="keyword">var</span> obj1 = <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, obj);</span><br><span class="line"></span><br><span class="line">obj1.<span class="property">a</span> = <span class="number">3</span>;</span><br><span class="line"><span class="comment">// # obj.a       1;</span></span><br></pre></td></tr></table></figure><ol start="3"><li>直接用=赋值</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line"><span class="keyword">let</span> b = a;</span><br><span class="line"></span><br><span class="line"><span class="comment">// # a === b       true;</span></span><br><span class="line">a[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// # b[0]        1;</span></span><br></pre></td></tr></table></figure><h2 id="如何实现深拷贝"><a class="markdownIt-Anchor" href="#如何实现深拷贝"></a> 如何实现深拷贝</h2><ol><li>采用递归去拷贝所以层级属性</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">deepClone</span> (obj) &#123;</span><br><span class="line">  <span class="keyword">let</span> objClone = <span class="title class_">Array</span>.<span class="title function_">isArray</span>(obj) ? [] : &#123;&#125;;</span><br><span class="line">  <span class="keyword">if</span>(obj &amp;&amp; <span class="keyword">typeof</span> obj === <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">      <span class="keyword">if</span>(obj.<span class="title function_">hasOwnProperty</span>(key)) &#123;</span><br><span class="line">        <span class="comment">// # 判断obj子元素是否为对象，如果是，递归复制</span></span><br><span class="line">        <span class="keyword">if</span>(obj[key] &amp;&amp; type obj[key] === <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">          objClone[key] = <span class="title function_">deepClone</span>(obj[key]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// # 如果不是，简单复制</span></span><br><span class="line">          objClone[key] = obj[key];</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> objClone;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line"><span class="keyword">let</span> b = <span class="title function_">deepClone</span>(a);</span><br><span class="line">a[<span class="number">0</span>] = <span class="number">2</span>;</span><br><span class="line"><span class="comment">// # b[0]   1;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>通过JSON对象来实现深拷贝</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">deepClone2</span> (obj) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(obj));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>缺点：无法实现对象中方法的深拷贝，会显示为undefined;</p><ol start="3"><li>通过Jquery的extend方法实现深拷贝</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line"><span class="keyword">let</span> newArr = $.<span class="title function_">extend</span>(<span class="literal">true</span>, [], arr);</span><br></pre></td></tr></table></figure><ol start="4"><li>通过lodash函数实现深拷贝</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result = _.<span class="title function_">cloneDeep</span>(test);</span><br></pre></td></tr></table></figure><ol start="5"><li>Reflect法</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// # 代理法</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">deepClone</span> (obj) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="title function_">isObject</span>(obj)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;obj 不是一个对象&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> isArray = <span class="title class_">Array</span>.<span class="title function_">isArray</span>(obj);</span><br><span class="line">  <span class="keyword">let</span> cloneObj = isArray ? [...obj] : &#123; ...obj &#125;;</span><br><span class="line">  <span class="title class_">Reflect</span>.<span class="title function_">ownKeys</span>(cloneObj).<span class="title function_">forEach</span>(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">    cloneObj[key] = <span class="title function_">isObject</span>(obj[key]) ? <span class="title function_">deepClone</span>(obj[key]) : obj[key];</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> cloneObj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考文案"><a class="markdownIt-Anchor" href="#参考文案"></a> 参考文案</h2><ol><li><a href="https://www.jianshu.com/p/1c142ec2ca45">js浅拷贝与深拷贝的区别和实现方式</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;如何区分深拷贝和浅拷贝&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#如何区分深拷贝和浅拷贝&quot;&gt;&lt;/a&gt; 如何区分深拷贝和浅拷贝&lt;/h2&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;</summary>
      
    
    
    
    <category term="前端开发" scheme="http://www.amaoc.cn/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="js" scheme="http://www.amaoc.cn/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>观察者模式和发布-订阅模式</title>
    <link href="http://www.amaoc.cn/2023/11/28/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%8F%91%E5%B8%83(%E8%AE%A2%E9%98%85)%E6%A8%A1%E5%BC%8F/"/>
    <id>http://www.amaoc.cn/2023/11/28/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%8F%91%E5%B8%83(%E8%AE%A2%E9%98%85)%E6%A8%A1%E5%BC%8F/</id>
    <published>2023-11-28T03:37:46.759Z</published>
    <updated>2023-11-28T03:37:46.760Z</updated>
    
    <content type="html"><![CDATA[<h2 id="观察者模式和发布订阅模式"><a class="markdownIt-Anchor" href="#观察者模式和发布订阅模式"></a> 观察者模式和发布/订阅模式</h2><blockquote><h3 id="观察者模式"><a class="markdownIt-Anchor" href="#观察者模式"></a> 观察者模式</h3><p>目标和观察者是基类，目标提供维护观察者的一系列方法，观察者提供更新接口。具体观察者和具体目标继承各自的基类，然后具体观察者把自己注册到具体目标里，在具体目标发生变化时候，调度观察者的更新方法。<br /><img src="/imgs/1.png" alt="观察者模式" /><br />观察者模式实现代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 观察者列表</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">ObserverList</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">observerList</span> = [];</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">ObserverList</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">add</span> = <span class="keyword">function</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">observerList</span>.<span class="title function_">push</span>(obj);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">ObserverList</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">count</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">observerList</span>.<span class="property">length</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">ObserverList</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">get</span> = <span class="keyword">function</span>(<span class="params">index</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span>(index &gt; -<span class="number">1</span> &amp;&amp; index &lt; <span class="variable language_">this</span>.<span class="property">observerList</span>.<span class="property">length</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">observerList</span>[index];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">ObserverList</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">indexOf</span> = <span class="keyword">function</span>(<span class="params">obj, startIndex</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> i = startIndex || <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(i &lt; <span class="variable language_">this</span>.<span class="property">observerList</span>.<span class="property">length</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="property">observerList</span>[i] === obj) &#123;</span><br><span class="line">      <span class="keyword">return</span> i</span><br><span class="line">    &#125;</span><br><span class="line">    i++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">ObserverList</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">removeAt</span> = <span class="keyword">function</span>(<span class="params">index</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">observerList</span>.<span class="title function_">splice</span>(index, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.目标</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Subject</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">observers</span> = <span class="keyword">new</span> <span class="title class_">ObserverList</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Subject</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">addObserver</span> = <span class="keyword">function</span>(<span class="params">observer</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">observers</span>.<span class="title function_">add</span>(observer);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Subject</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">removeObserver</span> = <span class="keyword">function</span>(<span class="params">observer</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">observers</span>.<span class="title function_">removeAt</span>(<span class="variable language_">this</span>.<span class="property">observers</span>.<span class="title function_">indexOf</span>(observer, <span class="number">0</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Subject</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">notify</span> = <span class="keyword">function</span>(<span class="params">context</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> observerCount = <span class="variable language_">this</span>.<span class="property">observers</span>.<span class="title function_">count</span>();</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; observerCount; i++) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">observers</span>.<span class="title function_">get</span>(i).<span class="title function_">update</span>(context);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.观察者</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Observer</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">update</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用范例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// html </span></span><br><span class="line"><span class="comment">// &lt;button id=&quot;addNewObjserver&quot;&gt;add New Observer checkBox&lt;/button&gt;</span></span><br><span class="line"><span class="comment">// </span></span><br></pre></td></tr></table></figure></blockquote><blockquote><h3 id="发布订阅模式"><a class="markdownIt-Anchor" href="#发布订阅模式"></a> 发布/订阅模式</h3><p>订阅者把自己想订阅的事件注册到调度中心，当该事件触发的时候，发布者发布该事件到调度中心，由调度中心同意调度订阅者注册到调度中心的处理代码。<br /><img src="/imgs/2.png" alt="发布/订阅模式" /><br />发布/订阅模式实现代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pubsub = &#123;&#125;;</span><br><span class="line">(<span class="keyword">function</span>(<span class="params">myObject</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> topics = &#123;&#125;;</span><br><span class="line">  <span class="keyword">var</span> subUid = -<span class="number">1</span>;</span><br><span class="line">  myObject.<span class="property">publish</span> = <span class="keyword">function</span>(<span class="params">topic, args</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!topics[topic]) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> subscribers = topics[topic];</span><br><span class="line">    <span class="keyword">var</span> len = subscribers ? subscribers.<span class="property">length</span> : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (len--) &#123;</span><br><span class="line">      subscribers[len].<span class="title function_">func</span>(topic, func);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">  myObject.<span class="property">subscribe</span> = <span class="keyword">function</span>(<span class="params">topic, func</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!topics[topic]) &#123;</span><br><span class="line">      topics[topic] = [];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> token = (++subUid).<span class="title function_">toString</span>();</span><br><span class="line">    topics[topic].<span class="title function_">push</span>(&#123;</span><br><span class="line">      <span class="attr">token</span>: token,</span><br><span class="line">      <span class="attr">func</span>: func</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> token;</span><br><span class="line">  &#125;</span><br><span class="line">  myObject.<span class="property">unsubscribe</span> = <span class="keyword">function</span>(<span class="params">token</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> m <span class="keyword">in</span> topics) &#123;</span><br><span class="line">      <span class="keyword">if</span>(topics[m]) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>, j = topics[m].<span class="property">length</span>; i &lt; j; i++) &#123;</span><br><span class="line">          <span class="keyword">if</span>(topics[m][i].<span class="property">token</span> === token) &#123;</span><br><span class="line">            topics[m].<span class="title function_">splice</span>(i, <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> token;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)(pubsub)</span><br></pre></td></tr></table></figure></blockquote><blockquote><h3 id="参考文档"><a class="markdownIt-Anchor" href="#参考文档"></a> 参考文档</h3><ol><li><a href="https://www.jianshu.com/p/594f018b68e7">观察者模式和发布订阅模式的区别</a></li><li><a href="https://www.jianshu.com/p/9f2c8ae57cac">设计模式学习之观察者模式和发布订阅模式</a></li><li><a href="https://www.cnblogs.com/lovesong/p/5272752.html">观察者模式与发布/订阅模式区别</a></li><li><a href="https://www.jianshu.com/p/2f94d7596522">JS设计模式2-发布／订阅模式和观察者模式</a></li></ol></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;观察者模式和发布订阅模式&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#观察者模式和发布订阅模式&quot;&gt;&lt;/a&gt; 观察者模式和发布/订阅模式&lt;/h2&gt;
&lt;blockquote&gt;
&lt;h3 id=&quot;观察者模式&quot;&gt;&lt;a class=&quot;markdo</summary>
      
    
    
    
    <category term="前端开发" scheme="http://www.amaoc.cn/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="js" scheme="http://www.amaoc.cn/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>domain实现跨域</title>
    <link href="http://www.amaoc.cn/2023/11/28/domain%E4%BD%BF%E7%94%A8/"/>
    <id>http://www.amaoc.cn/2023/11/28/domain%E4%BD%BF%E7%94%A8/</id>
    <published>2023-11-28T03:37:46.758Z</published>
    <updated>2023-11-28T03:37:46.758Z</updated>
    
    <content type="html"><![CDATA[<h2 id="domain实现跨域"><a class="markdownIt-Anchor" href="#domain实现跨域"></a> domain实现跨域</h2><blockquote><p>因项目需要，需要跨域，而且是在同一个基础域名下，就选择domain来实现，过程较为简单。</p></blockquote><h3 id="前提条件"><a class="markdownIt-Anchor" href="#前提条件"></a> 前提条件</h3><blockquote><p>需跨域的两个域名必须属于同一个基础域名，而且所用的协议(http或https)，端口号必须要一致。否则无法利用document.domain进行跨域。</p><blockquote><ol><li>JavaScript出于对安全性的考虑，而禁止两个或者多个不同域名的页面进行相互操作。</li><li>相同的页面在相互操作的时候，是不会任何有问题的。</li></ol></blockquote></blockquote><h3 id="iframe之间的操作"><a class="markdownIt-Anchor" href="#iframe之间的操作"></a> iframe之间的操作</h3><blockquote><p>例如：</p><blockquote><p>aaa.com的一个网页中（a.html），利用iframe引入来一个bbb.com里的页面（b.html）<br />这时候在a.html中可以看到b.html的内容，但是却不能利用javascript来操作它。因为这两个页面属于不同的域，在操作之前，js会检测两个页面的域是否相等，如果相等，就允许操作，如果不相等，就会拒绝操作。<br />这里不可能把a.html与b.html利用JavaScript改成同一个域。因为它们的基础域名不相等。（强制用JavaScript将它们改成相等的域的话，会报“参数无效错误。”）</p></blockquote><p>另外一种情况：</p><blockquote><p>如果两个子域名：<a href="http://aaa.xxx.xn--combbb-k76j.xxx.com">aaa.xxx.com和bbb.xxx.com</a>；aaa里的页面（a.html）引入里bbb里的一个网页（b.html），这时a.html里同样不能操作b.html里面的内容。因为document.domain不一样，<a href="http://xn--aaa-p18dohm08k.xxx.com">一个是aaa.xxx.com</a>，<a href="http://xn--bbb-p18doh593avnjqk1a.xxx.com">另外一个是bbb.xxx.com</a>。</p></blockquote><p>这时我们就可以通过JavaScript，将两个页面的domain改成一样的。</p><blockquote><p>只需要在a.html里与b.html里都加入</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="property">domain</span> = <span class="string">&#x27;xxx.com&#x27;</span>;</span><br></pre></td></tr></table></figure></blockquote><p>这样两个页面就可以相互操作了。也就实现了同一基础域名之间的“跨域”；</p></blockquote><h3 id="cookie的domain"><a class="markdownIt-Anchor" href="#cookie的domain"></a> cookie的domain</h3><blockquote><p>cookie虽然是由一个网页所创建，但并不只是创建cookie的网页才能读取该cookie。<br />在默认情况下，与创建cookie的网页在同一个目录或者子目录下的所有网页都可以读取该cookie。但是如果在这个目录下还有子目录，要使在子目录中也可以访问。则需要使用path参数设置cookie。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test目录可以访问</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">cookie</span> = <span class="string">&quot;name=&quot;</span> + <span class="built_in">escape</span>(<span class="string">&quot;zhangsan&quot;</span>) + <span class="string">&quot;; path=/test&quot;</span></span><br><span class="line"><span class="comment">// 整个域名下都可以访问</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">cookie</span> = <span class="string">&quot;name=&quot;</span> + <span class="built_in">escape</span>(<span class="string">&quot;zhangsan&quot;</span>) + <span class="string">&quot;; path=/&quot;</span></span><br></pre></td></tr></table></figure></blockquote><blockquote><p>当如果在bbb.xxx.com域名下访问aaa.xxx.com里的cookie，就需要是用domain参数了。<br />例如，在aaa.xxx.com里设置cookie的domain，在bbb.xxx.com里就可以访问到了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意：domian基础域名参数前面最好带一个.</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">cookie</span> = <span class="string">&quot;name=&quot;</span> + <span class="built_in">escape</span>(<span class="string">&quot;zhangsan&quot;</span>) + <span class="string">&quot;; path=/; domain=.xxx.com&quot;</span></span><br></pre></td></tr></table></figure></blockquote><h3 id="参考文档"><a class="markdownIt-Anchor" href="#参考文档"></a> 参考文档</h3><blockquote><ol><li><a href="https://www.jb51.net/article/66497.htm">js设置document.domain实现跨域的注意点分析</a></li><li><a href="https://www.cnblogs.com/ricky_li/p/3365064.html">JavaScript中cookie的路径(path)和域(domain)</a></li></ol></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;domain实现跨域&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#domain实现跨域&quot;&gt;&lt;/a&gt; domain实现跨域&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;因项目需要，需要跨域，而且是在同一个基础域名下，就选择domain来实</summary>
      
    
    
    
    <category term="前端开发" scheme="http://www.amaoc.cn/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="js" scheme="http://www.amaoc.cn/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>js中null、undefined浅谈</title>
    <link href="http://www.amaoc.cn/2023/11/28/js%E4%B8%ADnull%E3%80%81undefined%E6%B5%85%E8%B0%88/"/>
    <id>http://www.amaoc.cn/2023/11/28/js%E4%B8%ADnull%E3%80%81undefined%E6%B5%85%E8%B0%88/</id>
    <published>2023-11-28T03:37:46.758Z</published>
    <updated>2024-03-04T10:18:12.805Z</updated>
    
    <content type="html"><![CDATA[<p>大多数计算机语言，有且只有一个表示“无”的值，比如，C语言的NULL，Java语言的null，Python语言的None，Ruby语言的nil。<br />为啥JavaScript语言居然有两个表示“无”的值：undefined和null</p><h3 id="历史原因"><a class="markdownIt-Anchor" href="#历史原因"></a> 历史原因</h3><p>1995年JavaScript诞生时，最初像Java一样，只设置了null作为表示“无”的值。<br />根据C语言的传统，null被设计成可以自动转为0。</p><p>但是Brendan Eich觉得这样做还不够，有两个原因：</p><ol><li><p>null像在Java里一样，被当成一个对象。但是，JavaScript的数据类型分成原始类型（primitive）和合成类型（complex）两大类，Brendan Eich觉得表示“无”的值最好不是对象。</p></li><li><p>JavaScript的最初版本没有包括错误处理机制，发生数据类型不匹配时，往往时自动转换类型或者默默地失败。Brendan Eich觉得，如果null自动转为0，很不容易发现错误。</p></li></ol><p>因此，Brendan Eich又设计了一个undefined。</p><h3 id="最初设计"><a class="markdownIt-Anchor" href="#最初设计"></a> 最初设计</h3><p>JavaScript的最初版本时这样区分的：</p><ol><li>null 是一个表示“无”的对象，转为数值时为0；</li><li>undefined 是一个表示“无”的原始值，转为数值是为NAN；</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Number</span>(<span class="literal">null</span>)</span><br><span class="line"><span class="comment">// # 0</span></span><br><span class="line"></span><br><span class="line"><span class="number">5</span> + <span class="literal">null</span></span><br><span class="line"><span class="comment">// # 5</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Number</span>(<span class="literal">undefined</span>)</span><br><span class="line"><span class="comment">// # NAN</span></span><br><span class="line"></span><br><span class="line"><span class="number">5</span> + <span class="literal">undefined</span></span><br><span class="line"><span class="comment">// # NAN</span></span><br></pre></td></tr></table></figure><h3 id="目前的用法"><a class="markdownIt-Anchor" href="#目前的用法"></a> 目前的用法</h3><p>按照最初的设计区分，在实践中很快就被证明不可行。实践中有很多需要注意的地方。</p><ol><li><p>null<br />null 是基本数据类型之一，值仅有一个，即为null。表示“空对象”（因此类型检测返回对象），即如果有对象就会是一个具体的对象，如果没有对象，就是null。<br />典型用法：</p><ol><li>作为函数的参数，表示该函数的参数不是对象；</li><li>作为对象的原型链的终点。</li></ol> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>)  <span class="comment">// null</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span>      <span class="comment">// Object</span></span><br></pre></td></tr></table></figure><p>如果定义一个变量准备在将来用来保存对象，那么最好将该变量初始化为null而不是其他值。</p></li><li><p>undefined<br />undefined 是基本数据类型之一，值仅有一个，即为undefined。表示“缺少值”（因此类型检测返回 undefined），即此处应该有一个值，但是还没有定义。<br />典型的用法：</p><ol><li>变量被声明来，但没有赋值是，就等于 undefined 。</li><li>调用函数时，应该提供的参数没有提供，该参数就是undefined。</li><li>对象没有赋值的属性，该属性的值为 undefined。</li><li>函数没有返回值，默认返回 undefined。</li></ol> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i;</span><br><span class="line"><span class="comment">// i undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">x</span>) &#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(x)&#125;</span><br><span class="line"><span class="title function_">f</span>()</span><br><span class="line"><span class="comment">// x undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="comment">// o.p undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x = <span class="title function_">f</span>();</span><br><span class="line"><span class="comment">// x undefined</span></span><br></pre></td></tr></table></figure></li><li><p>如何检测undefined</p></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="keyword">typeof</span> abc == <span class="string">&#x27;undefined&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="keyword">if</span>(abc === <span class="literal">undefined</span>)</span><br></pre></td></tr></table></figure><p>ps: typeof有两种用法: typeof(x) 或者 typeof x</p><ol start="4"><li>如何检测null</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!abc &amp;&amp; <span class="keyword">typeof</span> abc != <span class="string">&#x27;undefined&#x27;</span> &amp;&amp; abc !== <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (abc === <span class="literal">null</span>)</span><br></pre></td></tr></table></figure><h3 id="参考文档"><a class="markdownIt-Anchor" href="#参考文档"></a> 参考文档</h3><ol><li><a href="https://www.cnblogs.com/haishen/p/10718715.html">null 和 undefined 的区别</a></li><li><a href="https://cloud.tencent.com/developer/article/1534974">null 和 undefined</a></li><li><a href="http://www.ruanyifeng.com/blog/2014/03/undefined-vs-null.html">null 和 undefined 的区别</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;大多数计算机语言，有且只有一个表示“无”的值，比如，C语言的NULL，Java语言的null，Python语言的None，Ruby语言的nil。&lt;br /&gt;
为啥JavaScript语言居然有两个表示“无”的值：undefined和null&lt;/p&gt;
&lt;h3 id=&quot;历史原因</summary>
      
    
    
    
    <category term="前端开发" scheme="http://www.amaoc.cn/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="js" scheme="http://www.amaoc.cn/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>js中的内存管理</title>
    <link href="http://www.amaoc.cn/2023/11/28/js%E4%B8%AD%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <id>http://www.amaoc.cn/2023/11/28/js%E4%B8%AD%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</id>
    <published>2023-11-28T03:37:46.758Z</published>
    <updated>2024-03-04T10:18:01.416Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-内存的生命周期"><a class="markdownIt-Anchor" href="#1-内存的生命周期"></a> 1. 内存的生命周期</h3><blockquote><p><img src="/imgs/1.jpeg" alt="内存生命周期" /><br />不管什么语言，内存生命周期基本是一致的：</p><ol><li>分配你所需的内存</li><li>使用分配到的内存（读，写）</li><li>不需要时将其释放/归还<br />在C语言中，有专门的内存管理接口，像malloc() 和 free()。而在js中，没有专门的内存管理接口，所有的内存管理都是“自动”的。<br />js在创建变量时，自动分配内存，并在不使用的时候，自动释放。</li></ol></blockquote><h3 id="2-js中的内存回收"><a class="markdownIt-Anchor" href="#2-js中的内存回收"></a> 2. JS中的内存回收</h3><p>引用</p><blockquote><p>垃圾回收算法主要依赖于引用的概念，在内存管理的环境中，一个对象如果有访问另一个对象的权限（隐式或显式），叫做一个对象引用另一个对象。<br />例如：一个Javascript对象具有堆它原型的引用（隐式引用）和它属性的引用（显式引用）。</p></blockquote><ol><li>引用计数垃圾收集</li></ol><blockquote><p>这是最简单的垃圾回收机制算法。此算法把“对象是否不再需要”简化定义为“对象有没有其他对象引用到它”。如果没有引用指向对象（零引用，对象将被垃圾回收机制回收）<br />例：</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line">arr = <span class="literal">null</span>; <span class="comment">// [1, 2, 3, 4]这时没有被引用，会被自动回收</span></span><br></pre></td></tr></table></figure><ol start="2"><li>限制：循环引用</li></ol><blockquote><p>两个对象被创建并相互引用，就造成零循环引用。它们被调用之后不会离开函数的作用域，所以它们已经没用零，可以被回收了。然而，引用计数算法考虑它们相互都有至少一次引用，所以它们不会被回收<br />例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> o1 = &#123;&#125;;</span><br><span class="line">  <span class="keyword">var</span> o2 = &#123;&#125;;</span><br><span class="line">  o1.<span class="property">p</span> = o2; <span class="comment">// o1 引用了 o2</span></span><br><span class="line">  o2.<span class="property">p</span> = o1; <span class="comment">// o2 引用了 o1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">f</span>();</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div;</span><br><span class="line"><span class="variable language_">window</span>.<span class="property">onload</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  div = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myDivElement&quot;</span>);</span><br><span class="line">  div.<span class="property">circularReference</span> = div;</span><br><span class="line">  div.<span class="property">lotsOfData</span> = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">10000</span>).<span class="title function_">join</span>(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面的例子里，myDivElement这个Dom元素的circularRerence属性引用了myDivElement造成了循环引用。IE6，7使用引用计数方式对DOM对象进行垃圾回收。该方法常常造成对象被循环引用时内存发生泄露。现代浏览器通过使用标记-清除内存回收算法，来解决这一个问题。</p></blockquote><ol start="3"><li>标记-清楚算法</li></ol><blockquote><p>这个算法把“对象是否不再需要”简化定义为“对象是否可以获得”。</p><p>这个算法假定设置一个叫根root的对象（在JavaScript里，根是全局对象）。垃圾回收器将从根开始定期的找所有从根开始引用的对象，然后找这些对象引用的对象，从根开始，垃圾回收器将找到所有可以获得的对象和所有不能获得的对象。</p><p>从2012年起，所有现代浏览器都使用了标记-清除内存回收算法。所有对JavaScript垃圾回收算法的改进都是基于标记-清除算法。</p><p><img src="/imgs/img2.webp" alt="标记-清除算法" /></p></blockquote><ol start="4"><li>自动GC垃圾回收机制</li></ol><blockquote><p>尽管自动GC很方便，但是我们不知道GC什么时候会进行。这意味着如果我们在使用过程中使用了大量的内存，而GC没有运行的情况下，或者GC无法回收这些内存的情况下，程序就有可能假死，这个就需要我们在程序中手动做一些操作来触发内存回收了。</p></blockquote><h3 id="3-什么是内存泄露"><a class="markdownIt-Anchor" href="#3-什么是内存泄露"></a> 3. 什么是内存泄露？</h3><blockquote><p>程序的运行需要内存，程序运行中的各种操作需要消耗资源和内存，程序运行中生成的各种数据也需要内存。若不及时释放内存，则内存的占用越来越高，轻则影响程序和系统的性能，重则导致进程或系统的崩溃。<br />没有即使释放不再使用的内存，就称为内存泄漏。<br />本质的讲，内存泄露就是不再被需要的内存，由于某种原因，无法被释放。</p></blockquote><h3 id="4-哪些内容是垃圾"><a class="markdownIt-Anchor" href="#4-哪些内容是垃圾"></a> 4. 哪些内容是“垃圾”？</h3><p>JS的垃圾回收机制会定期（周期性）找出那些不再用到的内存（变量），然后释放其内存。 很简单，对于我们不再使用的内容，就会视为垃圾处理掉。而对于不再使用的值，则会被垃圾回收。（注意可访问性）</p><ul><li>有用的值：</li></ul><blockquote><p>本地函数的局部变量和参数<br />调用链上的其他函数的变量和参数<br />全局变量<br />可访问的值</p></blockquote><ul><li>无用的值：</li></ul><blockquote><p>地址或值为 null 的值<br />函数的局部作用域中的变量和参数（函数完成后）</p></blockquote><p>等等等等。</p><h3 id="5-常见的内存泄露案例"><a class="markdownIt-Anchor" href="#5-常见的内存泄露案例"></a> 5. 常见的内存泄露案例</h3><ol><li>全局变量</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span> (arg) &#123;</span><br><span class="line">  bar = <span class="string">&quot;some text&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在js中处理未被声明的变量，上述范例中的bar时，会把bar定义到全局对象中，在浏览器中就是window上。在页面中的全局变量，只有当页面被关闭后才会被销毁。所以这种写法就会造成内存泄露，当然这个例子中的泄露的只是一个简单的字符串，但是在实际的代码中，往往情况会更加糟糕。</p><p>另外一种意外创建全局变量的情况。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span> () &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">var1</span> = <span class="string">&quot;potential accidental global&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// foo 被调用时，this指向全局变量window</span></span><br><span class="line"><span class="title function_">foo</span>();</span><br></pre></td></tr></table></figure><blockquote><p>这种情况下调用foo，this被指向了全局变量window，意外的创建了全局变量。</p><p>我们谈到了一些意外情况下定义的全局变量，代码中也有一些我们明确定义的全局变量。如果使用这些全局变量用来暂存大量的数据，记得在使用后，对其重新赋值为null。</p></blockquote><ol start="2"><li>未销毁的定时器和回调函数</li></ol><blockquote><p>很多库中，如果使用了观察者模式，都会提供回调方法，来调用一些回调函数。要记得回收这些回调函数。例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> serverData = <span class="title function_">loadData</span>();</span><br><span class="line"><span class="built_in">setInterval</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> renderer = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;renderer&#x27;</span>);</span><br><span class="line">  <span class="keyword">if</span> (renderer) &#123;</span><br><span class="line">    renderer.<span class="property">innerHTML</span> = <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(serverData);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, <span class="number">5000</span>); <span class="comment">// 每5秒调用一次</span></span><br></pre></td></tr></table></figure><p>如果后续renderer元素被移除，整个定时器实际上没有任何作用。但是如果你没有回收定时器，整个定时器依然有效，不但定时器无法被内存回收，定时器函数中的依赖也无法回收(serverData也无法被回收)。</p></blockquote><ol start="3"><li>闭包</li></ol><blockquote><p>在js开发中，我们经常会用到内部函数，有权访问包含它的外部函数的变量。<br />注意下面这种情况，闭包也会造成内存泄露</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> theThing = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">var</span> replaceThing = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> originalThing = theThing;</span><br><span class="line">  <span class="keyword">var</span> unused = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (originalThing) &#123; <span class="comment">// 对于‘originalThing’的引用</span></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hi&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  theThing = &#123;</span><br><span class="line">    <span class="attr">longStr</span>: <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">1000000</span>).<span class="title function_">join</span>(<span class="string">&#x27;*&#x27;</span>),</span><br><span class="line">    <span class="attr">someMethod</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;message&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">setInterval</span>(replaceThing, <span class="number">10000</span>);</span><br></pre></td></tr></table></figure><p>每次调用replaceThing时，theThing获得了包含一个巨大的数组和一个对于新闭包someMethod的对象，同时unused是一个引用了originalThing的闭包。<br />闭包之间是共享作用域的，尽管unused可能一只都没有被调用，但是someMethod可能会被调用，就会导致内存无法对其进行回收。</p></blockquote><ol start="4"><li>DOM引用</li></ol><blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> elements = &#123;</span><br><span class="line">  <span class="attr">image</span>: <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;image&#x27;</span>)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">doStuff</span>(<span class="params"></span>) &#123;</span><br><span class="line">  elements.<span class="property">image</span>.<span class="property">src</span> = <span class="string">&#x27;http://example.com/img.png&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">removeImage</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">removeChild</span>(<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;image&#x27;</span>));</span><br><span class="line">  <span class="comment">// 这个时候，我们对于#image 仍然有一个引用，Image元素仍然无法被内存回收。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：<br />如果我们引用了一个表格中的td元素，一旦在DOM中删除了整个表格，我们直观的认为内存回收应该回收了除了有引用的td外的其他元素，但是事实上，这个td元素是整个表格的一个子元素，并保留对于其父元素的引用。这个就会导致整个表格都无法进行内存回收。所以我们要小心处理DOM元素的引用。</p></blockquote><h3 id="es6"><a class="markdownIt-Anchor" href="#es6"></a> ES6</h3><blockquote><p>ES中引入了WeakSet和WeakMap两个新概念，来解决引用造成的内存回收问题。WeakSet和WeakMap对于值的引用可以忽略不计，它们对于值的引用都是弱引用，内存回收机制不会考虑这种引用。当其他引用被消除之后，引用就会被内存中释放。</p></blockquote><h2 id="参考文档"><a class="markdownIt-Anchor" href="#参考文档"></a> 参考文档</h2><ol><li><a href="https://www.jianshu.com/p/b31c7d5e8311">JS中的内存管理</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1-内存的生命周期&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#1-内存的生命周期&quot;&gt;&lt;/a&gt; 1. 内存的生命周期&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;img src=&quot;/imgs/1.jpeg&quot; alt=&quot;内存生命周期&quot; </summary>
      
    
    
    
    <category term="前端开发" scheme="http://www.amaoc.cn/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="js" scheme="http://www.amaoc.cn/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>js中的栈内存和堆内存</title>
    <link href="http://www.amaoc.cn/2023/11/28/js%E4%B8%AD%E7%9A%84%E6%A0%88%E5%86%85%E5%AD%98%E5%92%8C%E5%A0%86%E5%86%85%E5%AD%98/"/>
    <id>http://www.amaoc.cn/2023/11/28/js%E4%B8%AD%E7%9A%84%E6%A0%88%E5%86%85%E5%AD%98%E5%92%8C%E5%A0%86%E5%86%85%E5%AD%98/</id>
    <published>2023-11-28T03:37:46.758Z</published>
    <updated>2024-03-04T10:18:07.846Z</updated>
    
    <content type="html"><![CDATA[<p>JavaScript的内存空间分为栈(stack)、堆(heap)、池(或叫栈中);</p><h3 id="栈内存和堆内存简介"><a class="markdownIt-Anchor" href="#栈内存和堆内存简介"></a> 栈内存和堆内存简介</h3><p>JavaScript中并没有严格意义上区分栈内存和堆内存。</p><ol><li>栈数据结构<br />执行上下文的执行顺序借用了栈数据结构的存取方式；<br />栈空间的特点：先进后出，后进先出；<br /><img src="/imgs/1.webp" alt="栈数据结构" /><br />由于栈具有后入先出的特点，所以任何不在栈顶的元素都无法访问。<br />为了得到栈底的元素，必须先拿掉上面的元素；<br />类似乒乓球盒子来分析栈的存取方式。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">栈会自动分配内存空间，物理内存是连续的，可以存放基本类型（Boolean,Number,String,undefined,null,Symbol），简单的数据段，引用类型的物理地址；</span><br><span class="line">占用空间小（大小固定），通过按值来访问，属于被频繁使用的数据。  </span><br><span class="line"></span><br><span class="line">PS：闭包中的基本数据类型变量不会保存在栈内存中，而是保存在堆内存中。</span><br></pre></td></tr></table></figure><ol start="2"><li>堆数据结构<br />堆是一种经过排序的树形数据结构，每个结点都有一个值。<br />通常我们所属的堆的数据结构，是指二叉堆。<br />堆的特点是根结点的值最小（或最大），且根结点的两个子树也是一个堆。<br />这种树状结构，它的存储数据的方式是随意的，与书架与书非常相似。我们不关心书的放置顺序是怎样的，只需要知道书的名字就可以取出我们想要的书了。<br />虽然书的摆放是有顺序的，但我们想取任意一本时不必像栈一样，先取出前面的所有书。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">引用数据类型（Array,Object, Function）存储在堆内存中，因为引用数据类型占据空间大（大小不固定），如果存储在栈中，将会影响程序运行的性能。</span><br><span class="line">引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。</span><br><span class="line">当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。</span><br><span class="line"></span><br><span class="line">堆内存是动态分配的内存，物理地址不连续，大小不定也不会自动释放内存；</span><br></pre></td></tr></table></figure><ol start="3"><li>队列<br />在Javascript中，理解队列数据结构的目的主要是为了清晰的明白事件循环（Event Loop）的机制<br />队列的特点：先进先出，后进后出。<br /><img src="/imgs/2.webp" alt="队列数据结构" /></li></ol><h3 id="栈内存和堆内存的区别"><a class="markdownIt-Anchor" href="#栈内存和堆内存的区别"></a> 栈内存和堆内存的区别</h3><ol><li><p>栈内存：所有在方法中定义的变量都是放在栈内存中，随着方法的执行结束，这个方法的内存栈也自然销毁。<br />优点：存取速度比堆快，仅次于直接位于CPU中的寄存器，数据可共享；<br />缺点：存在栈中的数据大小与生存期必须是确定的，缺乏灵活性。</p></li><li><p>堆内存：堆内存中的对象不会随方法的结束而销毁，即使方法结束后，这个对象海可能被另一个引用变量所引用（参数传递）</p></li></ol><h3 id="赋值与赋址"><a class="markdownIt-Anchor" href="#赋值与赋址"></a> 赋值与赋址</h3><p>引擎不能直接操作堆内存中的数据，这就造成了对同一个变量赋不同类型的值，会出现完全不同的效果：<br />为一个变量赋基本值时，实际上是创建一个新值，然后把该值赋给新变量，可以说这是一种真正意义上的“赋值”；<br />为一个变量赋引用值时，实际上是为新变量添加一个指针，指向堆内存中的一个对象，属于一直“赋址”操作。<br /><img src="/imgs/7.png" alt="图片" /></p><h3 id="内存分配和垃圾回收"><a class="markdownIt-Anchor" href="#内存分配和垃圾回收"></a> 内存分配和垃圾回收</h3><p>一般来说栈内存线性有序存储，容量小，系统分配效率高。而堆内存首先要在堆内存新分配存储区域，之后又要把指针存储到栈内存中，效率相对就要比较低一些。<br />垃圾回收方面，栈内存变量基本上用完了就回收了，而堆内存中的变量因为存在很多不确定的引用，只有当所有调用的变量全部销毁之后才能回收。</p><h3 id="脑洞"><a class="markdownIt-Anchor" href="#脑洞"></a> 脑洞</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. const 定义的基本类型不能改变，但是定义的对象是可以通过修改对象属性等方法来改变的。</span><br><span class="line">因为我们定义一个const对象的时候，，我们说的常量其实是一个指针，就是说const对象对应的堆内存指向是不变的，但是堆内存中的数据本身的大小或者属性是可变的。</span><br></pre></td></tr></table></figure><h2 id="参考文案"><a class="markdownIt-Anchor" href="#参考文案"></a> 参考文案</h2><ol><li><a href="https://www.cnblogs.com/heioray/p/9487093.html">浅析js中的栈内存和堆内存</a></li><li><a href="https://blog.csdn.net/a59612/article/details/93661354">中高级前端必须了解的–JS中的栈内存和堆内存</a></li><li><a href="https://www.jianshu.com/p/0b18e120955b">JavaScript栈内存与堆内存</a></li><li><a href="https://www.jb51.net/article/159120.htm">详解JavaScript栈内存与堆内存</a></li><li><a href="https://blog.csdn.net/qq_36747861/article/details/84958366">js中的栈内存和堆内存</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;JavaScript的内存空间分为栈(stack)、堆(heap)、池(或叫栈中);&lt;/p&gt;
&lt;h3 id=&quot;栈内存和堆内存简介&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#栈内存和堆内存简介&quot;&gt;&lt;/a&gt; 栈内存和堆内存简介&lt;/h3&gt;
&lt;p&gt;J</summary>
      
    
    
    
    <category term="前端开发" scheme="http://www.amaoc.cn/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="js" scheme="http://www.amaoc.cn/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>js的原型和原型链</title>
    <link href="http://www.amaoc.cn/2023/11/28/js%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
    <id>http://www.amaoc.cn/2023/11/28/js%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/</id>
    <published>2023-11-28T03:37:46.758Z</published>
    <updated>2023-11-28T03:37:46.758Z</updated>
    
    <content type="html"><![CDATA[<h2 id="js的原型和原型链"><a class="markdownIt-Anchor" href="#js的原型和原型链"></a> js的原型和原型链</h2><h3 id="普通函数和函数对象"><a class="markdownIt-Anchor" href="#普通函数和函数对象"></a> 普通函数和函数对象</h3><blockquote><p>JavaScript中，万物皆对象！但是对象也是有区别的。分为普通函数和函数对象，Object、Function是JS中自带的函数对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o1 = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> o2 = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="keyword">var</span> o3 = <span class="keyword">new</span> <span class="title function_">f1</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f1</span>(<span class="params"></span>) &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> f2 = <span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> f3 = <span class="keyword">new</span> <span class="title class_">Function</span>(<span class="string">&#x27;str&#x27;</span>, <span class="string">&#x27;console.log(str)&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="title class_">Object</span>); <span class="comment">// function</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="title class_">Function</span>); <span class="comment">// function</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> f1); <span class="comment">// function</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> f2); <span class="comment">// function</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> f3); <span class="comment">// function</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> o1); <span class="comment">// object</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> o2); <span class="comment">// object</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> o3); <span class="comment">// object</span></span><br></pre></td></tr></table></figure><p>在上面的例子中，o1、o2、o3为普通的对象，f1、f2、f3为函数对象。<br />怎么区分？其实很简单：<br />凡是通过new Function() 创建的对象都是函数对象，其他的都是普通对象。f1、f2归根结底都是通过new Function() 的方式进行创建的。Function Object也都是通过new Function() 创建的。</p></blockquote><h3 id="构造函数"><a class="markdownIt-Anchor" href="#构造函数"></a> 构造函数</h3><blockquote><p>我们先复习一下构造函数的知识：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, age, job</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">job</span> = job;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;zhangsan&#x27;</span>, <span class="number">28</span>, <span class="string">&#x27;Software Engineer&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;lisi&#x27;</span>, <span class="number">23</span>, <span class="string">&#x27;Doctor&#x27;</span>);</span><br></pre></td></tr></table></figure><p>上面的例子中的person1和person2都是Person的实例。这两个实例都有一个constructor（构造函数）的属性，该属性(是一个指针)指向Person。即：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person1.<span class="property">constructor</span> === <span class="title class_">Person</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person2.<span class="property">constructor</span> === <span class="title class_">Person</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>我们要记住两个概念（构造函数，实例）：<br />person1和person2都是构造函数Person的实例。<br />一个公式：<br />实例的构造函数属性（constructor）指向构造函数。</p></blockquote><h3 id="原型对象"><a class="markdownIt-Anchor" href="#原型对象"></a> 原型对象</h3><blockquote><p>在JavaScript中，每当定义一个对象（函数也是对象）的时候，对象中都会包含一些预定义的属性。其中每个函数对象都有一个prototype属性，这个属性指向函数的原型对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123;&#125;;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">name</span> = <span class="string">&#x27;zhangsan&#x27;</span>;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">age</span> = <span class="number">28</span>;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">job</span> = <span class="string">&#x27;Softwar Engineer&#x27;</span>;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">person1.<span class="title function_">sayName</span>(); <span class="comment">// &#x27;zhangsan&#x27;;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">person2.<span class="title function_">sayName</span>(); <span class="comment">// &#x27;zhangsan&#x27;;</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person1.<span class="property">sayName</span> === person2.<span class="property">sayName</span>); <span class="comment">// true; </span></span><br></pre></td></tr></table></figure><p>我们得到了文本第一【定律】：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">每个对象都有__proto__属性，但只有函数对象才有prototype属性。</span><br></pre></td></tr></table></figure><p>那什么是原型对象呢？<br />我们把上面的例子改一改就会明白了：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;zhangsan&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">28</span>,</span><br><span class="line">  <span class="attr">job</span>: <span class="string">&#x27;Software&#x27;</span>,</span><br><span class="line">  <span class="attr">sayName</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原型对象，顾名思义，它就是一个普通对象。<br />在上面我们给A添加了四个属性：name，age，job，sayName。其实它还有一个默认属性：constructor。</p><blockquote><p>在默认情况下，所有的原型对象都会自动获得一个constructor（构造函数）的属性，这个属性（是一个指针）指向prototype属性所在的函数（Person）。<br />即 Person.prototype.constructor === Person;</p></blockquote></blockquote><h3 id="参考文档"><a class="markdownIt-Anchor" href="#参考文档"></a> 参考文档</h3><blockquote><ol><li><a href="https://www.jianshu.com/p/dee9f8b14771">最详尽的 JS 原型与原型链终极详解，没有「可能是」。（一）</a></li><li><a href="https://www.jianshu.com/p/652991a67186">最详尽的 JS 原型与原型链终极详解，没有「可能是」。（二）</a></li><li><a href="https://www.jianshu.com/p/a4e1e7b6f4f8">最详尽的 JS 原型与原型链终极详解，没有「可能是」。（三）</a></li></ol></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;js的原型和原型链&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#js的原型和原型链&quot;&gt;&lt;/a&gt; js的原型和原型链&lt;/h2&gt;
&lt;h3 id=&quot;普通函数和函数对象&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;</summary>
      
    
    
    
    <category term="前端开发" scheme="http://www.amaoc.cn/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="js" scheme="http://www.amaoc.cn/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>stylelint 初次使用（vue）</title>
    <link href="http://www.amaoc.cn/2023/11/28/stylelint%E5%88%9D%E6%AC%A1%E4%BD%BF%E7%94%A8/"/>
    <id>http://www.amaoc.cn/2023/11/28/stylelint%E5%88%9D%E6%AC%A1%E4%BD%BF%E7%94%A8/</id>
    <published>2023-11-28T03:37:46.758Z</published>
    <updated>2023-11-28T03:37:46.759Z</updated>
    
    <content type="html"><![CDATA[<h3 id="stylelint-初次使用vue"><a class="markdownIt-Anchor" href="#stylelint-初次使用vue"></a> stylelint 初次使用（vue）</h3><blockquote><p>很早就知道样式校验了，但是一直都没有去了解，因公司对样式比较关怀，所以特意去研究了一下，效果倍爽。。。</p></blockquote><h3 id="安装"><a class="markdownIt-Anchor" href="#安装"></a> 安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">yarn add stylelint stylelint-config-standard stylelint-config-rational-order stylelint-order stylelint-scss stylelint-webpack-plugin --save-dev</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">npm install stylelint stylelint-config-standard stylelint-config-rational-order stylelint-order stylelint-scss stylelint-webpack-plugin --save-dev</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>stylelint是运行工具<br />stylelint-config-standard(stylelint-config-recommentded)是stylelint的推荐配置<br />stylelint-order是css属性排序插件，并且每个规则都支持自动修复（stylelint --fix）<br />stylelint-scss引入了特定的scss规则，是stylelint更好的支持scss语法<br />stylelint-config-rational-order是stylelint配置，通过按照以下顺序将相关属性声明进行分组来对它们进行排序：</p><ol><li>Positioning；</li><li>Box Model；</li><li>Typography；</li><li>Visual；</li><li>Animation；</li><li>Misc；</li></ol><p>stylelint-webpack-plugin是webpack插件，使用stylelint检查css/scss代码。<br />注意：用vue-cli2构建的项目(webpack3.0)，stylelint-wepack-plugin的版本记得选用0.10.5的版本。</p></blockquote><h3 id="配置规则"><a class="markdownIt-Anchor" href="#配置规则"></a> 配置规则</h3><blockquote><p>stylelint配置顺序：</p><blockquote><ol><li>会去找package.json里的stylelint配置</li><li>没有找到package.json的配置，会找.stylelintrc（或者.stylelintrc.json, .stylelintrc.yaml, .stylelintrc.yml, .stylelintrc.js）中的配置</li><li>找stylelint.config.js中的配置</li></ol></blockquote><p>我们一般选用第二个，创建一个.stylelintrc.json文件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;extends&quot;</span>: [<span class="string">&quot;stylelint-config-standard&quot;</span>, <span class="string">&quot;stylelint-config-rational-order&quot;</span>],</span><br><span class="line">  <span class="string">&quot;plugins&quot;</span>: [<span class="string">&quot;stylelint-scss&quot;</span>, <span class="string">&quot;stylelint-order&quot;</span>],</span><br><span class="line">  <span class="string">&quot;rules&quot;</span>: &#123;</span><br><span class="line">    <span class="comment">// 因为开发原因，不可能每个css都给排序，太影响开发效率，所以排序禁用</span></span><br><span class="line">    <span class="string">&quot;no-descending-specificity&quot;</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="comment">// 因为项目中用到里px2rem，不需要转rem的单位我们都用大写的PX来做单位（注释会被scss-loader及stylelint去掉），所以忽略单位大小写</span></span><br><span class="line">    <span class="string">&quot;unit-case&quot;</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="comment">// 嵌套层写5层，太少会影响之前项目代码</span></span><br><span class="line">    <span class="string">&quot;max-nesting-depth&quot;</span>: <span class="number">5</span>,</span><br><span class="line">    <span class="string">&quot;order/order&quot;</span>: [</span><br><span class="line">      <span class="string">&quot;custom-properties&quot;</span>,</span><br><span class="line">      <span class="string">&quot;dollar-variables&quot;</span>,</span><br><span class="line">      <span class="string">&quot;declarations&quot;</span>,</span><br><span class="line">      <span class="string">&quot;rules&quot;</span>,</span><br><span class="line">      <span class="string">&quot;at-rules&quot;</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建忽略stylelint代码文件，.stylelintignore忽略指定目录或文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/dist/</span><br><span class="line">/test/</span><br><span class="line"></span><br><span class="line">*.min.css</span><br><span class="line"></span><br><span class="line">*.js</span><br><span class="line">*.ts</span><br><span class="line">*.png</span><br><span class="line">*.jpg</span><br><span class="line">*.webp</span><br><span class="line">*.ttf</span><br><span class="line">*.woff</span><br></pre></td></tr></table></figure></blockquote><h3 id="配置"><a class="markdownIt-Anchor" href="#配置"></a> 配置</h3><blockquote><ol><li>使用webpack插件校验.vue文件中的style，在vue.config.js中添加</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">configureWebpack</span>: <span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="title class_">StyleLintPlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;stylelint-webpack-plugin&#x27;</span>)</span><br><span class="line">  config.<span class="property">plugins</span>.<span class="title function_">push</span>(</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">StyleLintPlugin</span>(&#123;</span><br><span class="line">      <span class="attr">files</span>: [<span class="string">&#x27;src/**/*.&#123;vue,html,css,scss,sass,less&#125;&#x27;</span>],</span><br><span class="line">      <span class="attr">failOnError</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">cache</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">fix</span>: <span class="literal">true</span>,</span><br><span class="line">    &#125;)</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>用vue-cli2构建的项目中，在/build/webpack.prod.conf.js中添加</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">StyleLintPlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;stylelint-webpack-plugin&#x27;</span>)</span><br><span class="line"><span class="comment">// 在plugins中</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">StyleLintPlugin</span>(&#123;</span><br><span class="line">      <span class="string">&#x27;files&#x27;</span>: [<span class="string">&#x27;src/**/*.&#123;vue,css,sass,scss&#125;&#x27;</span>],</span><br><span class="line">      <span class="string">&#x27;fix&#x27;</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="string">&#x27;cache&#x27;</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="string">&#x27;emitErrors&#x27;</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="string">&#x27;failOnError&#x27;</span>: <span class="literal">false</span></span><br><span class="line">    &#125;),</span><br></pre></td></tr></table></figure><ol start="3"><li>stylelint与eslint同时使用git-hooks配置<br />在package.json中配置</li></ol><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">   <span class="comment">// ...</span></span><br><span class="line">   <span class="attr">&quot;lint-staged&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">       <span class="attr">&quot;*.&#123;vue,js&#125;&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">           <span class="string">&quot;eslint --fix&quot;</span><span class="punctuation">,</span></span><br><span class="line">           <span class="string">&quot;git add&quot;</span></span><br><span class="line">       <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">       <span class="attr">&quot;*.&#123;html,vue,css,sass,scss&#125;&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">           <span class="string">&quot;stylelint --fix&quot;</span><span class="punctuation">,</span></span><br><span class="line">           <span class="string">&quot;git add&quot;</span><span class="punctuation">,</span></span><br><span class="line">       <span class="punctuation">]</span></span><br><span class="line">   <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">   <span class="attr">&quot;husky&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">       <span class="attr">&quot;hooks&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">           <span class="attr">&quot;pre-commit&quot;</span><span class="punctuation">:</span> <span class="string">&quot;lint-staged&quot;</span><span class="punctuation">,</span></span><br><span class="line">       <span class="punctuation">&#125;</span></span><br><span class="line">   <span class="punctuation">&#125;</span></span><br><span class="line"> <span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></blockquote><h3 id="rules规则"><a class="markdownIt-Anchor" href="#rules规则"></a> rules规则</h3><blockquote><p>Color<br />color-hex-case: 指定大写或小写十六进制的颜色。<br />color-hex-length: 指定十六进制颜色长或短的符号。<br />color-named: 需要（如果可能）或不允许命名的颜色。<br />color-no-hex: 不允许十六进制的颜色。<br />color-no-invalid-hex: 禁止无效的十六进制颜色。</p><p>font-family<br />font-family-name-quotes:指定是否引号应该围绕字体系列名称中使用。</p><p>function<br />function-blacklist:指定不允许的功能黑名单<br />function-calc-no-unspaced-operator:计算的函数中禁止的unspaced执行<br />function-comma-newline-after:要求一个新行或函数的逗号后禁止空白。<br />function-comma-newline-before: 要求一个新行或函数的逗号之前不允许空白。<br />function-comma-space-after: 要求一个空格或函数的逗号后禁止空白。<br />function-comma-space-before:要求一个空格或函数的逗号前禁止空白。<br />function-linear-gradient-no-nonstandard-direction:禁止在线性梯度方向值（），根据标准语法是无效的呼叫。<br />function-max-empty-lines: 限制方法中相邻的空行数<br />function-name-case: 指定大写或小写的函数名。<br />function-parentheses-newline-inside:要求一个新行或函数的括号内不允许空白。<br />function-parentheses-space-inside: 要求一个空格或函数的括号内不允许空白。<br />function-url-data-uris: 要求或禁止数据的URI的URL<br />function-url-no-scheme-relative:不允许文档相对的URL。<br />function-url-quotes: 要求或禁止对于网址报价<br />function-url-scheme-whitelist: 指定允许URL方案的白名单。<br />function-whitelist: 指定允许的功能的白名单。<br />function-whitespace-after: 要求方法后不允许空白。</p><p>Number<br />number-leading-zero:要求或分数低于1的数字禁止前导零。<br />number-max-precision:限制允许的小数位数的数目。<br />number-no-trailing-zeros: 禁止在数量尾随零。<br />String<br />string-no-newline: 禁止在字符串（转义）换行。<br />string-quotes: 指定字串，单或双引号。<br />Length<br />length-zero-no-unit: 禁止单位零长度。<br />Time<br />time-no-imperceptible: 禁止动画和过渡小于或等于100毫秒。<br />Unit<br />unit-blacklist: 指定不允许使用单位的黑名单。<br />unit-case: 指定大写或小写的单位。<br />unit-no-unknown: 禁止未知的单位。<br />unit-whitelist: 指定允许单位的白名单&gt;<br />Value<br />value-keyword-case: 指定大写或小写关键字的值。<br />value-no-vendor-prefix: 不允许供应商前缀值。<br />Value list<br />value-list-comma-newline-after: 逗号后需要一个换行符或不允许空白值列表。<br />value-list-comma-newline-before: 逗号前需要一个换行符或不允许空白值列表。<br />value-list-comma-space-after: 需要一个空格或者逗号后不允许空白值列表。<br />value-list-comma-space-before:需要一个空格或者逗号前不允许空白值列表。<br />value-list-max-empty-lines: 限制相邻的数量值列表内空行。<br />Custom property<br />custom-property-empty-line-before: 自定义属性之前equire或不允许空行。<br />custom-property-no-outside-root: 不允许自定义属性以外的:根规则。<br />custom-property-pattern: 为自定义属性指定一个模式。<br />Shorthand property<br />shorthand-property-no-redundant-values:不允许在简写属性冗余值。<br />Property<br />property-blacklist: 指定一个不允许属性的黑名单。<br />property-case: 为属性指定小写或大写。<br />property-no-unknown: 不允许未知属性。<br />property-no-vendor-prefix: 不允许前缀的属性。<br />property-whitelist: 指定一个白名单允许属性。<br />Keyframe declaration<br />keyframe-declaration-no-important: 不允许!important在关键帧声明。<br />Declaration<br />declaration-bang-space-after: bang声明之后需要一个空格或者不允许空白<br />declaration-bang-space-before: bang声明之前需要一个空格或者不允许空白<br />declaration-colon-newline-after: 冒号后的声明需要一个换行符或不允许空白。<br />declaration-colon-space-after: 冒号后的声明需要一个空格或不允许空白。<br />declaration-colon-space-before: 冒号之前的声明需要一个空格或不允许空白。<br />declaration-empty-line-before: 要求声明前不允许空一行。<br />declaration-no-important: 不允许!important声明。<br />declaration-property-unit-blacklist: 指定一个黑名单内不允许声明属性。<br />declaration-property-unit-whitelist: 指定一个白名单内允许声明属性。<br />declaration-property-value-blacklist: 指定一个黑名单,不允许在声明属性和值对。<br />declaration-property-value-whitelist: 指定一个允许属性和值对声明的白名单。<br />Declaration block<br />declaration-block-no-duplicate-properties: 不允许复制属性块中声明<br />declaration-block-no-ignored-properties:不允许被忽略是因为另一个属性值的属性值相同的规则。<br />declaration-block-no-redundant-longhand-properties: 不允许手写属性,可以组合成一个简写属性。<br />declaration-block-no-shorthand-property-overrides: 不允许简写属性覆盖相关手写属性声明块。<br />declaration-block-properties-order: 声明块中指定的顺序属性。<br />declaration-block-semicolon-newline-after: 要求一个换行符或不允许空白块分号后。<br />declaration-block-semicolon-newline-before: 要求一个换行符或不允许空白块分号之前的声明。<br />declaration-block-semicolon-space-after: 要求一个空间或不允许空白块分号后的声明。<br />declaration-block-semicolon-space-before: 要求一个空间或不允许空白块分号之前的声明<br />declaration-block-single-line-max-declarations: 限制声明在一行声明块的数量<br />declaration-block-trailing-semicolon: 要求或不允许在声明块后面的分号。<br />Block<br />block-closing-brace-empty-line-before: 要求或不允许关闭括号前空一行。<br />block-closing-brace-newline-after: 需要一个换行符或不允许关闭括号后的空白。<br />block-closing-brace-newline-before: 需要一个换行符或不允许空白关闭括号前的块。<br />block-closing-brace-space-after: 需要一个空间或不允许关闭括号后的空白块。<br />block-closing-brace-space-before: 在关闭括号前的块需要一个空格或者不允许空白。<br />block-no-empty: 不允许空块<br />block-no-single-line: 不允许单行块<br />block-opening-brace-newline-after: 开括号的块之后需要新的一行。<br />block-opening-brace-newline-before: 开括号的块之后需要一个换行符或不允许空白<br />block-opening-brace-space-after: 开括号的块之后需要一个空格或不允许空白。<br />block-opening-brace-space-before: 开括号的块之前需要一个空格或不允许空白。<br />Selector<br />selector-attribute-brackets-space-inside: 在括号里的属性选择器需要一个空格或者不允许空白。<br />selector-attribute-operator-blacklist: 指定一个黑名单不允许属性的操作符。<br />selector-attribute-operator-space-after: 需要一个空间或不允许空格后运营商在属性选择器。<br />selector-attribute-operator-space-before: 需要一个空间或不允许空格内运营商之前属性选择器。<br />selector-attribute-operator-whitelist: 指定一个属性允许运营商的白名单。<br />selector-attribute-quotes: 需要或不允许引用属性值。<br />selector-class-pattern: 指定一个模式类选择符。<br />selector-combinator-space-after: 需要一个空间或不允许空格后的组合子选择器。<br />selector-combinator-space-before: 需要一个空间或不允许空格前的组合子选择器。<br />selector-descendant-combinator-no-non-space: 不允许的字符的后代组合子选择器进行技术改造。<br />selector-id-pattern: 指定一个模式,id选择器。<br />selector-max-compound-selectors: 在一个选择器里面限制复合选择器的数量。<br />selector-max-specificity: 限制的特异性选择器。<br />selector-nested-pattern: 指定一个模式选择器的规则嵌套规则。<br />selector-no-attribute: 不允许属性选择器。<br />selector-no-combinator: 不允许在选择器组合。<br />selector-no-id: 不允许id选择器。<br />selector-no-qualifying-type: 不允许符合条件的选择器的类型。<br />selector-no-type: 不允许类型选择器。<br />selector-no-universal: Disallow the universal selector.<br />selector-no-vendor-prefix: 不允许选择器的前缀。<br />selector-pseudo-class-blacklist: 指定一个黑名单禁止伪类选择器。<br />selector-pseudo-class-case: 为伪类选择器指定小写或大写。<br />selector-pseudo-class-no-unknown: 不允许未知的伪类选择器。<br />selector-pseudo-class-parentheses-space-inside: 需要一个空格或不允许空格在括号里面的伪类选择器。<br />selector-pseudo-class-whitelist: 伪类选择器允许指定一个白名单。<br />selector-pseudo-element-case: 为伪元素选择器指定小写或大写。<br />selector-pseudo-element-colon-notation: 为适用的伪元素指定单引号或双冒号符号。<br />selector-pseudo-element-no-unknown: 不允许未知的伪元素选择器。<br />selector-root-no-composition: 在选择器不允许根的构成。<br />selector-type-case: 指定小写或大写类型选择器。<br />selector-type-no-unknown: 不允许未知类型选择器。<br />selector-max-empty-lines: 限制内相邻的空行选择器的数量。<br />Selector list<br />selector-list-comma-newline-after: 需要一个换行符或不允许空白选择逗号后的列表。<br />selector-list-comma-newline-before: 逗号前需要一个换行符或不允许空白选择器列表。<br />selector-list-comma-space-after: 需要一个空格或者逗号后不允许空格选择器列表。<br />selector-list-comma-space-before: 需要一个空格或者逗号前不允许空格选择器列表。<br />Root rule<br />root-no-standard-properties: 根规则内不允许标准属性。<br />Rule<br />rule-nested-empty-line-before: 需要或不允许嵌套规则前空一行。<br />rule-non-nested-empty-line-before: 需要或不允许non-nested规则前空一行。<br />Media feature<br />media-feature-colon-space-after: 需要一个空间或不允许空格在冒号之后媒体的特性。<br />media-feature-colon-space-before: 需要一个空间或不允许空格在冒号之前媒体的特性。<br />media-feature-name-case: 为媒体特性名称指定小写或大写。<br />media-feature-name-no-unknown: 不允许未知的媒体功能的名字。<br />media-feature-name-no-vendor-prefix: 不允许媒体特性名称的前缀。<br />media-feature-no-missing-punctuation: 不允许标点non-boolean媒体功能<br />media-feature-parentheses-space-inside: 需要一个空间或不允许空格在括号里面的媒体功能。<br />media-feature-range-operator-space-after: 需要一个空间或不允许空白范围运算符后媒体的特性。<br />media-feature-range-operator-space-before: 之前需要一个空间或不允许空格符范围在媒体功能。<br />Custom media<br />custom-media-pattern: 为定制媒体查询名称指定一个模式。<br />Media query list<br />media-query-list-comma-newline-after: 需要一个换行符或不允许空格后媒体查询的逗号分隔列表。<br />media-query-list-comma-newline-before: 需要一个换行符或不允许空格之前媒体查询的逗号分隔列表<br />media-query-list-comma-space-after: 需要一个空间或不允许空格后媒体查询的逗号分隔列表。<br />media-query-list-comma-space-before:需要一个空间或不允许空格之前媒体查询的逗号分隔列表。<br />At-rule<br />at-rule-blacklist: 不允许at-rules指定一个黑名单。<br />at-rule-empty-line-before: 需要或不允许at-rules前空一行。<br />at-rule-name-case: 指定at-rules小写或大写的名字。<br />at-rule-name-newline-after: at-rule名称后需要一个换行符。<br />at-rule-name-space-after: 需要一个空格后at-rule名称。<br />at-rule-no-unknown: 不允许at-rules不明。<br />at-rule-no-vendor-prefix: 不允许at-rules前缀。<br />at-rule-semicolon-newline-after: 需要一个换行符之后at-rules的分号。<br />at-rule-whitelist: 指定允许at-rules的白名单。<br />stylelint-disable comment<br />stylelint-disable-reason: 需要一个理由stylelint-disable之前或之后的评论发表评论。<br />Comment<br />comment-empty-line-before: 需要或不允许评论之前一个空行。<br />comment-no-empty: 不允许空的评论。<br />comment-whitespace-inside:需要或不允许空格里面的注释标记。<br />comment-word-blacklist: 指定一个黑名单内不允许的话评论。<br />General / Sheet<br />indentation: 指定缩进。<br />max-empty-lines: 限制数量的相邻的空行。<br />max-line-length: 限制线的长度。<br />max-nesting-depth: 限制的深度嵌套。<br />no-browser-hacks: 不允许浏览器黑客,无关你目标的浏览器。<br />no-descending-specificity: 不允许选择器之后覆盖选择器的低特异性更高的特异性。<br />no-duplicate-selectors: 不允许重复的选择器。<br />no-empty-source: 不允许空的来源。<br />no-eol-whitespace: 不允许行尾空白。<br />no-extra-semicolons: 不允许额外的分号。<br />no-indistinguishable-colors: 不允许产品极其接近的颜色相同。<br />no-invalid-double-slash-comments: 不允许双斜杠注释(/ /…)不支持CSS。<br />no-missing-end-of-source-newline: 不允许丢失end-of-source换行。<br />no-unknown-animations: 不允许动画名称不对应@keyframes声明。<br />no-unsupported-browser-features: 不允许功能的浏览器不支持的目标</p></blockquote><h3 id="参考文档"><a class="markdownIt-Anchor" href="#参考文档"></a> 参考文档</h3><blockquote><ol><li><a href="https://blog.csdn.net/lfcss/article/details/82787113">stylelint rules</a></li><li><a href="https://blog.csdn.net/qq_42606051/article/details/85987840">如何为你的 Vue 项目添加配置 Stylelint</a></li><li><a href="https://www.cnblogs.com/huliang56/p/11933938.html">使用stylelint进行Vue项目样式检查</a></li><li><a href="https://stylelint.io/">stylelint官网</a></li></ol></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;stylelint-初次使用vue&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#stylelint-初次使用vue&quot;&gt;&lt;/a&gt; stylelint 初次使用（vue）&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;很早就知道样式校验了，但</summary>
      
    
    
    
    <category term="前端开发" scheme="http://www.amaoc.cn/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="css" scheme="http://www.amaoc.cn/tags/css/"/>
    
    <category term="stylelint" scheme="http://www.amaoc.cn/tags/stylelint/"/>
    
  </entry>
  
</feed>
