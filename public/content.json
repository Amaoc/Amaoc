{"meta":{"title":"Amaoc","subtitle":"blog","description":"Amaoc blog","author":"Amaoc","url":"http://www.amaoc.cn","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2023-11-28T03:37:46.757Z","updated":"2023-11-28T03:37:46.757Z","comments":false,"path":"/404.html","permalink":"http://www.amaoc.cn/404.html","excerpt":"","text":""},{"title":"关于","date":"2023-11-28T03:37:46.761Z","updated":"2023-11-28T03:37:46.761Z","comments":false,"path":"about/index.html","permalink":"http://www.amaoc.cn/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"书单","date":"2023-11-28T03:37:46.763Z","updated":"2023-11-28T03:37:46.763Z","comments":false,"path":"books/index.html","permalink":"http://www.amaoc.cn/books/index.html","excerpt":"","text":""},{"title":"分类","date":"2023-11-28T03:37:46.766Z","updated":"2023-11-28T03:37:46.766Z","comments":false,"path":"categories/index.html","permalink":"http://www.amaoc.cn/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2023-11-28T03:37:46.774Z","updated":"2023-11-28T03:37:46.774Z","comments":true,"path":"links/index.html","permalink":"http://www.amaoc.cn/links/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2023-11-28T03:37:46.775Z","updated":"2023-11-28T03:37:46.775Z","comments":false,"path":"repository/index.html","permalink":"http://www.amaoc.cn/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2023-11-28T03:37:46.775Z","updated":"2023-11-28T03:37:46.775Z","comments":false,"path":"tags/index.html","permalink":"http://www.amaoc.cn/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"事件循环(Event Loop)","slug":"事件循环","date":"2023-11-28T03:44:24.508Z","updated":"2024-03-04T10:17:03.829Z","comments":true,"path":"2023/11/28/事件循环/","link":"","permalink":"http://www.amaoc.cn/2023/11/28/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/","excerpt":"","text":"一、为什么JavaScript是单线程？ JavaScript语言的一大特点就是单线程，也就是说，同一个时间只能做一件事。那么，为什么JavaScript不能有多个线程呢？这样能提高效率啊。 JavaScript的单线程，与它的用途有关。作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。比如，假定JavaScript同时有两个线程，一个线程在某个DOM节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？ 所以，为了避免复杂性，从一诞生，JavaScript就是单线程，这已经成了这门语言的核心特征，将来也不会改变。 为了利用多核CPU的计算能力，HTML5提出Web Worker标准，允许JavaScript脚本创建多个线程，但是子线程完全受主线程控制，且不得操作DOM。所以，这个新标准并没有改变JavaScript单线程的本质。 二、任务队列 单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。如果前一个任务耗时很长，后一个任务就不得不一直等着。 如果排队是因为计算量大，CPU忙不过来，倒也算了，但是很多时候CPU是闲着的，因为IO设备（输入输出设备）很慢（比如Ajax操作从网络读取数据），不得不等着结果出来，再往下执行。 JavaScript语言的设计者意识到，这时主线程完全可以不管IO设备，挂起处于等待中的任务，先运行排在后面的任务。等到IO设备返回了结果，再回过头，把挂起的任务继续执行下去。 于是，所有任务可以分成两种，一种是同步任务（synchronous），另一种是异步任务（asynchronous）。同步任务指的是，在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；异步任务指的是，不进入主线程、而进入&quot;任务队列&quot;（task queue）的任务，只有&quot;任务队列&quot;通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。 具体来说，异步执行的运行机制如下。（同步执行也是如此，因为它可以被视为没有异步任务的异步执行。） （1）所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。 （2）主线程之外，还存在一个&quot;任务队列&quot;（task queue）。只要异步任务有了运行结果，就在&quot;任务队列&quot;之中放置一个事件。 （3）一旦&quot;执行栈&quot;中的所有同步任务执行完毕，系统就会读取&quot;任务队列&quot;，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。 （4）主线程不断重复上面的第三步。 下图就是主线程和任务队列的示意图。 只要主线程空了，就会去读取&quot;任务队列&quot;，这就是JavaScript的运行机制。这个过程会不断重复。 三、事件和回调函数 “任务队列&quot;是一个事件的队列（也可以理解成消息的队列），IO设备完成一项任务，就在&quot;任务队列&quot;中添加一个事件，表示相关的异步任务可以进入&quot;执行栈&quot;了。主线程读取&quot;任务队列”，就是读取里面有哪些事件。 “任务队列&quot;中的事件，除了IO设备的事件以外，还包括一些用户产生的事件（比如鼠标点击、页面滚动等等）。只要指定过回调函数，这些事件发生时就会进入&quot;任务队列”，等待主线程读取。 所谓&quot;回调函数&quot;（callback），就是那些会被主线程挂起来的代码。异步任务必须指定回调函数，当主线程开始执行异步任务，就是执行对应的回调函数。 &quot;任务队列&quot;是一个先进先出的数据结构，排在前面的事件，优先被主线程读取。主线程的读取过程基本上是自动的，只要执行栈一清空，&quot;任务队列&quot;上第一位的事件就自动进入主线程。但是，由于存在后文提到的&quot;定时器&quot;功能，主线程首先要检查一下执行时间，某些事件只有到了规定的时间，才能返回主线程。 四、Event Loop 主线程从&quot;任务队列&quot;中读取事件，这个过程是循环不断的，所以整个的这种运行机制又称为Event Loop（事件循环）。 为了更好地理解Event Loop，请看下图 上图中，主线程运行的时候，产生堆（heap）和栈（stack），栈中的代码调用各种外部API，它们在&quot;任务队列&quot;中加入各种事件（click，load，done）。只要栈中的代码执行完毕，主线程就会去读取&quot;任务队列&quot;，依次执行那些事件所对应的回调函数。 执行栈中的代码（同步任务），总是在读取&quot;任务队列&quot;（异步任务）之前执行。 五、Node.js的Event Loop Node.js也是单线程的Event Loop，但是它的运行机制不同于浏览器环境。 请看下面的示意图 根据上图，Node.js的运行机制如下: （1）V8引擎解析JavaScript脚本。 （2）解析后的代码，调用Node API。 （3）libuv库负责Node API的执行。它将不同的任务分配给不同的线程，形成一个Event Loop（事件循环），以异步的方式将任务的执行结果返回给V8引擎。 （4）V8引擎再将结果返回给用户。 参考文档 JavaScript 运行机制详解：再谈Event Loop","categories":[{"name":"前端开发","slug":"前端开发","permalink":"http://www.amaoc.cn/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"js","slug":"js","permalink":"http://www.amaoc.cn/tags/js/"}]},{"title":"前端开发规范","slug":"前端开发规范","date":"2023-11-28T03:37:46.759Z","updated":"2024-03-04T14:49:57.115Z","comments":true,"path":"2023/11/28/前端开发规范/","link":"","permalink":"http://www.amaoc.cn/2023/11/28/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/","excerpt":"","text":"一、命名规范 注意： 项目名，文件名不能包含 /:?&lt;&gt;| 等特殊符号（windows系统不兼容） 1. 前端业务项目命名 全部采用小写方式， 并以中划线&quot;-&quot;分隔。 以对应的业务组名开头，如：“saas-”，“axcloud-”，“market-”，“tools-platform-”开头。 中间部分必须和后端同学，或者对应的master沟通好之后命名（怕命名重复，或命名不统一，前后端同一项目，命名不同）。 根据应用场景，以“-web”，“-h5”，“-pc”，“-admin”结尾。 例如：saas-xxx-admin 2. 其他前端项目命名 全部采用小写方式， 并以中划线&quot;-&quot;分隔。 模版项目以”-template“结尾。 例如：xxx-template 3. 目录命名 全部采用小驼峰格式 。 有复数结构时，要采用复数命名法，缩写不用复数。 正例：scripts / styles / components / images / utils / layouts / demo-styles / demo-scripts / img / doc / api 反例：script / style / demoScripts / demoStyles / imgs / docs / apis 【特殊】VUE项目中的components组件目录，使用大驼峰命名 正例：HeadSearch / PageLoading 【特殊】VUE的项目中的除了components组件目录外的所有目录也使用小驼峰格式命名。 正例：pageOne / shoppingCar / userManagement 反例：ShopingCar / UserManagement 4. js、css、scss、HTML、PNG文件命名 全部采用小驼峰格式命名。 5 使用Vue或者React技术栈，组件Component命名 全部采用大驼峰格式命名。 例：MyComponent.vue 命名的严谨性 代码中的命名严禁使用拼音与英文混合的方式，更不允许直接使用中文的方式。 说明：正确的英文拼写和语法可以让阅读者更易于理解，避免歧义。 注意：即使纯拼音命名方式也要避免采用。 正例：henan / luoyang /rmb 等国际通用的名称，可视为英文。 反例：DaZhePromotion [打折] / getPingFenByName [评分] / int 某变量 = 3 杜绝完全不规范的缩写，避免望文不知义 需做到望文知义 反例：AbstractClass —&gt; AbsClass，condition —&gt; condi 此类随意缩写严重降低例代码的可阅读性。 如果太长，要用缩写，必须把原来的英文放在注释里。 二、HTML规范（Vue Template同样适用） 1. HTML类型 推荐使用HTML5的文档类型声明： （建议使用text/html格式的HTML。避免使用XHTML。XHTML以及它的属性，比如application/xhtml + xml在浏览器中的应用支持与优化空间都十分有限）。 规定字符编码 IE兼容模式 doctype大写 正例： 1234567891011&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=Edge&quot; /&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;title&gt;Page Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;img src=&quot;images/company-logo.png&quot; alt=&quot;Company&quot;&gt; &lt;/body&gt;&lt;/html&gt; 2. 缩进 缩进使用2个空格（1个tab） 嵌套的节点应该缩进。 3. 分块注释 在每一个块状元素，列表元素和表格元素后，加上一对HTML注释。 注释格式： &lt;!– 英文 / 中文 start --&gt; &lt;!– 英文 / 中文 end --&gt; 正例： 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;!-- 头部 start --&gt; &lt;head&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=Edge&quot; /&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;title&gt;Page Title&lt;/title&gt; &lt;/head&gt; &lt;!-- 头部 end --&gt; &lt;!-- body start --&gt; &lt;body&gt; &lt;a href=&quot;#&quot;&gt; &lt;!-- 图片会把a标签给撑开，所以不用设置a标签的大小 --&gt; &lt;img src=&quot;images/company-logo.png&quot; alt=&quot;Company&quot;&gt; &lt;/a&gt; &lt;/body&gt; &lt;!-- body end --&gt;&lt;/html&gt; 4. 语义化标签 HTML5中新增很多语义化标签，所以优先使用语义化标签，避免一个页面都是div或者p标签 正例： 12&lt;header&gt;&lt;/header&gt;&lt;footer&gt;&lt;/footer&gt; 反例： 123&lt;div&gt; &lt;p&gt;&lt;/p&gt;&lt;/div&gt; 5. 引号 使用双引号(“”) 不使用单引号(‘’) 6. 引入CSS, JS 根据HTML5规范, 通常在引入CSS和JS时不需要指明 type，因为 text/css和 text/javascript 分别是他们的默认值。 123456789101112131415&lt;!-- External CSS --&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;code_guide.css&quot;&gt;&lt;!-- In-document CSS --&gt;&lt;style&gt; &lt;/style&gt;&lt;!-- External JS --&gt;&lt;script src=&quot;code_guide.js&quot;&gt;&lt;/script&gt;&lt;!-- In-document JS --&gt;&lt;script&gt; // ...&lt;/script&gt; 7. 属性顺序 属性名全小写，用中划线做分隔符 123456789101112# 由prettier格式化classidnamedata-*src, for, type, href, value , max-length, max, min, patternplaceholder, title, altaria-*, rolerequired, readonly, disabledclass是为高可复用组件设计的，所以应处在第一位；id 具体且应该尽量少使用，所以将它放在第二位。 12345&lt;a class=&quot;...&quot; id=&quot;...&quot; data-modal=&quot;toggle&quot; href=&quot;#&quot;&gt;Example link&lt;/a&gt;&lt;input class=&quot;form-control&quot; type=&quot;text&quot;&gt;&lt;img src=&quot;...&quot; alt=&quot;...&quot;&gt; 8. 减少标签数量 需要尽量避免多余的父节点； 1234567&lt;!-- 不建议这么做 --&gt;&lt;span class=&quot;avatar&quot;&gt; &lt;img src=&quot;...&quot;&gt;&lt;/span&gt;&lt;!-- 建议这么做 --&gt;&lt;img class=&quot;avatar&quot; src=&quot;...&quot;&gt; 9. 其他 标签必须要关闭 p标签不允许嵌套div等标签 12345678&lt;!-- 例 --&gt;&lt;p&gt; &lt;div&gt;&lt;/div&gt;&lt;/p&gt;&lt;!-- 部分浏览器会解析成 --&gt;&lt;p&gt;&lt;/p&gt;&lt;div&gt;&lt;/div&gt;&lt;p&gt;&lt;/p&gt; 三、CSS/SCSS规范 缩进统一为2个空格 不允许有空的规则出现； 元素选择器用小写字母； 样式的顺序通过prettier来修改； CSS规范 1. 命名 类名使用小写字母，以中划线分隔 id采用驼峰试命名 scss中的变量、函数、混合、placeholder采用驼峰式命名 id和class的名称总是使用可以反应元素目的和用途的名称，或其他通用的名称，代替表象和晦涩难懂的名称 123456789101112131415/* 不推荐： */.fw-800 &#123; font-weight: 800;&#125;.red &#123; color: red;&#125;/* 推荐 */.heavy &#123; font-weight: 800;&#125;.important &#123; color: red;&#125; 2. 选择器 css选择器中避免使用标签名 从结构、表现、行为分离的原则来看，应该尽量避开css中出现的HTML标签，并且在css选择器中出现标签名会存在潜在的问题。 很多前端开发人员写选择器链的时候，不使用直接子选择器（注：直接子选择器和后代选择器的区别）。有时，这可能会导致疼痛的设计问题，并且有时候可能会很耗性能。然而，在任何情况下，这个是一个非常不好的做法。如果你不写很通用，需要匹配到DOM末端的选择器，你应该总是考虑直接子选择器。 123456789/* 不推荐 */.content .title &#123; font-size: 2rem;&#125;/* 推荐 */.content &gt; .title &#123; font-size: 2rem;&#125; 3. 尽量使用缩写属性 123456789101112131415161718/* 不推荐 */.title &#123; border-top-style: none; font-family: palatino, georgia, serif; font-size: 100%; line-height: 1.6; padding-bottom: 2em; padding-left: 2em; padding-right: 2em; padding-top: 2em;&#125;/* 推荐 */.title &#123; border-top: 0; font: 100%/1.6 palatino, georgia, serif; padding: 2em;&#125; 4. 每个选择器及属性独占一行 123456789101112/* 不推荐 */.title &#123; width: 100px;height: 50px; color: #fff; background: #00a0e9;&#125;/* 推荐 */.title &#123; width: 100px; height: 50px; color: #fff; background: #00a0e9;&#125; 5. 省略0后面的单位 1234567891011/* 不推荐 */.title &#123; padding-bottom: 0px; margin: 0em;&#125;/* 推荐 */.title &#123; padding-bottom: 0; margin: 0;&#125; 6. 避免使用ID选择器及全局标签选择器，防止污染全局样式 1234567891011/* 不推荐 */#title &#123; padding-bottom: 0; margin: 0;&#125;/* 推荐 */.title &#123; padding-bottom: 0; margin: 0;&#125; SCSS规范 1. 将公共的scss文件放置在style文件夹内 放置在项目的/src/styles内 nuxt项目可以直接放到/styles内 2. 按以下顺序组织 @import; 变量声明； 样式声明； 12345678@import &quot;styles/size.scss&quot;;@default-text-color: #333;.page &#123; width: 960px; margin: 0 auto;&#125; 3. 避免嵌套层级过多 将嵌套深度限制在3级。对于超过4级的嵌套，给予重新评估，这可以避免出现过于祥实的CSS选择器； 避免大量的嵌套规则。当可读性受到影响时，将之打断。推荐避免出现多于20行的嵌套规则出现； 123456789101112131415/* 不推荐 */.main &#123; .title &#123; .name &#123; color: #fff; &#125; &#125;&#125;/* 推荐 */.main-title &#123; .name &#123; color: #fff; &#125;&#125; 四、JavaScript规范 1. 命名 采用小写驼峰命名lowerCamelCase，代码中的命名均不能以 “_” 开头，也不能以 “_” 或者 “$” 结束； 反例：_name / name_ / name$； 方法名、参数名、成员变量、局部变量都统一用lowerCamelCase风格，必须遵从驼峰形式； 正例：localValue / getHttpMessage() / inputUserId *** 其中method方法命名必须是 “动词” 或者 “动词 + 名词” 的形式 *** 正例：saveShopCarData / openShopCarInfoDialog 反例：save / open / show / go *** 特此说，增删改查，详情统一使用如下5个单词，不得使用其他 *** （目的是为了统一各个端） add / delete / update / get / detail 常量命名全部大写，单词间用下划线隔开，力求语义表达完整清楚，不要嫌弃名字长。 正例：MAX_STOCK_COUNT 反例：MAX_COUNTs 附：函数方法常用的动词 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465handle 处理toggle 切换reset 重置init 初始化get 获取 / set 设置add 增加 / remove 删除create 创建 / destory 移除start 开始 / stop 停止start 开始 / finish 完成begin 开始 / end 结束open 打开 / close 关闭read 读取 / write 写入load 载入 / save 保存create 创建 / destroy 销毁backup 备份 / restore 恢复import 导入 / export 导出split 分割 / merge 合并inject 注入 / extract 提取attach 附着 / detach 脱离bind 绑定 / separate 分离view 查看 / browse 浏览edit 编辑 / modify 修改select 选取 / mark 标记copy 复制 / paste 粘贴undo 撤销 / redo 重做insert 插入 / delete 移除add 加入 / append 添加clean 清理 / clear 清除index 索引 / sort 排序find 查找 / search 搜索increase 增加 / decrease 减少play 播放 / pause 暂停launch 启动 / run 运行compile 编译 / execute 执行debug 调试 / trace 跟踪observe 观察 / listen 监听build 构建 / publish 发布input 输入 / output 输出encode 编码 / decode 解码encrypt 加密 / decrypt 解密compress 压缩 / decompress 解压缩pack 打包 / unpack 解包parse 解析 / emit 生成 / build 构建generate 生成 / emit 发射connect 连接 / disconnect 断开send 发送 / receive 接收download 下载 / upload 上传refresh 刷新 / synchronize 同步update 更新 / revert 复原lock 锁定 / unlock 解锁check out 签出 / check in 签入submit 提交 / commit 交付push 推 / pull 拉expand 展开 / collapse 折叠enter 进入 / exit 退出abort 放弃 / quit 离开obsolete 废弃 / depreciate 废旧collect 收集 / aggregate 聚集shim 衬垫 / sham 伪装pick 拿取 / seek 寻找translate 平移/翻译 / rotate 旋转zoom 变焦 / scale 缩放skew 歪曲 / shear 剪切涉及返回逻辑值的函数可以使用is，can，has，contains等表示逻辑的词语代替动词 附2：一些其他变量命名常用规范（仅供参考） 12345678* s：表示字符串。例如：sName，sHtml；* n：表示数字。例如：nPage，nTotal；* b：表示逻辑。例如：bChecked，bHasLogin；* a：表示数组。例如：aList，aGroup；* r：表示正则表达式。例如：rDomain，rEmail；* f：表示函数。例如：fGetHtml，fInit；* o：表示以上未涉及到的其他对象，例如：oButton，oDate；* g：表示全局变量，例如：gUserName，gLoginTime； 附3：按照前缀区分（仅供参考） 12345678* $：表示Jquery对象。例如：$Content，$Module； 一种比较广泛的Jquery对象变量命名规范。* j：表示Jquery对象。例如：jContent， jModule； 另一种Jquery对象变量命名方式。* fn：表示函数。例如：fnGetName，fnSetAge； 和上面函数的前缀略有不同，改用fn来代替，个人认为fn能够更好的区分普通变量和函数变量。* dom：表示Dom对象，例如：domForm，domInput； 项目中很多地方会用到原生的Dom方法及属性，可以根据团队需要适当修改。 2. 代码格式 使用2个空格进行缩进； 12345if (x &lt; y) &#123; x += 10;&#125; else &#123; x += 1;&#125; 不同逻辑、不同语义，不同业务的代码之间插入一个空行分隔开来，以提升可读性； 说明：任何情形，没有必要插入多个空行进行隔开。 字符串统一使用单引号(')，而不使用双引号(&quot;)。这在创建HTML字符串非常有好处，单引号的处理速度也比双引号快； 1234567// 正例let str = &#x27;foo&#x27;;let testDiv = &#x27;&lt;div id=&quot;test&quot;&gt;&lt;/div&gt;&#x27;;// 反例let str = &quot;foo&quot;;let testDiv = &quot;&lt;div id=&#x27;test&#x27;&gt;&lt;/div&gt;&quot;; 4. 对象声明 使用字面值创建对象； 12345// 正例let user = &#123;&#125;;// 反例let user = new Object(); 使用字面量来代替对象构造器； 123456789101112// 正例let user = &#123; age: 0, name: 1, city: 2&#125;;// 反例let user = new Object();user.age = 0;user.name = 1;user.city = 2; 5. 使用ES6,7 必须优先使用ES6,7中新增的语法糖和函数。这将简化你的程序，并让你的代码更加灵活和可复用。 必须强制使用ES6，ES7的新语法，比如箭头函数，await/async，解构，let，for…of等等。 6. 括号 下列关键字后必须有大括号（即使代码块的内容只有一行）： if, else, for, while, do, switch, try, catch, finally, with。 1234567// 正例if (condition) &#123; doSomething();&#125;// 反例if (condition) doSomething(); 7. undefined 判断 永远不要直接使用undefined进行变量判断； 使用typeof和字符串’undefined’对变量进行判断； 123456789// 正例if (typeof person === &#x27;undefined&#x27;) &#123; // do...&#125;// 反例if (person === undefined) &#123; // do...&#125; 8. 条件判断和循环最多三层 条件判断能使用三元运算符和逻辑运算符解决的，就不要使用条件判断，但是谨记不要写太长的三元运算符。 如果超过3层，请抽成函数，并写清楚注释。 9. this 的转换命名 对上下文 this 的引用只能使用’self’来命名。 10. 慎用 console.log 因 console.log 的大量使用会有性能问题，所以在非webpack项目中谨慎使用log功能。 其他 1）缩进 2个空格 2）属性末尾加分号 3) 空格 在对象，数组括号与文字之间加空格 通过配置prettier实现 4）注释 单行：双斜线后，必须跟一个空格；缩进与下一行代码保持一致；可位于一个代码行的末尾，与代码间隔一个空格。 1234567if (condition) &#123; // if you made it here, then all security checks passed allowed();&#125;var zhangsan = &#x27;zhangsan&#x27;; // one space after code 多行：最少三行, '*'后跟一个空格 1234/* * one space after &#x27;*&#x27; */var x = 1; 方法注释 1234567891011/** * @description 我是一个方法 * @param &#123;string&#125; p1 参数1的说明 * @param &#123;string&#125; p2 参数2的说明，比较长 * 那就换行了. * @param &#123;number=&#125; p3 参数3的说明（可选） * @return &#123;Object&#125; 返回值描述 */function fun(p1, p2, p3) &#123; return &#123;&#125;&#125; 5) 变量命名 标准变量采用驼峰式命名 'ID’在变量名中全大写 'URL’在变量名中全大写 'Android’在变量名中大写第一个字母 'iOS’在变量名中小写第一个，大写后两个字母 常量全大写，用下划线连接 构造函数，大写第一个字母 6)函数 无论是函数声明还是函数表达式，'(‘前不要空格，但’{'前一定要有空格； 函数调用括号前不需要空格； 立即执行函数外必须包一层括号； 不要给inline function命名； 参数之间用’, '分隔，注意逗号后有一个空格。 123456789101112131415161718192021222324252627282930313233343536373839404142434445// no space before &#x27;(&#x27;, but one space before&#x27;&#123;&#x27;var doSomething = function(item) &#123; // do something&#125;;function doSomething(item) &#123; // do something&#125;// not gooddoSomething (item);// gooddoSomething(item);// requires parentheses around immediately invoked function expressions(function() &#123; return 1;&#125;)();// not good[1, 2].forEach(function x() &#123; ...&#125;);// good[1, 2].forEach(function() &#123; ...&#125;);// not goodvar a = [1, 2, function a() &#123; ...&#125;];// goodvar a = [1, 2, function() &#123; ...&#125;];// use &#x27;, &#x27; between function parametersvar doSomething = function(a, b, c) &#123; // do something&#125;; 7) 数组、对象 对象属性名不需要加引号； 对象以缩进的形式书写，不要写在一行； 数组、对象最后不要有逗号。 可通过prettier 配置实现 123456789101112131415161718// not goodvar a = &#123; &#x27;b&#x27;: 1&#125;;var a = &#123;b: 1&#125;;var a = &#123; b: 1, c: 2,&#125;;// goodvar a = &#123; b: 1, c: 2&#125;; 8) 括号 下列关键字后必须有大括号（即使代码块的内容只有一行）：if, else,for, while, do, switch, try, catch, finally, with。 123456789// not goodif (condition) doSomething();// goodif (condition) &#123; doSomething();&#125; 其他 不要混用tab和space； 不要在一处使用多个tab或space； 换行符统一用’LF’； 对上下文this的引用只能使用’_this’, ‘that’, 'self’其中一个来命名； 行尾不要有空白字符； switch的falling through和no default的情况一定要有注释特别说明； 不允许有空的代码块。 五、VUE规范 vue 项目规范以Vue官网规范（ https://cn.vuejs.org/v2/style-guide ）中的A规范为基础，在其上班进行项目开发，故所以代码均遵守该规范。 请仔仔细细阅读Vue官方规范，切记，此为第一步。 1. 组件规范 组件名为多个单词； 组件名应该始终是多个单词组成（大于等于2），且命名规范为KebabCase格式。 这样做可以避免跟现有的以及未来的HTML元素冲突，因为所以的HTML元素名称都是单个单词的。 123456789101112131415// 正例export default &#123; name: &#x27;TodoItem&#x27;, // ...&#125;// 反例export default &#123; name: &#x27;Todo&#x27;, // ...&#125;export default &#123; name: &#x27;todo-item&#x27;, // ...&#125; 组件文件名为大驼峰格式； 12345678# 正例components /|- MyComponent.vue# 反例components /|- myComponent.vue|- my-component.vue 基础组件文件名为base开头，使用完整单词，而不是缩写； 1234567891011# 正例components /|- base-button.vue|- base-table.vue|- base-icon.vue# 反例components /|- MyButton.vue|- VueTable.vue|- Icon.vue 和父组件紧密耦合的子组件应该以父组件名作为前缀命名； 12345678910111213# 正例components /|- todo-list.vue|- todo-list-item.vue|- todo-list-item-button.vue|- user-profile-options.vue # (完整单词)# 反例components /|- TodoList.vue|- TodoItem.vue|- TodoButton.vue|- UProfOpts.vue # (使用来缩写) 在template 模版中使用组件，应使用PascalCase模式，并且使用自闭组件； 12345678&lt;!-- 正例 --&gt;&lt;!-- 在单文件组件、字符串模版和JSX中 --&gt;&lt;MyComponent /&gt;&lt;Row&gt;&lt;table :column=&quot;data&quot; /&gt;&lt;/Row&gt;&lt;!-- 反例 --&gt;&lt;my-component /&gt;&lt;row&gt;&lt;table :column=&quot;data&quot; /&gt;&lt;/row&gt; 组件的data必须是一个函数； 当在组件中使用data属性的时候（除了new Vue外的任何地方），它的值必须是返回一个对象的函数。 因为如果直接是一个对象的化，子组件之间的属性值会相互影响。 1234567891011121314151617// 正例export default &#123; data () &#123; return &#123; name: &#x27;jack&#x27;, &#125; &#125; // ...&#125;// 反例export default &#123; data: &#123; name: &#x27;jack&#x27;, &#125; // ...&#125; Prop 定义应该尽量详细 必须使用camelCase驼峰命名； 必须指定类型； 必须加上注释，表面其含义； 必须加上required 或者 default，两者二选其一； 如果有业务需要，必须加上validator 验证； 12345678910111213141516171819202122// 正例export default &#123; props: &#123; // 组件状态，用于控制组件的颜色 status: &#123; type: String, required: true, validator: function (value) &#123; return [ &#x27;succ&#x27;, &#x27;info&#x27;, &#x27;error&#x27;, ].indexOf(vaule) !== -1 &#125; &#125;, // 用户级别，用于显示皇冠个数 userLevel: &#123; type: String, required: true &#125; &#125;&#125; 为组件样式设置作用域 12345678910&lt;template&gt; &lt;button class=&quot;btn btn-close&quot;&gt;X&lt;/button&gt;&lt;/template&gt;&lt;!-- 正例：使用‘scoped’特性 --&gt;&lt;style scoped&gt;.btn-close &#123; color: red&#125;&lt;/style&gt; 如果特性元素较多时，应该主动换行。 12345678&lt;!-- 正例 --&gt;&lt;MyComponent foo=&quot;a&quot; bar=&quot;b&quot; baz=&quot;c&quot;/&gt;&lt;!-- 反例 --&gt;&lt;MyComponent foo=&quot;a&quot; bar=&quot;b&quot; baz=&quot;c&quot; /&gt; 2. 模版中使用简单的表达式 组件模版应该只包含简单的表达式，复杂的表达式则应该重构为计算属性或方法。 复杂的表达式会让你的模版变得不那么声明式，我们应该尽量描述应该出现的是什么，而非如何计算那个值，而且计算属性和方法使得代码可以重用。 1234567891011121314151617181920&lt;!-- 正例 --&gt;&lt;template&gt; &lt;p&gt;&#123;&#123; normalizedFullName &#125;&#125;&lt;/p&gt;&lt;/template&gt;&lt;script&gt;export default &#123; // 复杂表达式已经移入一个计算属性 computed: &#123; normalizedFullName () &#123; return this.fullName.split(&#x27; &#x27;).map((word) =&gt; word[0].toUpperCase() + word.slice(1)).join(&#x27; &#x27;); &#125; &#125;&#125;&lt;/script&gt;&lt;!-- 反例 --&gt;&lt;template&gt; &lt;p&gt;&#123;&#123; fullName.split(&#x27; &#x27;).map((word) =&gt; word[0].toUpperCase() + word.slice(1)).join(&#x27; &#x27;) &#125;&#125;&lt;/p&gt;&lt;/template&gt; 3. 指令都使用缩写形式 指令推荐都使用缩写形式 用&quot;:“表示&quot;v-bind” 用&quot;@“表示&quot;v-on” 用&quot;#“表示&quot;v-slot” 1234567891011&lt;!-- 正例 --&gt;&lt;input @input=&quot;onInput&quot; @focus=&quot;onFocus&quot;/&gt;&lt;!-- 反例 --&gt;&lt;input v-on:input=&quot;onInput&quot; @focus=&quot;onFocus&quot;/&gt; 4. 标签顺序必须保持一致 单文件组件应该总是让标签顺序保持为 123&lt;template&gt;&lt;/template&gt;&lt;script&gt;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 5. 必须为 v-for 设置健值 key 6. v-show 与 v-if 选择 如果运行时，需要非常频繁地切换，使用v-show； 如果运行时，条件很少改变，使用 v-if； 7. 避免 v-if 和 v-for 用在一起 永远不要把 v-if 和 v-for 同时用在同一个元素上。 一般我们在两种常见的情况下会倾向于这样做： 为了过滤一个列表中的项目 (比如 v-for=“user in users” v-if=“user.isActive”)。在这种情形下，请将 users 替换为一个计算属性 (比如 activeUsers)，让其返回过滤后的列表。 为了避免渲染本应该被隐藏的列表 (比如 v-for=“user in users” v-if=“shouldShowUsers”)。这种情形下，请将 v-if 移动至容器元素上 (比如 ul、ol)。 8. script标签内部结构顺序 components &gt; props &gt; data &gt; computed &gt; watch &gt; filter &gt; 钩子函数(钩子函数按其执行顺序) &gt; methods Vue Router 规范 1. 页面跳转数据传递使用路由参数 页面跳转，例如 A 页面跳转到 B 页面，需要将 A 页面的数据传递到 B 页面，推荐使用路由参数进行传参，而不是将需要传递的数据保存 vuex，然后在 B 页面取出 vuex 的数据，因为如果在 B 页面刷新会导致 vuex 数据丢失，导致 B 页面无法正常显示数据。 12let id = &#x27;123&#x27;;this.$router.push(&#123; name: &#x27;userCenter&#x27;, query: &#123; id: id &#125; &#125;); 2. 使用路由懒加载（延迟加载）机制 12345678&#123; path: &#x27;/uploadAttachment&#x27;, name: &#x27;uploadAttachment&#x27;, meta: &#123; title: &#x27;上传组件&#x27; &#125;, component: () =&gt; import(&#x27;@/views/uploadAttachment.vue&#x27;)&#125; 3. router 中的命名规范 path、chilrenPoints 命名规范采用 kebab-case 命名规范（尽量vue文件的目录结构保持一致，因为目录、文件名都是 kebab-case，这样很方便找到对应的文件） name 命名规范采用 kebabCase 命名规范，且和 component 组件名保持一致！（因为要保持 keep-alive 特性，keep-alive 按照 component 的 name 进行缓存，所以两者必须高度保持一致） 12345678910111213141516171819202122// 动态加载export const reload = [ &#123; path: &#x27;/reload&#x27;, name: &#x27;reload&#x27;, component: Main, meta: &#123; title: &#x27;动态加载&#x27;, icon: &#x27;icon iconfont&#x27; &#125;, children: &#123; path: &#x27;/reload/smart-reload-list&#x27;, name: &#x27;smartReloadList&#x27;, component: Main, meta: &#123; title: &#x27;动态加载&#x27;, icon: &#x27;icon iconfont&#x27; &#125;, component: () =&gt; import(&#x27;@/views/reload/smart-reload-list.vue&#x27;) &#125; &#125;] Vue 项目目录规范 1. 基础 vue项目中的所有命名一定要和后端命名统一； 比如权限：后端privilege，前端物理router，store，api等都必须使用privielege单词 2. 使用 vue-cli 脚手架 使用 vue-cli4 版本的脚手架来初始化项目。 3. 目录说明 目录名按照上面的命名规范，其中 components 组件用大写驼峰，其余除 components 组件目录外的所以目录均使用 kebab-case 命名。 1234567891011121314151617181920212223- mock # mock服务，后期会添加mockjs，加强mock的能力- publish # 公共目录，可以放一些需要放跟目录下文件可以直接拷贝到这边- src # 源代码目录 - api # 公共的api接口文件夹，放组件里的接口或其他公共地方需要使用的接口，即非页面级的接口，方便统一管理 - assets # 静态资源目录 - components # 公共组件目录，非页面级组件目录 - filters # vue的filters组件目录 - layout # 项目的layout放置目录 - index.js # 默认的layout 可以给多个layout使用，前提需在router/index.js上配置 - router # 路由目录 - index.js # 当有新的layout出现时，需在此文件添加你的layout，并指定layout - routes.js # 会自动去找views目录下的routes.js文件，并通过layout参数区分不同的routes - styles # 公共样式目录 - utils # 公共工具目录 - views # 项目页面 - admin # layout为默认的layout，命名为admin的页面目录，访问路径为：/admin/xxx/xxx - home # layout 为admin的某一导航栏内容，包括改导航栏的一二级导航， 访问路径为：/admin/home/xxx - login # 页面的登录页面，后期单点登录项目上线后，会修改 - test # 供给大家参考的目录，包括两个列表页面，后期会添加更多页面供大家拷贝，查看页面路径：/test - App.vue # vue的入口文件 - main.js # 项目的入口文件 - defaultSettings.js # 公共的配置文件 - registerServiceWorker.js # pwa文件 4. views 页面结构说明 12345678views/xxx # layout名字一样的集合，admin为admin的集合，test为test的集合，命名是在views下面的route.js里views/test/xxx # test集合下的某一级导航，里面包含各种二级页面views/test/list # test集合下的list测试列表 - components # 该级下的组件文件夹 - api.js # 该级下的api集合 - index.vue,detail.vue # 该级下的页面，也可以建一个目录放置 - mock.js # 该级下的本地mock数据，目前只是简单的mock，后期会添加mockjs加强处理mock数据 - routes.js # 该级下的路由，使用参考/views/test/list/routes.js 5. 注释说明 整理必须加注释的地方 公共组件使用说明 api目录的接口js文件必须加注释 store 中的 state，mutation，action 等必须加注释 vue 文件中的template 必须加注释，若文件较大加start，end注释 vue 文件的methods，每个method必须加注释 vue 文件的data，非常常见的单词要加注释 6. 其他 尽量不要手动操作 DOM 因使用vue框架，所以在项目开发中，尽量使用 vue 的数据驱动更新 DOM，尽量（不到万不得已）不要手动操作 DOM，包括：增删改 DOM 的元素，以及更改样式，添加事件等。 删除无用代码 因使用了 git 代码管理工具，对于无用代码必须及时删除，例如：一些调用的 console 语句、无用的弃用功能代码。 参考文档 js命名规范 前端开发规范：命名规范、html规范、css规范、js规范","categories":[{"name":"前端开发","slug":"前端开发","permalink":"http://www.amaoc.cn/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"开发规范","slug":"开发规范","permalink":"http://www.amaoc.cn/tags/%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/"}]},{"title":"深拷贝与浅拷贝","slug":"深拷贝与浅拷贝","date":"2023-11-28T03:37:46.759Z","updated":"2024-03-04T10:17:19.337Z","comments":true,"path":"2023/11/28/深拷贝与浅拷贝/","link":"","permalink":"http://www.amaoc.cn/2023/11/28/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D/","excerpt":"","text":"如何区分深拷贝和浅拷贝 1234假设B复制了A;当修改了A时，看B是否会发生变化;如果B也跟着变了，说明这是浅拷贝;如果B没变，那就是深拷贝。 基本数据与复杂（引用）数据 12基本数据类型：number,string,boolean,null,undefined,symbol(ES6),BigInt(ES10); 引用数据类型：Object,Array,function 1.基本数据类型名值存储在栈内存中 例如： let a = 1; 当你b=a复制时，栈内存会新开辟一个内存 所以当你此时修改a=2时，对b并不会对a造成影响，所以深拷贝本身只针对较为复杂的引用数据类型。 2.引用数据类型名存在栈内存中，而值却存在于堆内存中，栈内存会提供一个引用的地址指向堆内存中的值 例如： let a = [0,1,2,3,4] 当b=a进行拷贝时，其实复制的是a的引用地址，而并非是堆内存里面的值 而当我们修改a[0]=1时，由于a与b指向的是同一个地址，所以自然b也受到了影响，这就是浅拷贝了。 那么，我们如何在堆内存中也开辟一个新的内存专门为b存放值，就像基本类型一样，就能达到深拷贝了。 如何实现浅拷贝 for…in只循环第一层 1234567891011121314151617// 只复制第一层的浅拷贝function simpleCopy(obj1) &#123; var obj2 = Array.isArray(obj1)?[]:&#123;&#125;; for (let i in obj1) &#123; obj2[i] = obj1[i] &#125; return obj2;&#125;var obj1 = &#123;a: 1, b: 2, c: &#123; d: 3&#125;&#125;;var obj2 = simpleCopy(obj1);obj2.a = 3;obj2.c.d = 4;// # obj1.a 1;// # obj2.a 3;// # obj1.c.d 4;// # obj2.c.d 4; Object.assign 12345var obj = &#123;a: 1, b: 2&#125;var obj1 = Object.assign(&#123;&#125;, obj);obj1.a = 3;// # obj.a 1; 直接用=赋值 123456let a = [0,1,2,3,4];let b = a;// # a === b true;a[0] = 1;// # b[0] 1; 如何实现深拷贝 采用递归去拷贝所以层级属性 12345678910111213141516171819202122function deepClone (obj) &#123; let objClone = Array.isArray(obj) ? [] : &#123;&#125;; if(obj &amp;&amp; typeof obj === &#x27;object&#x27;) &#123; for (let key in obj) &#123; if(obj.hasOwnProperty(key)) &#123; // # 判断obj子元素是否为对象，如果是，递归复制 if(obj[key] &amp;&amp; type obj[key] === &#x27;object&#x27;) &#123; objClone[key] = deepClone(obj[key]); &#125; else &#123; // # 如果不是，简单复制 objClone[key] = obj[key]; &#125; &#125; &#125; &#125; return objClone;&#125;let a = [1,2,3,4];let b = deepClone(a);a[0] = 2;// # b[0] 1; 通过JSON对象来实现深拷贝 123function deepClone2 (obj) &#123; return JSON.parse(JSON.stringify(obj));&#125; 缺点：无法实现对象中方法的深拷贝，会显示为undefined; 通过Jquery的extend方法实现深拷贝 12let arr = [1,2,3,4];let newArr = $.extend(true, [], arr); 通过lodash函数实现深拷贝 1let result = _.cloneDeep(test); Reflect法 123456789101112// # 代理法function deepClone (obj) &#123; if (!isObject(obj)) &#123; throw new Error(&#x27;obj 不是一个对象&#x27;) &#125; let isArray = Array.isArray(obj); let cloneObj = isArray ? [...obj] : &#123; ...obj &#125;; Reflect.ownKeys(cloneObj).forEach(key =&gt; &#123; cloneObj[key] = isObject(obj[key]) ? deepClone(obj[key]) : obj[key]; &#125;) return cloneObj;&#125; 参考文案 js浅拷贝与深拷贝的区别和实现方式","categories":[{"name":"前端开发","slug":"前端开发","permalink":"http://www.amaoc.cn/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"js","slug":"js","permalink":"http://www.amaoc.cn/tags/js/"}]},{"title":"观察者模式和发布-订阅模式","slug":"观察者模式和发布(订阅)模式","date":"2023-11-28T03:37:46.759Z","updated":"2023-11-28T03:37:46.760Z","comments":true,"path":"2023/11/28/观察者模式和发布(订阅)模式/","link":"","permalink":"http://www.amaoc.cn/2023/11/28/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%8F%91%E5%B8%83(%E8%AE%A2%E9%98%85)%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"观察者模式和发布/订阅模式 观察者模式 目标和观察者是基类，目标提供维护观察者的一系列方法，观察者提供更新接口。具体观察者和具体目标继承各自的基类，然后具体观察者把自己注册到具体目标里，在具体目标发生变化时候，调度观察者的更新方法。 观察者模式实现代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// 1. 观察者列表function ObserverList() &#123; this.observerList = [];&#125;ObserverList.prototype.add = function(obj) &#123; return this.observerList.push(obj);&#125;ObserverList.prototype.count = function() &#123; return this.observerList.length;&#125;ObserverList.prototype.get = function(index) &#123; if(index &gt; -1 &amp;&amp; index &lt; this.observerList.length) &#123; return this.observerList[index]; &#125; return null;&#125;ObserverList.prototype.indexOf = function(obj, startIndex) &#123; var i = startIndex || 0; while(i &lt; this.observerList.length) &#123; if(this.observerList[i] === obj) &#123; return i &#125; i++; &#125; return -1;&#125;ObserverList.prototype.removeAt = function(index) &#123; this.observerList.splice(index, 1);&#125;// 2.目标function Subject() &#123; this.observers = new ObserverList();&#125;Subject.prototype.addObserver = function(observer) &#123; this.observers.add(observer);&#125;Subject.prototype.removeObserver = function(observer) &#123; this.observers.removeAt(this.observers.indexOf(observer, 0));&#125;Subject.prototype.notify = function(context) &#123; var observerCount = this.observers.count(); for(var i = 0; i &lt; observerCount; i++) &#123; this.observers.get(i).update(context); &#125;&#125;// 3.观察者function Observer() &#123; this.update = function() &#123; //... &#125;&#125; 使用范例 123// html // &lt;button id=&quot;addNewObjserver&quot;&gt;add New Observer checkBox&lt;/button&gt;// 发布/订阅模式 订阅者把自己想订阅的事件注册到调度中心，当该事件触发的时候，发布者发布该事件到调度中心，由调度中心同意调度订阅者注册到调度中心的处理代码。 发布/订阅模式实现代码 12345678910111213141516171819202122232425262728293031323334353637383940var pubsub = &#123;&#125;;(function(myObject) &#123; var topics = &#123;&#125;; var subUid = -1; myObject.publish = function(topic, args) &#123; if(!topics[topic]) &#123; return false; &#125; var subscribers = topics[topic]; var len = subscribers ? subscribers.length : 0; while (len--) &#123; subscribers[len].func(topic, func); &#125; return this; &#125;; myObject.subscribe = function(topic, func) &#123; if(!topics[topic]) &#123; topics[topic] = []; &#125; var token = (++subUid).toString(); topics[topic].push(&#123; token: token, func: func &#125;); return token; &#125; myObject.unsubscribe = function(token) &#123; for(var m in topics) &#123; if(topics[m]) &#123; for(var i = 0, j = topics[m].length; i &lt; j; i++) &#123; if(topics[m][i].token === token) &#123; topics[m].splice(i, 1); return token; &#125; &#125; &#125; &#125; return this; &#125;&#125;)(pubsub) 参考文档 观察者模式和发布订阅模式的区别 设计模式学习之观察者模式和发布订阅模式 观察者模式与发布/订阅模式区别 JS设计模式2-发布／订阅模式和观察者模式","categories":[{"name":"前端开发","slug":"前端开发","permalink":"http://www.amaoc.cn/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"js","slug":"js","permalink":"http://www.amaoc.cn/tags/js/"}]},{"title":"domain实现跨域","slug":"domain使用","date":"2023-11-28T03:37:46.758Z","updated":"2023-11-28T03:37:46.758Z","comments":true,"path":"2023/11/28/domain使用/","link":"","permalink":"http://www.amaoc.cn/2023/11/28/domain%E4%BD%BF%E7%94%A8/","excerpt":"","text":"domain实现跨域 因项目需要，需要跨域，而且是在同一个基础域名下，就选择domain来实现，过程较为简单。 前提条件 需跨域的两个域名必须属于同一个基础域名，而且所用的协议(http或https)，端口号必须要一致。否则无法利用document.domain进行跨域。 JavaScript出于对安全性的考虑，而禁止两个或者多个不同域名的页面进行相互操作。 相同的页面在相互操作的时候，是不会任何有问题的。 iframe之间的操作 例如： aaa.com的一个网页中（a.html），利用iframe引入来一个bbb.com里的页面（b.html） 这时候在a.html中可以看到b.html的内容，但是却不能利用javascript来操作它。因为这两个页面属于不同的域，在操作之前，js会检测两个页面的域是否相等，如果相等，就允许操作，如果不相等，就会拒绝操作。 这里不可能把a.html与b.html利用JavaScript改成同一个域。因为它们的基础域名不相等。（强制用JavaScript将它们改成相等的域的话，会报“参数无效错误。”） 另外一种情况： 如果两个子域名：aaa.xxx.com和bbb.xxx.com；aaa里的页面（a.html）引入里bbb里的一个网页（b.html），这时a.html里同样不能操作b.html里面的内容。因为document.domain不一样，一个是aaa.xxx.com，另外一个是bbb.xxx.com。 这时我们就可以通过JavaScript，将两个页面的domain改成一样的。 只需要在a.html里与b.html里都加入 1document.domain = &#x27;xxx.com&#x27;; 这样两个页面就可以相互操作了。也就实现了同一基础域名之间的“跨域”； cookie的domain cookie虽然是由一个网页所创建，但并不只是创建cookie的网页才能读取该cookie。 在默认情况下，与创建cookie的网页在同一个目录或者子目录下的所有网页都可以读取该cookie。但是如果在这个目录下还有子目录，要使在子目录中也可以访问。则需要使用path参数设置cookie。 1234// test目录可以访问document.cookie = &quot;name=&quot; + escape(&quot;zhangsan&quot;) + &quot;; path=/test&quot;// 整个域名下都可以访问document.cookie = &quot;name=&quot; + escape(&quot;zhangsan&quot;) + &quot;; path=/&quot; 当如果在bbb.xxx.com域名下访问aaa.xxx.com里的cookie，就需要是用domain参数了。 例如，在aaa.xxx.com里设置cookie的domain，在bbb.xxx.com里就可以访问到了。 12// 注意：domian基础域名参数前面最好带一个.document.cookie = &quot;name=&quot; + escape(&quot;zhangsan&quot;) + &quot;; path=/; domain=.xxx.com&quot; 参考文档 js设置document.domain实现跨域的注意点分析 JavaScript中cookie的路径(path)和域(domain)","categories":[{"name":"前端开发","slug":"前端开发","permalink":"http://www.amaoc.cn/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"js","slug":"js","permalink":"http://www.amaoc.cn/tags/js/"}]},{"title":"js中null、undefined浅谈","slug":"js中null、undefined浅谈","date":"2023-11-28T03:37:46.758Z","updated":"2024-03-04T10:18:12.805Z","comments":true,"path":"2023/11/28/js中null、undefined浅谈/","link":"","permalink":"http://www.amaoc.cn/2023/11/28/js%E4%B8%ADnull%E3%80%81undefined%E6%B5%85%E8%B0%88/","excerpt":"","text":"大多数计算机语言，有且只有一个表示“无”的值，比如，C语言的NULL，Java语言的null，Python语言的None，Ruby语言的nil。 为啥JavaScript语言居然有两个表示“无”的值：undefined和null 历史原因 1995年JavaScript诞生时，最初像Java一样，只设置了null作为表示“无”的值。 根据C语言的传统，null被设计成可以自动转为0。 但是Brendan Eich觉得这样做还不够，有两个原因： null像在Java里一样，被当成一个对象。但是，JavaScript的数据类型分成原始类型（primitive）和合成类型（complex）两大类，Brendan Eich觉得表示“无”的值最好不是对象。 JavaScript的最初版本没有包括错误处理机制，发生数据类型不匹配时，往往时自动转换类型或者默默地失败。Brendan Eich觉得，如果null自动转为0，很不容易发现错误。 因此，Brendan Eich又设计了一个undefined。 最初设计 JavaScript的最初版本时这样区分的： null 是一个表示“无”的对象，转为数值时为0； undefined 是一个表示“无”的原始值，转为数值是为NAN； 1234567891011Number(null)// # 05 + null// # 5Number(undefined)// # NAN5 + undefined// # NAN 目前的用法 按照最初的设计区分，在实践中很快就被证明不可行。实践中有很多需要注意的地方。 null null 是基本数据类型之一，值仅有一个，即为null。表示“空对象”（因此类型检测返回对象），即如果有对象就会是一个具体的对象，如果没有对象，就是null。 典型用法： 作为函数的参数，表示该函数的参数不是对象； 作为对象的原型链的终点。 12Object.getPrototypeOf(Object.prototype) // nulltypeof null // Object 如果定义一个变量准备在将来用来保存对象，那么最好将该变量初始化为null而不是其他值。 undefined undefined 是基本数据类型之一，值仅有一个，即为undefined。表示“缺少值”（因此类型检测返回 undefined），即此处应该有一个值，但是还没有定义。 典型的用法： 变量被声明来，但没有赋值是，就等于 undefined 。 调用函数时，应该提供的参数没有提供，该参数就是undefined。 对象没有赋值的属性，该属性的值为 undefined。 函数没有返回值，默认返回 undefined。 123456789101112var i;// i undefinedfunction f(x) &#123;console.log(x)&#125;f()// x undefinedvar o = new Object();// o.p undefinedvar x = f();// x undefined 如何检测undefined 1234if(typeof abc == &#x27;undefined&#x27;)// 或者if(abc === undefined) ps: typeof有两种用法: typeof(x) 或者 typeof x 如何检测null 123if(!abc &amp;&amp; typeof abc != &#x27;undefined&#x27; &amp;&amp; abc !== 0)if (abc === null) 参考文档 null 和 undefined 的区别 null 和 undefined null 和 undefined 的区别","categories":[{"name":"前端开发","slug":"前端开发","permalink":"http://www.amaoc.cn/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"js","slug":"js","permalink":"http://www.amaoc.cn/tags/js/"}]},{"title":"js中的内存管理","slug":"js中的内存管理","date":"2023-11-28T03:37:46.758Z","updated":"2024-03-04T10:18:01.416Z","comments":true,"path":"2023/11/28/js中的内存管理/","link":"","permalink":"http://www.amaoc.cn/2023/11/28/js%E4%B8%AD%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/","excerpt":"","text":"1. 内存的生命周期 不管什么语言，内存生命周期基本是一致的： 分配你所需的内存 使用分配到的内存（读，写） 不需要时将其释放/归还 在C语言中，有专门的内存管理接口，像malloc() 和 free()。而在js中，没有专门的内存管理接口，所有的内存管理都是“自动”的。 js在创建变量时，自动分配内存，并在不使用的时候，自动释放。 2. JS中的内存回收 引用 垃圾回收算法主要依赖于引用的概念，在内存管理的环境中，一个对象如果有访问另一个对象的权限（隐式或显式），叫做一个对象引用另一个对象。 例如：一个Javascript对象具有堆它原型的引用（隐式引用）和它属性的引用（显式引用）。 引用计数垃圾收集 这是最简单的垃圾回收机制算法。此算法把“对象是否不再需要”简化定义为“对象有没有其他对象引用到它”。如果没有引用指向对象（零引用，对象将被垃圾回收机制回收） 例： 12let arr = [1, 2, 3, 4];arr = null; // [1, 2, 3, 4]这时没有被引用，会被自动回收 限制：循环引用 两个对象被创建并相互引用，就造成零循环引用。它们被调用之后不会离开函数的作用域，所以它们已经没用零，可以被回收了。然而，引用计数算法考虑它们相互都有至少一次引用，所以它们不会被回收 例： 1234567function f() &#123; var o1 = &#123;&#125;; var o2 = &#123;&#125;; o1.p = o2; // o1 引用了 o2 o2.p = o1; // o2 引用了 o1&#125;f(); 123456var div;window.onload = function () &#123; div = document.getElementById(&quot;myDivElement&quot;); div.circularReference = div; div.lotsOfData = new Array(10000).join(&quot;*&quot;);&#125;; 上面的例子里，myDivElement这个Dom元素的circularRerence属性引用了myDivElement造成了循环引用。IE6，7使用引用计数方式对DOM对象进行垃圾回收。该方法常常造成对象被循环引用时内存发生泄露。现代浏览器通过使用标记-清除内存回收算法，来解决这一个问题。 标记-清楚算法 这个算法把“对象是否不再需要”简化定义为“对象是否可以获得”。 这个算法假定设置一个叫根root的对象（在JavaScript里，根是全局对象）。垃圾回收器将从根开始定期的找所有从根开始引用的对象，然后找这些对象引用的对象，从根开始，垃圾回收器将找到所有可以获得的对象和所有不能获得的对象。 从2012年起，所有现代浏览器都使用了标记-清除内存回收算法。所有对JavaScript垃圾回收算法的改进都是基于标记-清除算法。 自动GC垃圾回收机制 尽管自动GC很方便，但是我们不知道GC什么时候会进行。这意味着如果我们在使用过程中使用了大量的内存，而GC没有运行的情况下，或者GC无法回收这些内存的情况下，程序就有可能假死，这个就需要我们在程序中手动做一些操作来触发内存回收了。 3. 什么是内存泄露？ 程序的运行需要内存，程序运行中的各种操作需要消耗资源和内存，程序运行中生成的各种数据也需要内存。若不及时释放内存，则内存的占用越来越高，轻则影响程序和系统的性能，重则导致进程或系统的崩溃。 没有即使释放不再使用的内存，就称为内存泄漏。 本质的讲，内存泄露就是不再被需要的内存，由于某种原因，无法被释放。 4. 哪些内容是“垃圾”？ JS的垃圾回收机制会定期（周期性）找出那些不再用到的内存（变量），然后释放其内存。 很简单，对于我们不再使用的内容，就会视为垃圾处理掉。而对于不再使用的值，则会被垃圾回收。（注意可访问性） 有用的值： 本地函数的局部变量和参数 调用链上的其他函数的变量和参数 全局变量 可访问的值 无用的值： 地址或值为 null 的值 函数的局部作用域中的变量和参数（函数完成后） 等等等等。 5. 常见的内存泄露案例 全局变量 123function foo (arg) &#123; bar = &quot;some text&quot;;&#125; 在js中处理未被声明的变量，上述范例中的bar时，会把bar定义到全局对象中，在浏览器中就是window上。在页面中的全局变量，只有当页面被关闭后才会被销毁。所以这种写法就会造成内存泄露，当然这个例子中的泄露的只是一个简单的字符串，但是在实际的代码中，往往情况会更加糟糕。 另外一种意外创建全局变量的情况。 12345function foo () &#123; this.var1 = &quot;potential accidental global&quot;;&#125;// foo 被调用时，this指向全局变量windowfoo(); 这种情况下调用foo，this被指向了全局变量window，意外的创建了全局变量。 我们谈到了一些意外情况下定义的全局变量，代码中也有一些我们明确定义的全局变量。如果使用这些全局变量用来暂存大量的数据，记得在使用后，对其重新赋值为null。 未销毁的定时器和回调函数 很多库中，如果使用了观察者模式，都会提供回调方法，来调用一些回调函数。要记得回收这些回调函数。例： 1234567var serverData = loadData();setInterval(function () &#123; var renderer = document.getElementById(&#x27;renderer&#x27;); if (renderer) &#123; renderer.innerHTML = JSON.stringify(serverData); &#125;&#125;, 5000); // 每5秒调用一次 如果后续renderer元素被移除，整个定时器实际上没有任何作用。但是如果你没有回收定时器，整个定时器依然有效，不但定时器无法被内存回收，定时器函数中的依赖也无法回收(serverData也无法被回收)。 闭包 在js开发中，我们经常会用到内部函数，有权访问包含它的外部函数的变量。 注意下面这种情况，闭包也会造成内存泄露 12345678910111213141516var theThing = null;var replaceThing = function () &#123; var originalThing = theThing; var unused = function () &#123; if (originalThing) &#123; // 对于‘originalThing’的引用 console.log(&#x27;hi&#x27;) &#125; &#125; theThing = &#123; longStr: new Array(1000000).join(&#x27;*&#x27;), someMethod: function () &#123; console.log(&#x27;message&#x27;); &#125; &#125;&#125;setInterval(replaceThing, 10000); 每次调用replaceThing时，theThing获得了包含一个巨大的数组和一个对于新闭包someMethod的对象，同时unused是一个引用了originalThing的闭包。 闭包之间是共享作用域的，尽管unused可能一只都没有被调用，但是someMethod可能会被调用，就会导致内存无法对其进行回收。 DOM引用 12345678910var elements = &#123; image: document.getElementById(&#x27;image&#x27;)&#125;;function doStuff() &#123; elements.image.src = &#x27;http://example.com/img.png&#x27;;&#125;function removeImage() &#123; document.body.removeChild(document.getElementById(&#x27;image&#x27;)); // 这个时候，我们对于#image 仍然有一个引用，Image元素仍然无法被内存回收。&#125; 注意： 如果我们引用了一个表格中的td元素，一旦在DOM中删除了整个表格，我们直观的认为内存回收应该回收了除了有引用的td外的其他元素，但是事实上，这个td元素是整个表格的一个子元素，并保留对于其父元素的引用。这个就会导致整个表格都无法进行内存回收。所以我们要小心处理DOM元素的引用。 ES6 ES中引入了WeakSet和WeakMap两个新概念，来解决引用造成的内存回收问题。WeakSet和WeakMap对于值的引用可以忽略不计，它们对于值的引用都是弱引用，内存回收机制不会考虑这种引用。当其他引用被消除之后，引用就会被内存中释放。 参考文档 JS中的内存管理","categories":[{"name":"前端开发","slug":"前端开发","permalink":"http://www.amaoc.cn/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"js","slug":"js","permalink":"http://www.amaoc.cn/tags/js/"}]},{"title":"js中的栈内存和堆内存","slug":"js中的栈内存和堆内存","date":"2023-11-28T03:37:46.758Z","updated":"2024-03-04T10:18:07.846Z","comments":true,"path":"2023/11/28/js中的栈内存和堆内存/","link":"","permalink":"http://www.amaoc.cn/2023/11/28/js%E4%B8%AD%E7%9A%84%E6%A0%88%E5%86%85%E5%AD%98%E5%92%8C%E5%A0%86%E5%86%85%E5%AD%98/","excerpt":"","text":"JavaScript的内存空间分为栈(stack)、堆(heap)、池(或叫栈中); 栈内存和堆内存简介 JavaScript中并没有严格意义上区分栈内存和堆内存。 栈数据结构 执行上下文的执行顺序借用了栈数据结构的存取方式； 栈空间的特点：先进后出，后进先出； 由于栈具有后入先出的特点，所以任何不在栈顶的元素都无法访问。 为了得到栈底的元素，必须先拿掉上面的元素； 类似乒乓球盒子来分析栈的存取方式。 1234栈会自动分配内存空间，物理内存是连续的，可以存放基本类型（Boolean,Number,String,undefined,null,Symbol），简单的数据段，引用类型的物理地址；占用空间小（大小固定），通过按值来访问，属于被频繁使用的数据。 PS：闭包中的基本数据类型变量不会保存在栈内存中，而是保存在堆内存中。 堆数据结构 堆是一种经过排序的树形数据结构，每个结点都有一个值。 通常我们所属的堆的数据结构，是指二叉堆。 堆的特点是根结点的值最小（或最大），且根结点的两个子树也是一个堆。 这种树状结构，它的存储数据的方式是随意的，与书架与书非常相似。我们不关心书的放置顺序是怎样的，只需要知道书的名字就可以取出我们想要的书了。 虽然书的摆放是有顺序的，但我们想取任意一本时不必像栈一样，先取出前面的所有书。 12345引用数据类型（Array,Object, Function）存储在堆内存中，因为引用数据类型占据空间大（大小不固定），如果存储在栈中，将会影响程序运行的性能。引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。堆内存是动态分配的内存，物理地址不连续，大小不定也不会自动释放内存； 队列 在Javascript中，理解队列数据结构的目的主要是为了清晰的明白事件循环（Event Loop）的机制 队列的特点：先进先出，后进后出。 栈内存和堆内存的区别 栈内存：所有在方法中定义的变量都是放在栈内存中，随着方法的执行结束，这个方法的内存栈也自然销毁。 优点：存取速度比堆快，仅次于直接位于CPU中的寄存器，数据可共享； 缺点：存在栈中的数据大小与生存期必须是确定的，缺乏灵活性。 堆内存：堆内存中的对象不会随方法的结束而销毁，即使方法结束后，这个对象海可能被另一个引用变量所引用（参数传递） 赋值与赋址 引擎不能直接操作堆内存中的数据，这就造成了对同一个变量赋不同类型的值，会出现完全不同的效果： 为一个变量赋基本值时，实际上是创建一个新值，然后把该值赋给新变量，可以说这是一种真正意义上的“赋值”； 为一个变量赋引用值时，实际上是为新变量添加一个指针，指向堆内存中的一个对象，属于一直“赋址”操作。 内存分配和垃圾回收 一般来说栈内存线性有序存储，容量小，系统分配效率高。而堆内存首先要在堆内存新分配存储区域，之后又要把指针存储到栈内存中，效率相对就要比较低一些。 垃圾回收方面，栈内存变量基本上用完了就回收了，而堆内存中的变量因为存在很多不确定的引用，只有当所有调用的变量全部销毁之后才能回收。 脑洞 121. const 定义的基本类型不能改变，但是定义的对象是可以通过修改对象属性等方法来改变的。因为我们定义一个const对象的时候，，我们说的常量其实是一个指针，就是说const对象对应的堆内存指向是不变的，但是堆内存中的数据本身的大小或者属性是可变的。 参考文案 浅析js中的栈内存和堆内存 中高级前端必须了解的–JS中的栈内存和堆内存 JavaScript栈内存与堆内存 详解JavaScript栈内存与堆内存 js中的栈内存和堆内存","categories":[{"name":"前端开发","slug":"前端开发","permalink":"http://www.amaoc.cn/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"js","slug":"js","permalink":"http://www.amaoc.cn/tags/js/"}]},{"title":"js的原型和原型链","slug":"js原型和原型链","date":"2023-11-28T03:37:46.758Z","updated":"2023-11-28T03:37:46.758Z","comments":true,"path":"2023/11/28/js原型和原型链/","link":"","permalink":"http://www.amaoc.cn/2023/11/28/js%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/","excerpt":"","text":"js的原型和原型链 普通函数和函数对象 JavaScript中，万物皆对象！但是对象也是有区别的。分为普通函数和函数对象，Object、Function是JS中自带的函数对象。 123456789101112131415161718var o1 = &#123;&#125;;var o2 = new Object();var o3 = new f1();function f1() &#123;&#125;;var f2 = function() &#123;&#125;;var f3 = new Function(&#x27;str&#x27;, &#x27;console.log(str)&#x27;);console.log(typeof Object); // functionconsole.log(typeof Function); // functionconsole.log(typeof f1); // functionconsole.log(typeof f2); // functionconsole.log(typeof f3); // functionconsole.log(typeof o1); // objectconsole.log(typeof o2); // objectconsole.log(typeof o3); // object 在上面的例子中，o1、o2、o3为普通的对象，f1、f2、f3为函数对象。 怎么区分？其实很简单： 凡是通过new Function() 创建的对象都是函数对象，其他的都是普通对象。f1、f2归根结底都是通过new Function() 的方式进行创建的。Function Object也都是通过new Function() 创建的。 构造函数 我们先复习一下构造函数的知识： 12345678910function Person(name, age, job) &#123; this.name = name; this.age = age; this.job = job; this.sayName = function() &#123; console.log(this.name) &#125;&#125;var person1 = new Person(&#x27;zhangsan&#x27;, 28, &#x27;Software Engineer&#x27;);var person2 = new Person(&#x27;lisi&#x27;, 23, &#x27;Doctor&#x27;); 上面的例子中的person1和person2都是Person的实例。这两个实例都有一个constructor（构造函数）的属性，该属性(是一个指针)指向Person。即： 12console.log(person1.constructor === Person); // trueconsole.log(person2.constructor === Person); // true 我们要记住两个概念（构造函数，实例）： person1和person2都是构造函数Person的实例。 一个公式： 实例的构造函数属性（constructor）指向构造函数。 原型对象 在JavaScript中，每当定义一个对象（函数也是对象）的时候，对象中都会包含一些预定义的属性。其中每个函数对象都有一个prototype属性，这个属性指向函数的原型对象。 1234567891011121314function Person() &#123;&#125;;Person.prototype.name = &#x27;zhangsan&#x27;;Person.prototype.age = 28;Person.prototype.job = &#x27;Softwar Engineer&#x27;;Person.prototype.sayName = function() &#123; console.log(this.name);&#125;var person1 = new Person();person1.sayName(); // &#x27;zhangsan&#x27;;var person2 = new Person();person2.sayName(); // &#x27;zhangsan&#x27;;console.log(person1.sayName === person2.sayName); // true; 我们得到了文本第一【定律】： 1每个对象都有__proto__属性，但只有函数对象才有prototype属性。 那什么是原型对象呢？ 我们把上面的例子改一改就会明白了： 12345678Person.prototype = &#123; name: &#x27;zhangsan&#x27;, age: 28, job: &#x27;Software&#x27;, sayName: function() &#123; console.log(this.name); &#125;&#125; 原型对象，顾名思义，它就是一个普通对象。 在上面我们给A添加了四个属性：name，age，job，sayName。其实它还有一个默认属性：constructor。 在默认情况下，所有的原型对象都会自动获得一个constructor（构造函数）的属性，这个属性（是一个指针）指向prototype属性所在的函数（Person）。 即 Person.prototype.constructor === Person; 参考文档 最详尽的 JS 原型与原型链终极详解，没有「可能是」。（一） 最详尽的 JS 原型与原型链终极详解，没有「可能是」。（二） 最详尽的 JS 原型与原型链终极详解，没有「可能是」。（三）","categories":[{"name":"前端开发","slug":"前端开发","permalink":"http://www.amaoc.cn/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"js","slug":"js","permalink":"http://www.amaoc.cn/tags/js/"}]},{"title":"stylelint 初次使用（vue）","slug":"stylelint初次使用","date":"2023-11-28T03:37:46.758Z","updated":"2023-11-28T03:37:46.759Z","comments":true,"path":"2023/11/28/stylelint初次使用/","link":"","permalink":"http://www.amaoc.cn/2023/11/28/stylelint%E5%88%9D%E6%AC%A1%E4%BD%BF%E7%94%A8/","excerpt":"","text":"stylelint 初次使用（vue） 很早就知道样式校验了，但是一直都没有去了解，因公司对样式比较关怀，所以特意去研究了一下，效果倍爽。。。 安装 12345yarn add stylelint stylelint-config-standard stylelint-config-rational-order stylelint-order stylelint-scss stylelint-webpack-plugin --save-dev# 或者npm install stylelint stylelint-config-standard stylelint-config-rational-order stylelint-order stylelint-scss stylelint-webpack-plugin --save-dev stylelint是运行工具 stylelint-config-standard(stylelint-config-recommentded)是stylelint的推荐配置 stylelint-order是css属性排序插件，并且每个规则都支持自动修复（stylelint --fix） stylelint-scss引入了特定的scss规则，是stylelint更好的支持scss语法 stylelint-config-rational-order是stylelint配置，通过按照以下顺序将相关属性声明进行分组来对它们进行排序： Positioning； Box Model； Typography； Visual； Animation； Misc； stylelint-webpack-plugin是webpack插件，使用stylelint检查css/scss代码。 注意：用vue-cli2构建的项目(webpack3.0)，stylelint-wepack-plugin的版本记得选用0.10.5的版本。 配置规则 stylelint配置顺序： 会去找package.json里的stylelint配置 没有找到package.json的配置，会找.stylelintrc（或者.stylelintrc.json, .stylelintrc.yaml, .stylelintrc.yml, .stylelintrc.js）中的配置 找stylelint.config.js中的配置 我们一般选用第二个，创建一个.stylelintrc.json文件 12345678910111213141516171819&#123; &quot;extends&quot;: [&quot;stylelint-config-standard&quot;, &quot;stylelint-config-rational-order&quot;], &quot;plugins&quot;: [&quot;stylelint-scss&quot;, &quot;stylelint-order&quot;], &quot;rules&quot;: &#123; // 因为开发原因，不可能每个css都给排序，太影响开发效率，所以排序禁用 &quot;no-descending-specificity&quot;: null, // 因为项目中用到里px2rem，不需要转rem的单位我们都用大写的PX来做单位（注释会被scss-loader及stylelint去掉），所以忽略单位大小写 &quot;unit-case&quot;: null, // 嵌套层写5层，太少会影响之前项目代码 &quot;max-nesting-depth&quot;: 5, &quot;order/order&quot;: [ &quot;custom-properties&quot;, &quot;dollar-variables&quot;, &quot;declarations&quot;, &quot;rules&quot;, &quot;at-rules&quot; ] &#125;&#125; 创建忽略stylelint代码文件，.stylelintignore忽略指定目录或文件 123456789101112/dist//test/*.min.css*.js*.ts*.png*.jpg*.webp*.ttf*.woff 配置 使用webpack插件校验.vue文件中的style，在vue.config.js中添加 1234567891011configureWebpack: config =&gt; &#123; const StyleLintPlugin = require(&#x27;stylelint-webpack-plugin&#x27;) config.plugins.push( new StyleLintPlugin(&#123; files: [&#x27;src/**/*.&#123;vue,html,css,scss,sass,less&#125;&#x27;], failOnError: false, cache: true, fix: true, &#125;) )&#125; 用vue-cli2构建的项目中，在/build/webpack.prod.conf.js中添加 123456789const StyleLintPlugin = require(&#x27;stylelint-webpack-plugin&#x27;)// 在plugins中new StyleLintPlugin(&#123; &#x27;files&#x27;: [&#x27;src/**/*.&#123;vue,css,sass,scss&#125;&#x27;], &#x27;fix&#x27;: true, &#x27;cache&#x27;: true, &#x27;emitErrors&#x27;: true, &#x27;failOnError&#x27;: false &#125;), stylelint与eslint同时使用git-hooks配置 在package.json中配置 123456789101112131415161718&#123; // ... &quot;lint-staged&quot;: &#123; &quot;*.&#123;vue,js&#125;&quot;: [ &quot;eslint --fix&quot;, &quot;git add&quot; ], &quot;*.&#123;html,vue,css,sass,scss&#125;&quot;: [ &quot;stylelint --fix&quot;, &quot;git add&quot;, ] &#125;, &quot;husky&quot;: &#123; &quot;hooks&quot;: &#123; &quot;pre-commit&quot;: &quot;lint-staged&quot;, &#125; &#125; &#125; rules规则 Color color-hex-case: 指定大写或小写十六进制的颜色。 color-hex-length: 指定十六进制颜色长或短的符号。 color-named: 需要（如果可能）或不允许命名的颜色。 color-no-hex: 不允许十六进制的颜色。 color-no-invalid-hex: 禁止无效的十六进制颜色。 font-family font-family-name-quotes:指定是否引号应该围绕字体系列名称中使用。 function function-blacklist:指定不允许的功能黑名单 function-calc-no-unspaced-operator:计算的函数中禁止的unspaced执行 function-comma-newline-after:要求一个新行或函数的逗号后禁止空白。 function-comma-newline-before: 要求一个新行或函数的逗号之前不允许空白。 function-comma-space-after: 要求一个空格或函数的逗号后禁止空白。 function-comma-space-before:要求一个空格或函数的逗号前禁止空白。 function-linear-gradient-no-nonstandard-direction:禁止在线性梯度方向值（），根据标准语法是无效的呼叫。 function-max-empty-lines: 限制方法中相邻的空行数 function-name-case: 指定大写或小写的函数名。 function-parentheses-newline-inside:要求一个新行或函数的括号内不允许空白。 function-parentheses-space-inside: 要求一个空格或函数的括号内不允许空白。 function-url-data-uris: 要求或禁止数据的URI的URL function-url-no-scheme-relative:不允许文档相对的URL。 function-url-quotes: 要求或禁止对于网址报价 function-url-scheme-whitelist: 指定允许URL方案的白名单。 function-whitelist: 指定允许的功能的白名单。 function-whitespace-after: 要求方法后不允许空白。 Number number-leading-zero:要求或分数低于1的数字禁止前导零。 number-max-precision:限制允许的小数位数的数目。 number-no-trailing-zeros: 禁止在数量尾随零。 String string-no-newline: 禁止在字符串（转义）换行。 string-quotes: 指定字串，单或双引号。 Length length-zero-no-unit: 禁止单位零长度。 Time time-no-imperceptible: 禁止动画和过渡小于或等于100毫秒。 Unit unit-blacklist: 指定不允许使用单位的黑名单。 unit-case: 指定大写或小写的单位。 unit-no-unknown: 禁止未知的单位。 unit-whitelist: 指定允许单位的白名单&gt; Value value-keyword-case: 指定大写或小写关键字的值。 value-no-vendor-prefix: 不允许供应商前缀值。 Value list value-list-comma-newline-after: 逗号后需要一个换行符或不允许空白值列表。 value-list-comma-newline-before: 逗号前需要一个换行符或不允许空白值列表。 value-list-comma-space-after: 需要一个空格或者逗号后不允许空白值列表。 value-list-comma-space-before:需要一个空格或者逗号前不允许空白值列表。 value-list-max-empty-lines: 限制相邻的数量值列表内空行。 Custom property custom-property-empty-line-before: 自定义属性之前equire或不允许空行。 custom-property-no-outside-root: 不允许自定义属性以外的:根规则。 custom-property-pattern: 为自定义属性指定一个模式。 Shorthand property shorthand-property-no-redundant-values:不允许在简写属性冗余值。 Property property-blacklist: 指定一个不允许属性的黑名单。 property-case: 为属性指定小写或大写。 property-no-unknown: 不允许未知属性。 property-no-vendor-prefix: 不允许前缀的属性。 property-whitelist: 指定一个白名单允许属性。 Keyframe declaration keyframe-declaration-no-important: 不允许!important在关键帧声明。 Declaration declaration-bang-space-after: bang声明之后需要一个空格或者不允许空白 declaration-bang-space-before: bang声明之前需要一个空格或者不允许空白 declaration-colon-newline-after: 冒号后的声明需要一个换行符或不允许空白。 declaration-colon-space-after: 冒号后的声明需要一个空格或不允许空白。 declaration-colon-space-before: 冒号之前的声明需要一个空格或不允许空白。 declaration-empty-line-before: 要求声明前不允许空一行。 declaration-no-important: 不允许!important声明。 declaration-property-unit-blacklist: 指定一个黑名单内不允许声明属性。 declaration-property-unit-whitelist: 指定一个白名单内允许声明属性。 declaration-property-value-blacklist: 指定一个黑名单,不允许在声明属性和值对。 declaration-property-value-whitelist: 指定一个允许属性和值对声明的白名单。 Declaration block declaration-block-no-duplicate-properties: 不允许复制属性块中声明 declaration-block-no-ignored-properties:不允许被忽略是因为另一个属性值的属性值相同的规则。 declaration-block-no-redundant-longhand-properties: 不允许手写属性,可以组合成一个简写属性。 declaration-block-no-shorthand-property-overrides: 不允许简写属性覆盖相关手写属性声明块。 declaration-block-properties-order: 声明块中指定的顺序属性。 declaration-block-semicolon-newline-after: 要求一个换行符或不允许空白块分号后。 declaration-block-semicolon-newline-before: 要求一个换行符或不允许空白块分号之前的声明。 declaration-block-semicolon-space-after: 要求一个空间或不允许空白块分号后的声明。 declaration-block-semicolon-space-before: 要求一个空间或不允许空白块分号之前的声明 declaration-block-single-line-max-declarations: 限制声明在一行声明块的数量 declaration-block-trailing-semicolon: 要求或不允许在声明块后面的分号。 Block block-closing-brace-empty-line-before: 要求或不允许关闭括号前空一行。 block-closing-brace-newline-after: 需要一个换行符或不允许关闭括号后的空白。 block-closing-brace-newline-before: 需要一个换行符或不允许空白关闭括号前的块。 block-closing-brace-space-after: 需要一个空间或不允许关闭括号后的空白块。 block-closing-brace-space-before: 在关闭括号前的块需要一个空格或者不允许空白。 block-no-empty: 不允许空块 block-no-single-line: 不允许单行块 block-opening-brace-newline-after: 开括号的块之后需要新的一行。 block-opening-brace-newline-before: 开括号的块之后需要一个换行符或不允许空白 block-opening-brace-space-after: 开括号的块之后需要一个空格或不允许空白。 block-opening-brace-space-before: 开括号的块之前需要一个空格或不允许空白。 Selector selector-attribute-brackets-space-inside: 在括号里的属性选择器需要一个空格或者不允许空白。 selector-attribute-operator-blacklist: 指定一个黑名单不允许属性的操作符。 selector-attribute-operator-space-after: 需要一个空间或不允许空格后运营商在属性选择器。 selector-attribute-operator-space-before: 需要一个空间或不允许空格内运营商之前属性选择器。 selector-attribute-operator-whitelist: 指定一个属性允许运营商的白名单。 selector-attribute-quotes: 需要或不允许引用属性值。 selector-class-pattern: 指定一个模式类选择符。 selector-combinator-space-after: 需要一个空间或不允许空格后的组合子选择器。 selector-combinator-space-before: 需要一个空间或不允许空格前的组合子选择器。 selector-descendant-combinator-no-non-space: 不允许的字符的后代组合子选择器进行技术改造。 selector-id-pattern: 指定一个模式,id选择器。 selector-max-compound-selectors: 在一个选择器里面限制复合选择器的数量。 selector-max-specificity: 限制的特异性选择器。 selector-nested-pattern: 指定一个模式选择器的规则嵌套规则。 selector-no-attribute: 不允许属性选择器。 selector-no-combinator: 不允许在选择器组合。 selector-no-id: 不允许id选择器。 selector-no-qualifying-type: 不允许符合条件的选择器的类型。 selector-no-type: 不允许类型选择器。 selector-no-universal: Disallow the universal selector. selector-no-vendor-prefix: 不允许选择器的前缀。 selector-pseudo-class-blacklist: 指定一个黑名单禁止伪类选择器。 selector-pseudo-class-case: 为伪类选择器指定小写或大写。 selector-pseudo-class-no-unknown: 不允许未知的伪类选择器。 selector-pseudo-class-parentheses-space-inside: 需要一个空格或不允许空格在括号里面的伪类选择器。 selector-pseudo-class-whitelist: 伪类选择器允许指定一个白名单。 selector-pseudo-element-case: 为伪元素选择器指定小写或大写。 selector-pseudo-element-colon-notation: 为适用的伪元素指定单引号或双冒号符号。 selector-pseudo-element-no-unknown: 不允许未知的伪元素选择器。 selector-root-no-composition: 在选择器不允许根的构成。 selector-type-case: 指定小写或大写类型选择器。 selector-type-no-unknown: 不允许未知类型选择器。 selector-max-empty-lines: 限制内相邻的空行选择器的数量。 Selector list selector-list-comma-newline-after: 需要一个换行符或不允许空白选择逗号后的列表。 selector-list-comma-newline-before: 逗号前需要一个换行符或不允许空白选择器列表。 selector-list-comma-space-after: 需要一个空格或者逗号后不允许空格选择器列表。 selector-list-comma-space-before: 需要一个空格或者逗号前不允许空格选择器列表。 Root rule root-no-standard-properties: 根规则内不允许标准属性。 Rule rule-nested-empty-line-before: 需要或不允许嵌套规则前空一行。 rule-non-nested-empty-line-before: 需要或不允许non-nested规则前空一行。 Media feature media-feature-colon-space-after: 需要一个空间或不允许空格在冒号之后媒体的特性。 media-feature-colon-space-before: 需要一个空间或不允许空格在冒号之前媒体的特性。 media-feature-name-case: 为媒体特性名称指定小写或大写。 media-feature-name-no-unknown: 不允许未知的媒体功能的名字。 media-feature-name-no-vendor-prefix: 不允许媒体特性名称的前缀。 media-feature-no-missing-punctuation: 不允许标点non-boolean媒体功能 media-feature-parentheses-space-inside: 需要一个空间或不允许空格在括号里面的媒体功能。 media-feature-range-operator-space-after: 需要一个空间或不允许空白范围运算符后媒体的特性。 media-feature-range-operator-space-before: 之前需要一个空间或不允许空格符范围在媒体功能。 Custom media custom-media-pattern: 为定制媒体查询名称指定一个模式。 Media query list media-query-list-comma-newline-after: 需要一个换行符或不允许空格后媒体查询的逗号分隔列表。 media-query-list-comma-newline-before: 需要一个换行符或不允许空格之前媒体查询的逗号分隔列表 media-query-list-comma-space-after: 需要一个空间或不允许空格后媒体查询的逗号分隔列表。 media-query-list-comma-space-before:需要一个空间或不允许空格之前媒体查询的逗号分隔列表。 At-rule at-rule-blacklist: 不允许at-rules指定一个黑名单。 at-rule-empty-line-before: 需要或不允许at-rules前空一行。 at-rule-name-case: 指定at-rules小写或大写的名字。 at-rule-name-newline-after: at-rule名称后需要一个换行符。 at-rule-name-space-after: 需要一个空格后at-rule名称。 at-rule-no-unknown: 不允许at-rules不明。 at-rule-no-vendor-prefix: 不允许at-rules前缀。 at-rule-semicolon-newline-after: 需要一个换行符之后at-rules的分号。 at-rule-whitelist: 指定允许at-rules的白名单。 stylelint-disable comment stylelint-disable-reason: 需要一个理由stylelint-disable之前或之后的评论发表评论。 Comment comment-empty-line-before: 需要或不允许评论之前一个空行。 comment-no-empty: 不允许空的评论。 comment-whitespace-inside:需要或不允许空格里面的注释标记。 comment-word-blacklist: 指定一个黑名单内不允许的话评论。 General / Sheet indentation: 指定缩进。 max-empty-lines: 限制数量的相邻的空行。 max-line-length: 限制线的长度。 max-nesting-depth: 限制的深度嵌套。 no-browser-hacks: 不允许浏览器黑客,无关你目标的浏览器。 no-descending-specificity: 不允许选择器之后覆盖选择器的低特异性更高的特异性。 no-duplicate-selectors: 不允许重复的选择器。 no-empty-source: 不允许空的来源。 no-eol-whitespace: 不允许行尾空白。 no-extra-semicolons: 不允许额外的分号。 no-indistinguishable-colors: 不允许产品极其接近的颜色相同。 no-invalid-double-slash-comments: 不允许双斜杠注释(/ /…)不支持CSS。 no-missing-end-of-source-newline: 不允许丢失end-of-source换行。 no-unknown-animations: 不允许动画名称不对应@keyframes声明。 no-unsupported-browser-features: 不允许功能的浏览器不支持的目标 参考文档 stylelint rules 如何为你的 Vue 项目添加配置 Stylelint 使用stylelint进行Vue项目样式检查 stylelint官网","categories":[{"name":"前端开发","slug":"前端开发","permalink":"http://www.amaoc.cn/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"css","slug":"css","permalink":"http://www.amaoc.cn/tags/css/"},{"name":"stylelint","slug":"stylelint","permalink":"http://www.amaoc.cn/tags/stylelint/"}]}],"categories":[{"name":"前端开发","slug":"前端开发","permalink":"http://www.amaoc.cn/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"js","slug":"js","permalink":"http://www.amaoc.cn/tags/js/"},{"name":"开发规范","slug":"开发规范","permalink":"http://www.amaoc.cn/tags/%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/"},{"name":"css","slug":"css","permalink":"http://www.amaoc.cn/tags/css/"},{"name":"stylelint","slug":"stylelint","permalink":"http://www.amaoc.cn/tags/stylelint/"}]}