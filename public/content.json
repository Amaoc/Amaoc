{"meta":{"title":"Amaoc","subtitle":"blog","description":"Amaoc blog","author":"Amaoc","url":"http://www.amaoc.cn","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2023-11-28T03:37:46.757Z","updated":"2023-11-28T03:37:46.757Z","comments":false,"path":"/404.html","permalink":"http://www.amaoc.cn/404.html","excerpt":"","text":""},{"title":"关于","date":"2023-11-28T03:37:46.761Z","updated":"2023-11-28T03:37:46.761Z","comments":false,"path":"about/index.html","permalink":"http://www.amaoc.cn/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"书单","date":"2023-11-28T03:37:46.763Z","updated":"2023-11-28T03:37:46.763Z","comments":false,"path":"books/index.html","permalink":"http://www.amaoc.cn/books/index.html","excerpt":"","text":""},{"title":"分类","date":"2023-11-28T03:37:46.766Z","updated":"2023-11-28T03:37:46.766Z","comments":false,"path":"categories/index.html","permalink":"http://www.amaoc.cn/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2023-11-28T03:37:46.774Z","updated":"2023-11-28T03:37:46.774Z","comments":true,"path":"links/index.html","permalink":"http://www.amaoc.cn/links/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2023-11-28T03:37:46.775Z","updated":"2023-11-28T03:37:46.775Z","comments":false,"path":"repository/index.html","permalink":"http://www.amaoc.cn/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2023-11-28T03:37:46.775Z","updated":"2023-11-28T03:37:46.775Z","comments":false,"path":"tags/index.html","permalink":"http://www.amaoc.cn/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"事件循环(Event Loop)","slug":"事件循环","date":"2023-11-28T03:44:24.508Z","updated":"2024-03-04T10:17:03.829Z","comments":true,"path":"2023/11/28/事件循环/","link":"","permalink":"http://www.amaoc.cn/2023/11/28/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/","excerpt":"","text":"一、为什么JavaScript是单线程？ JavaScript语言的一大特点就是单线程，也就是说，同一个时间只能做一件事。那么，为什么JavaScript不能有多个线程呢？这样能提高效率啊。 JavaScript的单线程，与它的用途有关。作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。比如，假定JavaScript同时有两个线程，一个线程在某个DOM节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？ 所以，为了避免复杂性，从一诞生，JavaScript就是单线程，这已经成了这门语言的核心特征，将来也不会改变。 为了利用多核CPU的计算能力，HTML5提出Web Worker标准，允许JavaScript脚本创建多个线程，但是子线程完全受主线程控制，且不得操作DOM。所以，这个新标准并没有改变JavaScript单线程的本质。 二、任务队列 单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。如果前一个任务耗时很长，后一个任务就不得不一直等着。 如果排队是因为计算量大，CPU忙不过来，倒也算了，但是很多时候CPU是闲着的，因为IO设备（输入输出设备）很慢（比如Ajax操作从网络读取数据），不得不等着结果出来，再往下执行。 JavaScript语言的设计者意识到，这时主线程完全可以不管IO设备，挂起处于等待中的任务，先运行排在后面的任务。等到IO设备返回了结果，再回过头，把挂起的任务继续执行下去。 于是，所有任务可以分成两种，一种是同步任务（synchronous），另一种是异步任务（asynchronous）。同步任务指的是，在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；异步任务指的是，不进入主线程、而进入&quot;任务队列&quot;（task queue）的任务，只有&quot;任务队列&quot;通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。 具体来说，异步执行的运行机制如下。（同步执行也是如此，因为它可以被视为没有异步任务的异步执行。） （1）所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。 （2）主线程之外，还存在一个&quot;任务队列&quot;（task queue）。只要异步任务有了运行结果，就在&quot;任务队列&quot;之中放置一个事件。 （3）一旦&quot;执行栈&quot;中的所有同步任务执行完毕，系统就会读取&quot;任务队列&quot;，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。 （4）主线程不断重复上面的第三步。 下图就是主线程和任务队列的示意图。 只要主线程空了，就会去读取&quot;任务队列&quot;，这就是JavaScript的运行机制。这个过程会不断重复。 三、事件和回调函数 “任务队列&quot;是一个事件的队列（也可以理解成消息的队列），IO设备完成一项任务，就在&quot;任务队列&quot;中添加一个事件，表示相关的异步任务可以进入&quot;执行栈&quot;了。主线程读取&quot;任务队列”，就是读取里面有哪些事件。 “任务队列&quot;中的事件，除了IO设备的事件以外，还包括一些用户产生的事件（比如鼠标点击、页面滚动等等）。只要指定过回调函数，这些事件发生时就会进入&quot;任务队列”，等待主线程读取。 所谓&quot;回调函数&quot;（callback），就是那些会被主线程挂起来的代码。异步任务必须指定回调函数，当主线程开始执行异步任务，就是执行对应的回调函数。 &quot;任务队列&quot;是一个先进先出的数据结构，排在前面的事件，优先被主线程读取。主线程的读取过程基本上是自动的，只要执行栈一清空，&quot;任务队列&quot;上第一位的事件就自动进入主线程。但是，由于存在后文提到的&quot;定时器&quot;功能，主线程首先要检查一下执行时间，某些事件只有到了规定的时间，才能返回主线程。 四、Event Loop 主线程从&quot;任务队列&quot;中读取事件，这个过程是循环不断的，所以整个的这种运行机制又称为Event Loop（事件循环）。 为了更好地理解Event Loop，请看下图 上图中，主线程运行的时候，产生堆（heap）和栈（stack），栈中的代码调用各种外部API，它们在&quot;任务队列&quot;中加入各种事件（click，load，done）。只要栈中的代码执行完毕，主线程就会去读取&quot;任务队列&quot;，依次执行那些事件所对应的回调函数。 执行栈中的代码（同步任务），总是在读取&quot;任务队列&quot;（异步任务）之前执行。 五、Node.js的Event Loop Node.js也是单线程的Event Loop，但是它的运行机制不同于浏览器环境。 请看下面的示意图 根据上图，Node.js的运行机制如下: （1）V8引擎解析JavaScript脚本。 （2）解析后的代码，调用Node API。 （3）libuv库负责Node API的执行。它将不同的任务分配给不同的线程，形成一个Event Loop（事件循环），以异步的方式将任务的执行结果返回给V8引擎。 （4）V8引擎再将结果返回给用户。 参考文档 JavaScript 运行机制详解：再谈Event Loop","categories":[{"name":"前端开发","slug":"前端开发","permalink":"http://www.amaoc.cn/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"js","slug":"js","permalink":"http://www.amaoc.cn/tags/js/"}]},{"title":"前端开发规范","slug":"前端开发规范","date":"2023-11-28T03:37:46.759Z","updated":"2024-03-04T10:17:23.833Z","comments":true,"path":"2023/11/28/前端开发规范/","link":"","permalink":"http://www.amaoc.cn/2023/11/28/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/","excerpt":"","text":"参考文档 js命名规范 前端开发规范：命名规范、html规范、css规范、js规范","categories":[{"name":"前端开发","slug":"前端开发","permalink":"http://www.amaoc.cn/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"开发规范","slug":"开发规范","permalink":"http://www.amaoc.cn/tags/%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/"}]},{"title":"深拷贝与浅拷贝","slug":"深拷贝与浅拷贝","date":"2023-11-28T03:37:46.759Z","updated":"2024-03-04T10:17:19.337Z","comments":true,"path":"2023/11/28/深拷贝与浅拷贝/","link":"","permalink":"http://www.amaoc.cn/2023/11/28/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D/","excerpt":"","text":"如何区分深拷贝和浅拷贝 1234假设B复制了A;当修改了A时，看B是否会发生变化;如果B也跟着变了，说明这是浅拷贝;如果B没变，那就是深拷贝。 基本数据与复杂（引用）数据 12基本数据类型：number,string,boolean,null,undefined,symbol(ES6),BigInt(ES10); 引用数据类型：Object,Array,function 1.基本数据类型名值存储在栈内存中 例如： let a = 1; 当你b=a复制时，栈内存会新开辟一个内存 所以当你此时修改a=2时，对b并不会对a造成影响，所以深拷贝本身只针对较为复杂的引用数据类型。 2.引用数据类型名存在栈内存中，而值却存在于堆内存中，栈内存会提供一个引用的地址指向堆内存中的值 例如： let a = [0,1,2,3,4] 当b=a进行拷贝时，其实复制的是a的引用地址，而并非是堆内存里面的值 而当我们修改a[0]=1时，由于a与b指向的是同一个地址，所以自然b也受到了影响，这就是浅拷贝了。 那么，我们如何在堆内存中也开辟一个新的内存专门为b存放值，就像基本类型一样，就能达到深拷贝了。 如何实现浅拷贝 for…in只循环第一层 1234567891011121314151617// 只复制第一层的浅拷贝function simpleCopy(obj1) &#123; var obj2 = Array.isArray(obj1)?[]:&#123;&#125;; for (let i in obj1) &#123; obj2[i] = obj1[i] &#125; return obj2;&#125;var obj1 = &#123;a: 1, b: 2, c: &#123; d: 3&#125;&#125;;var obj2 = simpleCopy(obj1);obj2.a = 3;obj2.c.d = 4;// # obj1.a 1;// # obj2.a 3;// # obj1.c.d 4;// # obj2.c.d 4; Object.assign 12345var obj = &#123;a: 1, b: 2&#125;var obj1 = Object.assign(&#123;&#125;, obj);obj1.a = 3;// # obj.a 1; 直接用=赋值 123456let a = [0,1,2,3,4];let b = a;// # a === b true;a[0] = 1;// # b[0] 1; 如何实现深拷贝 采用递归去拷贝所以层级属性 12345678910111213141516171819202122function deepClone (obj) &#123; let objClone = Array.isArray(obj) ? [] : &#123;&#125;; if(obj &amp;&amp; typeof obj === &#x27;object&#x27;) &#123; for (let key in obj) &#123; if(obj.hasOwnProperty(key)) &#123; // # 判断obj子元素是否为对象，如果是，递归复制 if(obj[key] &amp;&amp; type obj[key] === &#x27;object&#x27;) &#123; objClone[key] = deepClone(obj[key]); &#125; else &#123; // # 如果不是，简单复制 objClone[key] = obj[key]; &#125; &#125; &#125; &#125; return objClone;&#125;let a = [1,2,3,4];let b = deepClone(a);a[0] = 2;// # b[0] 1; 通过JSON对象来实现深拷贝 123function deepClone2 (obj) &#123; return JSON.parse(JSON.stringify(obj));&#125; 缺点：无法实现对象中方法的深拷贝，会显示为undefined; 通过Jquery的extend方法实现深拷贝 12let arr = [1,2,3,4];let newArr = $.extend(true, [], arr); 通过lodash函数实现深拷贝 1let result = _.cloneDeep(test); Reflect法 123456789101112// # 代理法function deepClone (obj) &#123; if (!isObject(obj)) &#123; throw new Error(&#x27;obj 不是一个对象&#x27;) &#125; let isArray = Array.isArray(obj); let cloneObj = isArray ? [...obj] : &#123; ...obj &#125;; Reflect.ownKeys(cloneObj).forEach(key =&gt; &#123; cloneObj[key] = isObject(obj[key]) ? deepClone(obj[key]) : obj[key]; &#125;) return cloneObj;&#125; 参考文案 js浅拷贝与深拷贝的区别和实现方式","categories":[{"name":"前端开发","slug":"前端开发","permalink":"http://www.amaoc.cn/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"js","slug":"js","permalink":"http://www.amaoc.cn/tags/js/"}]},{"title":"观察者模式和发布-订阅模式","slug":"观察者模式和发布(订阅)模式","date":"2023-11-28T03:37:46.759Z","updated":"2023-11-28T03:37:46.760Z","comments":true,"path":"2023/11/28/观察者模式和发布(订阅)模式/","link":"","permalink":"http://www.amaoc.cn/2023/11/28/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%8F%91%E5%B8%83(%E8%AE%A2%E9%98%85)%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"观察者模式和发布/订阅模式 观察者模式 目标和观察者是基类，目标提供维护观察者的一系列方法，观察者提供更新接口。具体观察者和具体目标继承各自的基类，然后具体观察者把自己注册到具体目标里，在具体目标发生变化时候，调度观察者的更新方法。 观察者模式实现代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// 1. 观察者列表function ObserverList() &#123; this.observerList = [];&#125;ObserverList.prototype.add = function(obj) &#123; return this.observerList.push(obj);&#125;ObserverList.prototype.count = function() &#123; return this.observerList.length;&#125;ObserverList.prototype.get = function(index) &#123; if(index &gt; -1 &amp;&amp; index &lt; this.observerList.length) &#123; return this.observerList[index]; &#125; return null;&#125;ObserverList.prototype.indexOf = function(obj, startIndex) &#123; var i = startIndex || 0; while(i &lt; this.observerList.length) &#123; if(this.observerList[i] === obj) &#123; return i &#125; i++; &#125; return -1;&#125;ObserverList.prototype.removeAt = function(index) &#123; this.observerList.splice(index, 1);&#125;// 2.目标function Subject() &#123; this.observers = new ObserverList();&#125;Subject.prototype.addObserver = function(observer) &#123; this.observers.add(observer);&#125;Subject.prototype.removeObserver = function(observer) &#123; this.observers.removeAt(this.observers.indexOf(observer, 0));&#125;Subject.prototype.notify = function(context) &#123; var observerCount = this.observers.count(); for(var i = 0; i &lt; observerCount; i++) &#123; this.observers.get(i).update(context); &#125;&#125;// 3.观察者function Observer() &#123; this.update = function() &#123; //... &#125;&#125; 使用范例 123// html // &lt;button id=&quot;addNewObjserver&quot;&gt;add New Observer checkBox&lt;/button&gt;// 发布/订阅模式 订阅者把自己想订阅的事件注册到调度中心，当该事件触发的时候，发布者发布该事件到调度中心，由调度中心同意调度订阅者注册到调度中心的处理代码。 发布/订阅模式实现代码 12345678910111213141516171819202122232425262728293031323334353637383940var pubsub = &#123;&#125;;(function(myObject) &#123; var topics = &#123;&#125;; var subUid = -1; myObject.publish = function(topic, args) &#123; if(!topics[topic]) &#123; return false; &#125; var subscribers = topics[topic]; var len = subscribers ? subscribers.length : 0; while (len--) &#123; subscribers[len].func(topic, func); &#125; return this; &#125;; myObject.subscribe = function(topic, func) &#123; if(!topics[topic]) &#123; topics[topic] = []; &#125; var token = (++subUid).toString(); topics[topic].push(&#123; token: token, func: func &#125;); return token; &#125; myObject.unsubscribe = function(token) &#123; for(var m in topics) &#123; if(topics[m]) &#123; for(var i = 0, j = topics[m].length; i &lt; j; i++) &#123; if(topics[m][i].token === token) &#123; topics[m].splice(i, 1); return token; &#125; &#125; &#125; &#125; return this; &#125;&#125;)(pubsub) 参考文档 观察者模式和发布订阅模式的区别 设计模式学习之观察者模式和发布订阅模式 观察者模式与发布/订阅模式区别 JS设计模式2-发布／订阅模式和观察者模式","categories":[{"name":"前端开发","slug":"前端开发","permalink":"http://www.amaoc.cn/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"js","slug":"js","permalink":"http://www.amaoc.cn/tags/js/"}]},{"title":"domain实现跨域","slug":"domain使用","date":"2023-11-28T03:37:46.758Z","updated":"2023-11-28T03:37:46.758Z","comments":true,"path":"2023/11/28/domain使用/","link":"","permalink":"http://www.amaoc.cn/2023/11/28/domain%E4%BD%BF%E7%94%A8/","excerpt":"","text":"domain实现跨域 因项目需要，需要跨域，而且是在同一个基础域名下，就选择domain来实现，过程较为简单。 前提条件 需跨域的两个域名必须属于同一个基础域名，而且所用的协议(http或https)，端口号必须要一致。否则无法利用document.domain进行跨域。 JavaScript出于对安全性的考虑，而禁止两个或者多个不同域名的页面进行相互操作。 相同的页面在相互操作的时候，是不会任何有问题的。 iframe之间的操作 例如： aaa.com的一个网页中（a.html），利用iframe引入来一个bbb.com里的页面（b.html） 这时候在a.html中可以看到b.html的内容，但是却不能利用javascript来操作它。因为这两个页面属于不同的域，在操作之前，js会检测两个页面的域是否相等，如果相等，就允许操作，如果不相等，就会拒绝操作。 这里不可能把a.html与b.html利用JavaScript改成同一个域。因为它们的基础域名不相等。（强制用JavaScript将它们改成相等的域的话，会报“参数无效错误。”） 另外一种情况： 如果两个子域名：aaa.xxx.com和bbb.xxx.com；aaa里的页面（a.html）引入里bbb里的一个网页（b.html），这时a.html里同样不能操作b.html里面的内容。因为document.domain不一样，一个是aaa.xxx.com，另外一个是bbb.xxx.com。 这时我们就可以通过JavaScript，将两个页面的domain改成一样的。 只需要在a.html里与b.html里都加入 1document.domain = &#x27;xxx.com&#x27;; 这样两个页面就可以相互操作了。也就实现了同一基础域名之间的“跨域”； cookie的domain cookie虽然是由一个网页所创建，但并不只是创建cookie的网页才能读取该cookie。 在默认情况下，与创建cookie的网页在同一个目录或者子目录下的所有网页都可以读取该cookie。但是如果在这个目录下还有子目录，要使在子目录中也可以访问。则需要使用path参数设置cookie。 1234// test目录可以访问document.cookie = &quot;name=&quot; + escape(&quot;zhangsan&quot;) + &quot;; path=/test&quot;// 整个域名下都可以访问document.cookie = &quot;name=&quot; + escape(&quot;zhangsan&quot;) + &quot;; path=/&quot; 当如果在bbb.xxx.com域名下访问aaa.xxx.com里的cookie，就需要是用domain参数了。 例如，在aaa.xxx.com里设置cookie的domain，在bbb.xxx.com里就可以访问到了。 12// 注意：domian基础域名参数前面最好带一个.document.cookie = &quot;name=&quot; + escape(&quot;zhangsan&quot;) + &quot;; path=/; domain=.xxx.com&quot; 参考文档 js设置document.domain实现跨域的注意点分析 JavaScript中cookie的路径(path)和域(domain)","categories":[{"name":"前端开发","slug":"前端开发","permalink":"http://www.amaoc.cn/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"js","slug":"js","permalink":"http://www.amaoc.cn/tags/js/"}]},{"title":"js中null、undefined浅谈","slug":"js中null、undefined浅谈","date":"2023-11-28T03:37:46.758Z","updated":"2024-03-04T10:18:12.805Z","comments":true,"path":"2023/11/28/js中null、undefined浅谈/","link":"","permalink":"http://www.amaoc.cn/2023/11/28/js%E4%B8%ADnull%E3%80%81undefined%E6%B5%85%E8%B0%88/","excerpt":"","text":"大多数计算机语言，有且只有一个表示“无”的值，比如，C语言的NULL，Java语言的null，Python语言的None，Ruby语言的nil。 为啥JavaScript语言居然有两个表示“无”的值：undefined和null 历史原因 1995年JavaScript诞生时，最初像Java一样，只设置了null作为表示“无”的值。 根据C语言的传统，null被设计成可以自动转为0。 但是Brendan Eich觉得这样做还不够，有两个原因： null像在Java里一样，被当成一个对象。但是，JavaScript的数据类型分成原始类型（primitive）和合成类型（complex）两大类，Brendan Eich觉得表示“无”的值最好不是对象。 JavaScript的最初版本没有包括错误处理机制，发生数据类型不匹配时，往往时自动转换类型或者默默地失败。Brendan Eich觉得，如果null自动转为0，很不容易发现错误。 因此，Brendan Eich又设计了一个undefined。 最初设计 JavaScript的最初版本时这样区分的： null 是一个表示“无”的对象，转为数值时为0； undefined 是一个表示“无”的原始值，转为数值是为NAN； 1234567891011Number(null)// # 05 + null// # 5Number(undefined)// # NAN5 + undefined// # NAN 目前的用法 按照最初的设计区分，在实践中很快就被证明不可行。实践中有很多需要注意的地方。 null null 是基本数据类型之一，值仅有一个，即为null。表示“空对象”（因此类型检测返回对象），即如果有对象就会是一个具体的对象，如果没有对象，就是null。 典型用法： 作为函数的参数，表示该函数的参数不是对象； 作为对象的原型链的终点。 12Object.getPrototypeOf(Object.prototype) // nulltypeof null // Object 如果定义一个变量准备在将来用来保存对象，那么最好将该变量初始化为null而不是其他值。 undefined undefined 是基本数据类型之一，值仅有一个，即为undefined。表示“缺少值”（因此类型检测返回 undefined），即此处应该有一个值，但是还没有定义。 典型的用法： 变量被声明来，但没有赋值是，就等于 undefined 。 调用函数时，应该提供的参数没有提供，该参数就是undefined。 对象没有赋值的属性，该属性的值为 undefined。 函数没有返回值，默认返回 undefined。 123456789101112var i;// i undefinedfunction f(x) &#123;console.log(x)&#125;f()// x undefinedvar o = new Object();// o.p undefinedvar x = f();// x undefined 如何检测undefined 1234if(typeof abc == &#x27;undefined&#x27;)// 或者if(abc === undefined) ps: typeof有两种用法: typeof(x) 或者 typeof x 如何检测null 123if(!abc &amp;&amp; typeof abc != &#x27;undefined&#x27; &amp;&amp; abc !== 0)if (abc === null) 参考文档 null 和 undefined 的区别 null 和 undefined null 和 undefined 的区别","categories":[{"name":"前端开发","slug":"前端开发","permalink":"http://www.amaoc.cn/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"js","slug":"js","permalink":"http://www.amaoc.cn/tags/js/"}]},{"title":"js中的内存管理","slug":"js中的内存管理","date":"2023-11-28T03:37:46.758Z","updated":"2024-03-04T10:18:01.416Z","comments":true,"path":"2023/11/28/js中的内存管理/","link":"","permalink":"http://www.amaoc.cn/2023/11/28/js%E4%B8%AD%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/","excerpt":"","text":"1. 内存的生命周期 不管什么语言，内存生命周期基本是一致的： 分配你所需的内存 使用分配到的内存（读，写） 不需要时将其释放/归还 在C语言中，有专门的内存管理接口，像malloc() 和 free()。而在js中，没有专门的内存管理接口，所有的内存管理都是“自动”的。 js在创建变量时，自动分配内存，并在不使用的时候，自动释放。 2. JS中的内存回收 引用 垃圾回收算法主要依赖于引用的概念，在内存管理的环境中，一个对象如果有访问另一个对象的权限（隐式或显式），叫做一个对象引用另一个对象。 例如：一个Javascript对象具有堆它原型的引用（隐式引用）和它属性的引用（显式引用）。 引用计数垃圾收集 这是最简单的垃圾回收机制算法。此算法把“对象是否不再需要”简化定义为“对象有没有其他对象引用到它”。如果没有引用指向对象（零引用，对象将被垃圾回收机制回收） 例： 12let arr = [1, 2, 3, 4];arr = null; // [1, 2, 3, 4]这时没有被引用，会被自动回收 限制：循环引用 两个对象被创建并相互引用，就造成零循环引用。它们被调用之后不会离开函数的作用域，所以它们已经没用零，可以被回收了。然而，引用计数算法考虑它们相互都有至少一次引用，所以它们不会被回收 例： 1234567function f() &#123; var o1 = &#123;&#125;; var o2 = &#123;&#125;; o1.p = o2; // o1 引用了 o2 o2.p = o1; // o2 引用了 o1&#125;f(); 123456var div;window.onload = function () &#123; div = document.getElementById(&quot;myDivElement&quot;); div.circularReference = div; div.lotsOfData = new Array(10000).join(&quot;*&quot;);&#125;; 上面的例子里，myDivElement这个Dom元素的circularRerence属性引用了myDivElement造成了循环引用。IE6，7使用引用计数方式对DOM对象进行垃圾回收。该方法常常造成对象被循环引用时内存发生泄露。现代浏览器通过使用标记-清除内存回收算法，来解决这一个问题。 标记-清楚算法 这个算法把“对象是否不再需要”简化定义为“对象是否可以获得”。 这个算法假定设置一个叫根root的对象（在JavaScript里，根是全局对象）。垃圾回收器将从根开始定期的找所有从根开始引用的对象，然后找这些对象引用的对象，从根开始，垃圾回收器将找到所有可以获得的对象和所有不能获得的对象。 从2012年起，所有现代浏览器都使用了标记-清除内存回收算法。所有对JavaScript垃圾回收算法的改进都是基于标记-清除算法。 自动GC垃圾回收机制 尽管自动GC很方便，但是我们不知道GC什么时候会进行。这意味着如果我们在使用过程中使用了大量的内存，而GC没有运行的情况下，或者GC无法回收这些内存的情况下，程序就有可能假死，这个就需要我们在程序中手动做一些操作来触发内存回收了。 3. 什么是内存泄露？ 程序的运行需要内存，程序运行中的各种操作需要消耗资源和内存，程序运行中生成的各种数据也需要内存。若不及时释放内存，则内存的占用越来越高，轻则影响程序和系统的性能，重则导致进程或系统的崩溃。 没有即使释放不再使用的内存，就称为内存泄漏。 本质的讲，内存泄露就是不再被需要的内存，由于某种原因，无法被释放。 4. 哪些内容是“垃圾”？ JS的垃圾回收机制会定期（周期性）找出那些不再用到的内存（变量），然后释放其内存。 很简单，对于我们不再使用的内容，就会视为垃圾处理掉。而对于不再使用的值，则会被垃圾回收。（注意可访问性） 有用的值： 本地函数的局部变量和参数 调用链上的其他函数的变量和参数 全局变量 可访问的值 无用的值： 地址或值为 null 的值 函数的局部作用域中的变量和参数（函数完成后） 等等等等。 5. 常见的内存泄露案例 全局变量 123function foo (arg) &#123; bar = &quot;some text&quot;;&#125; 在js中处理未被声明的变量，上述范例中的bar时，会把bar定义到全局对象中，在浏览器中就是window上。在页面中的全局变量，只有当页面被关闭后才会被销毁。所以这种写法就会造成内存泄露，当然这个例子中的泄露的只是一个简单的字符串，但是在实际的代码中，往往情况会更加糟糕。 另外一种意外创建全局变量的情况。 12345function foo () &#123; this.var1 = &quot;potential accidental global&quot;;&#125;// foo 被调用时，this指向全局变量windowfoo(); 这种情况下调用foo，this被指向了全局变量window，意外的创建了全局变量。 我们谈到了一些意外情况下定义的全局变量，代码中也有一些我们明确定义的全局变量。如果使用这些全局变量用来暂存大量的数据，记得在使用后，对其重新赋值为null。 未销毁的定时器和回调函数 很多库中，如果使用了观察者模式，都会提供回调方法，来调用一些回调函数。要记得回收这些回调函数。例： 1234567var serverData = loadData();setInterval(function () &#123; var renderer = document.getElementById(&#x27;renderer&#x27;); if (renderer) &#123; renderer.innerHTML = JSON.stringify(serverData); &#125;&#125;, 5000); // 每5秒调用一次 如果后续renderer元素被移除，整个定时器实际上没有任何作用。但是如果你没有回收定时器，整个定时器依然有效，不但定时器无法被内存回收，定时器函数中的依赖也无法回收(serverData也无法被回收)。 闭包 在js开发中，我们经常会用到内部函数，有权访问包含它的外部函数的变量。 注意下面这种情况，闭包也会造成内存泄露 12345678910111213141516var theThing = null;var replaceThing = function () &#123; var originalThing = theThing; var unused = function () &#123; if (originalThing) &#123; // 对于‘originalThing’的引用 console.log(&#x27;hi&#x27;) &#125; &#125; theThing = &#123; longStr: new Array(1000000).join(&#x27;*&#x27;), someMethod: function () &#123; console.log(&#x27;message&#x27;); &#125; &#125;&#125;setInterval(replaceThing, 10000); 每次调用replaceThing时，theThing获得了包含一个巨大的数组和一个对于新闭包someMethod的对象，同时unused是一个引用了originalThing的闭包。 闭包之间是共享作用域的，尽管unused可能一只都没有被调用，但是someMethod可能会被调用，就会导致内存无法对其进行回收。 DOM引用 12345678910var elements = &#123; image: document.getElementById(&#x27;image&#x27;)&#125;;function doStuff() &#123; elements.image.src = &#x27;http://example.com/img.png&#x27;;&#125;function removeImage() &#123; document.body.removeChild(document.getElementById(&#x27;image&#x27;)); // 这个时候，我们对于#image 仍然有一个引用，Image元素仍然无法被内存回收。&#125; 注意： 如果我们引用了一个表格中的td元素，一旦在DOM中删除了整个表格，我们直观的认为内存回收应该回收了除了有引用的td外的其他元素，但是事实上，这个td元素是整个表格的一个子元素，并保留对于其父元素的引用。这个就会导致整个表格都无法进行内存回收。所以我们要小心处理DOM元素的引用。 ES6 ES中引入了WeakSet和WeakMap两个新概念，来解决引用造成的内存回收问题。WeakSet和WeakMap对于值的引用可以忽略不计，它们对于值的引用都是弱引用，内存回收机制不会考虑这种引用。当其他引用被消除之后，引用就会被内存中释放。 参考文档 JS中的内存管理","categories":[{"name":"前端开发","slug":"前端开发","permalink":"http://www.amaoc.cn/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"js","slug":"js","permalink":"http://www.amaoc.cn/tags/js/"}]},{"title":"js中的栈内存和堆内存","slug":"js中的栈内存和堆内存","date":"2023-11-28T03:37:46.758Z","updated":"2024-03-04T10:18:07.846Z","comments":true,"path":"2023/11/28/js中的栈内存和堆内存/","link":"","permalink":"http://www.amaoc.cn/2023/11/28/js%E4%B8%AD%E7%9A%84%E6%A0%88%E5%86%85%E5%AD%98%E5%92%8C%E5%A0%86%E5%86%85%E5%AD%98/","excerpt":"","text":"JavaScript的内存空间分为栈(stack)、堆(heap)、池(或叫栈中); 栈内存和堆内存简介 JavaScript中并没有严格意义上区分栈内存和堆内存。 栈数据结构 执行上下文的执行顺序借用了栈数据结构的存取方式； 栈空间的特点：先进后出，后进先出； 由于栈具有后入先出的特点，所以任何不在栈顶的元素都无法访问。 为了得到栈底的元素，必须先拿掉上面的元素； 类似乒乓球盒子来分析栈的存取方式。 1234栈会自动分配内存空间，物理内存是连续的，可以存放基本类型（Boolean,Number,String,undefined,null,Symbol），简单的数据段，引用类型的物理地址；占用空间小（大小固定），通过按值来访问，属于被频繁使用的数据。 PS：闭包中的基本数据类型变量不会保存在栈内存中，而是保存在堆内存中。 堆数据结构 堆是一种经过排序的树形数据结构，每个结点都有一个值。 通常我们所属的堆的数据结构，是指二叉堆。 堆的特点是根结点的值最小（或最大），且根结点的两个子树也是一个堆。 这种树状结构，它的存储数据的方式是随意的，与书架与书非常相似。我们不关心书的放置顺序是怎样的，只需要知道书的名字就可以取出我们想要的书了。 虽然书的摆放是有顺序的，但我们想取任意一本时不必像栈一样，先取出前面的所有书。 12345引用数据类型（Array,Object, Function）存储在堆内存中，因为引用数据类型占据空间大（大小不固定），如果存储在栈中，将会影响程序运行的性能。引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。堆内存是动态分配的内存，物理地址不连续，大小不定也不会自动释放内存； 队列 在Javascript中，理解队列数据结构的目的主要是为了清晰的明白事件循环（Event Loop）的机制 队列的特点：先进先出，后进后出。 栈内存和堆内存的区别 栈内存：所有在方法中定义的变量都是放在栈内存中，随着方法的执行结束，这个方法的内存栈也自然销毁。 优点：存取速度比堆快，仅次于直接位于CPU中的寄存器，数据可共享； 缺点：存在栈中的数据大小与生存期必须是确定的，缺乏灵活性。 堆内存：堆内存中的对象不会随方法的结束而销毁，即使方法结束后，这个对象海可能被另一个引用变量所引用（参数传递） 赋值与赋址 引擎不能直接操作堆内存中的数据，这就造成了对同一个变量赋不同类型的值，会出现完全不同的效果： 为一个变量赋基本值时，实际上是创建一个新值，然后把该值赋给新变量，可以说这是一种真正意义上的“赋值”； 为一个变量赋引用值时，实际上是为新变量添加一个指针，指向堆内存中的一个对象，属于一直“赋址”操作。 内存分配和垃圾回收 一般来说栈内存线性有序存储，容量小，系统分配效率高。而堆内存首先要在堆内存新分配存储区域，之后又要把指针存储到栈内存中，效率相对就要比较低一些。 垃圾回收方面，栈内存变量基本上用完了就回收了，而堆内存中的变量因为存在很多不确定的引用，只有当所有调用的变量全部销毁之后才能回收。 脑洞 121. const 定义的基本类型不能改变，但是定义的对象是可以通过修改对象属性等方法来改变的。因为我们定义一个const对象的时候，，我们说的常量其实是一个指针，就是说const对象对应的堆内存指向是不变的，但是堆内存中的数据本身的大小或者属性是可变的。 参考文案 浅析js中的栈内存和堆内存 中高级前端必须了解的–JS中的栈内存和堆内存 JavaScript栈内存与堆内存 详解JavaScript栈内存与堆内存 js中的栈内存和堆内存","categories":[{"name":"前端开发","slug":"前端开发","permalink":"http://www.amaoc.cn/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"js","slug":"js","permalink":"http://www.amaoc.cn/tags/js/"}]},{"title":"js的原型和原型链","slug":"js原型和原型链","date":"2023-11-28T03:37:46.758Z","updated":"2023-11-28T03:37:46.758Z","comments":true,"path":"2023/11/28/js原型和原型链/","link":"","permalink":"http://www.amaoc.cn/2023/11/28/js%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/","excerpt":"","text":"js的原型和原型链 普通函数和函数对象 JavaScript中，万物皆对象！但是对象也是有区别的。分为普通函数和函数对象，Object、Function是JS中自带的函数对象。 123456789101112131415161718var o1 = &#123;&#125;;var o2 = new Object();var o3 = new f1();function f1() &#123;&#125;;var f2 = function() &#123;&#125;;var f3 = new Function(&#x27;str&#x27;, &#x27;console.log(str)&#x27;);console.log(typeof Object); // functionconsole.log(typeof Function); // functionconsole.log(typeof f1); // functionconsole.log(typeof f2); // functionconsole.log(typeof f3); // functionconsole.log(typeof o1); // objectconsole.log(typeof o2); // objectconsole.log(typeof o3); // object 在上面的例子中，o1、o2、o3为普通的对象，f1、f2、f3为函数对象。 怎么区分？其实很简单： 凡是通过new Function() 创建的对象都是函数对象，其他的都是普通对象。f1、f2归根结底都是通过new Function() 的方式进行创建的。Function Object也都是通过new Function() 创建的。 构造函数 我们先复习一下构造函数的知识： 12345678910function Person(name, age, job) &#123; this.name = name; this.age = age; this.job = job; this.sayName = function() &#123; console.log(this.name) &#125;&#125;var person1 = new Person(&#x27;zhangsan&#x27;, 28, &#x27;Software Engineer&#x27;);var person2 = new Person(&#x27;lisi&#x27;, 23, &#x27;Doctor&#x27;); 上面的例子中的person1和person2都是Person的实例。这两个实例都有一个constructor（构造函数）的属性，该属性(是一个指针)指向Person。即： 12console.log(person1.constructor === Person); // trueconsole.log(person2.constructor === Person); // true 我们要记住两个概念（构造函数，实例）： person1和person2都是构造函数Person的实例。 一个公式： 实例的构造函数属性（constructor）指向构造函数。 原型对象 在JavaScript中，每当定义一个对象（函数也是对象）的时候，对象中都会包含一些预定义的属性。其中每个函数对象都有一个prototype属性，这个属性指向函数的原型对象。 1234567891011121314function Person() &#123;&#125;;Person.prototype.name = &#x27;zhangsan&#x27;;Person.prototype.age = 28;Person.prototype.job = &#x27;Softwar Engineer&#x27;;Person.prototype.sayName = function() &#123; console.log(this.name);&#125;var person1 = new Person();person1.sayName(); // &#x27;zhangsan&#x27;;var person2 = new Person();person2.sayName(); // &#x27;zhangsan&#x27;;console.log(person1.sayName === person2.sayName); // true; 我们得到了文本第一【定律】： 1每个对象都有__proto__属性，但只有函数对象才有prototype属性。 那什么是原型对象呢？ 我们把上面的例子改一改就会明白了： 12345678Person.prototype = &#123; name: &#x27;zhangsan&#x27;, age: 28, job: &#x27;Software&#x27;, sayName: function() &#123; console.log(this.name); &#125;&#125; 原型对象，顾名思义，它就是一个普通对象。 在上面我们给A添加了四个属性：name，age，job，sayName。其实它还有一个默认属性：constructor。 在默认情况下，所有的原型对象都会自动获得一个constructor（构造函数）的属性，这个属性（是一个指针）指向prototype属性所在的函数（Person）。 即 Person.prototype.constructor === Person; 参考文档 最详尽的 JS 原型与原型链终极详解，没有「可能是」。（一） 最详尽的 JS 原型与原型链终极详解，没有「可能是」。（二） 最详尽的 JS 原型与原型链终极详解，没有「可能是」。（三）","categories":[{"name":"前端开发","slug":"前端开发","permalink":"http://www.amaoc.cn/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"js","slug":"js","permalink":"http://www.amaoc.cn/tags/js/"}]},{"title":"stylelint 初次使用（vue）","slug":"stylelint初次使用","date":"2023-11-28T03:37:46.758Z","updated":"2023-11-28T03:37:46.759Z","comments":true,"path":"2023/11/28/stylelint初次使用/","link":"","permalink":"http://www.amaoc.cn/2023/11/28/stylelint%E5%88%9D%E6%AC%A1%E4%BD%BF%E7%94%A8/","excerpt":"","text":"stylelint 初次使用（vue） 很早就知道样式校验了，但是一直都没有去了解，因公司对样式比较关怀，所以特意去研究了一下，效果倍爽。。。 安装 12345yarn add stylelint stylelint-config-standard stylelint-config-rational-order stylelint-order stylelint-scss stylelint-webpack-plugin --save-dev# 或者npm install stylelint stylelint-config-standard stylelint-config-rational-order stylelint-order stylelint-scss stylelint-webpack-plugin --save-dev stylelint是运行工具 stylelint-config-standard(stylelint-config-recommentded)是stylelint的推荐配置 stylelint-order是css属性排序插件，并且每个规则都支持自动修复（stylelint --fix） stylelint-scss引入了特定的scss规则，是stylelint更好的支持scss语法 stylelint-config-rational-order是stylelint配置，通过按照以下顺序将相关属性声明进行分组来对它们进行排序： Positioning； Box Model； Typography； Visual； Animation； Misc； stylelint-webpack-plugin是webpack插件，使用stylelint检查css/scss代码。 注意：用vue-cli2构建的项目(webpack3.0)，stylelint-wepack-plugin的版本记得选用0.10.5的版本。 配置规则 stylelint配置顺序： 会去找package.json里的stylelint配置 没有找到package.json的配置，会找.stylelintrc（或者.stylelintrc.json, .stylelintrc.yaml, .stylelintrc.yml, .stylelintrc.js）中的配置 找stylelint.config.js中的配置 我们一般选用第二个，创建一个.stylelintrc.json文件 12345678910111213141516171819&#123; &quot;extends&quot;: [&quot;stylelint-config-standard&quot;, &quot;stylelint-config-rational-order&quot;], &quot;plugins&quot;: [&quot;stylelint-scss&quot;, &quot;stylelint-order&quot;], &quot;rules&quot;: &#123; // 因为开发原因，不可能每个css都给排序，太影响开发效率，所以排序禁用 &quot;no-descending-specificity&quot;: null, // 因为项目中用到里px2rem，不需要转rem的单位我们都用大写的PX来做单位（注释会被scss-loader及stylelint去掉），所以忽略单位大小写 &quot;unit-case&quot;: null, // 嵌套层写5层，太少会影响之前项目代码 &quot;max-nesting-depth&quot;: 5, &quot;order/order&quot;: [ &quot;custom-properties&quot;, &quot;dollar-variables&quot;, &quot;declarations&quot;, &quot;rules&quot;, &quot;at-rules&quot; ] &#125;&#125; 创建忽略stylelint代码文件，.stylelintignore忽略指定目录或文件 123456789101112/dist//test/*.min.css*.js*.ts*.png*.jpg*.webp*.ttf*.woff 配置 使用webpack插件校验.vue文件中的style，在vue.config.js中添加 1234567891011configureWebpack: config =&gt; &#123; const StyleLintPlugin = require(&#x27;stylelint-webpack-plugin&#x27;) config.plugins.push( new StyleLintPlugin(&#123; files: [&#x27;src/**/*.&#123;vue,html,css,scss,sass,less&#125;&#x27;], failOnError: false, cache: true, fix: true, &#125;) )&#125; 用vue-cli2构建的项目中，在/build/webpack.prod.conf.js中添加 123456789const StyleLintPlugin = require(&#x27;stylelint-webpack-plugin&#x27;)// 在plugins中new StyleLintPlugin(&#123; &#x27;files&#x27;: [&#x27;src/**/*.&#123;vue,css,sass,scss&#125;&#x27;], &#x27;fix&#x27;: true, &#x27;cache&#x27;: true, &#x27;emitErrors&#x27;: true, &#x27;failOnError&#x27;: false &#125;), stylelint与eslint同时使用git-hooks配置 在package.json中配置 123456789101112131415161718&#123; // ... &quot;lint-staged&quot;: &#123; &quot;*.&#123;vue,js&#125;&quot;: [ &quot;eslint --fix&quot;, &quot;git add&quot; ], &quot;*.&#123;html,vue,css,sass,scss&#125;&quot;: [ &quot;stylelint --fix&quot;, &quot;git add&quot;, ] &#125;, &quot;husky&quot;: &#123; &quot;hooks&quot;: &#123; &quot;pre-commit&quot;: &quot;lint-staged&quot;, &#125; &#125; &#125; rules规则 Color color-hex-case: 指定大写或小写十六进制的颜色。 color-hex-length: 指定十六进制颜色长或短的符号。 color-named: 需要（如果可能）或不允许命名的颜色。 color-no-hex: 不允许十六进制的颜色。 color-no-invalid-hex: 禁止无效的十六进制颜色。 font-family font-family-name-quotes:指定是否引号应该围绕字体系列名称中使用。 function function-blacklist:指定不允许的功能黑名单 function-calc-no-unspaced-operator:计算的函数中禁止的unspaced执行 function-comma-newline-after:要求一个新行或函数的逗号后禁止空白。 function-comma-newline-before: 要求一个新行或函数的逗号之前不允许空白。 function-comma-space-after: 要求一个空格或函数的逗号后禁止空白。 function-comma-space-before:要求一个空格或函数的逗号前禁止空白。 function-linear-gradient-no-nonstandard-direction:禁止在线性梯度方向值（），根据标准语法是无效的呼叫。 function-max-empty-lines: 限制方法中相邻的空行数 function-name-case: 指定大写或小写的函数名。 function-parentheses-newline-inside:要求一个新行或函数的括号内不允许空白。 function-parentheses-space-inside: 要求一个空格或函数的括号内不允许空白。 function-url-data-uris: 要求或禁止数据的URI的URL function-url-no-scheme-relative:不允许文档相对的URL。 function-url-quotes: 要求或禁止对于网址报价 function-url-scheme-whitelist: 指定允许URL方案的白名单。 function-whitelist: 指定允许的功能的白名单。 function-whitespace-after: 要求方法后不允许空白。 Number number-leading-zero:要求或分数低于1的数字禁止前导零。 number-max-precision:限制允许的小数位数的数目。 number-no-trailing-zeros: 禁止在数量尾随零。 String string-no-newline: 禁止在字符串（转义）换行。 string-quotes: 指定字串，单或双引号。 Length length-zero-no-unit: 禁止单位零长度。 Time time-no-imperceptible: 禁止动画和过渡小于或等于100毫秒。 Unit unit-blacklist: 指定不允许使用单位的黑名单。 unit-case: 指定大写或小写的单位。 unit-no-unknown: 禁止未知的单位。 unit-whitelist: 指定允许单位的白名单&gt; Value value-keyword-case: 指定大写或小写关键字的值。 value-no-vendor-prefix: 不允许供应商前缀值。 Value list value-list-comma-newline-after: 逗号后需要一个换行符或不允许空白值列表。 value-list-comma-newline-before: 逗号前需要一个换行符或不允许空白值列表。 value-list-comma-space-after: 需要一个空格或者逗号后不允许空白值列表。 value-list-comma-space-before:需要一个空格或者逗号前不允许空白值列表。 value-list-max-empty-lines: 限制相邻的数量值列表内空行。 Custom property custom-property-empty-line-before: 自定义属性之前equire或不允许空行。 custom-property-no-outside-root: 不允许自定义属性以外的:根规则。 custom-property-pattern: 为自定义属性指定一个模式。 Shorthand property shorthand-property-no-redundant-values:不允许在简写属性冗余值。 Property property-blacklist: 指定一个不允许属性的黑名单。 property-case: 为属性指定小写或大写。 property-no-unknown: 不允许未知属性。 property-no-vendor-prefix: 不允许前缀的属性。 property-whitelist: 指定一个白名单允许属性。 Keyframe declaration keyframe-declaration-no-important: 不允许!important在关键帧声明。 Declaration declaration-bang-space-after: bang声明之后需要一个空格或者不允许空白 declaration-bang-space-before: bang声明之前需要一个空格或者不允许空白 declaration-colon-newline-after: 冒号后的声明需要一个换行符或不允许空白。 declaration-colon-space-after: 冒号后的声明需要一个空格或不允许空白。 declaration-colon-space-before: 冒号之前的声明需要一个空格或不允许空白。 declaration-empty-line-before: 要求声明前不允许空一行。 declaration-no-important: 不允许!important声明。 declaration-property-unit-blacklist: 指定一个黑名单内不允许声明属性。 declaration-property-unit-whitelist: 指定一个白名单内允许声明属性。 declaration-property-value-blacklist: 指定一个黑名单,不允许在声明属性和值对。 declaration-property-value-whitelist: 指定一个允许属性和值对声明的白名单。 Declaration block declaration-block-no-duplicate-properties: 不允许复制属性块中声明 declaration-block-no-ignored-properties:不允许被忽略是因为另一个属性值的属性值相同的规则。 declaration-block-no-redundant-longhand-properties: 不允许手写属性,可以组合成一个简写属性。 declaration-block-no-shorthand-property-overrides: 不允许简写属性覆盖相关手写属性声明块。 declaration-block-properties-order: 声明块中指定的顺序属性。 declaration-block-semicolon-newline-after: 要求一个换行符或不允许空白块分号后。 declaration-block-semicolon-newline-before: 要求一个换行符或不允许空白块分号之前的声明。 declaration-block-semicolon-space-after: 要求一个空间或不允许空白块分号后的声明。 declaration-block-semicolon-space-before: 要求一个空间或不允许空白块分号之前的声明 declaration-block-single-line-max-declarations: 限制声明在一行声明块的数量 declaration-block-trailing-semicolon: 要求或不允许在声明块后面的分号。 Block block-closing-brace-empty-line-before: 要求或不允许关闭括号前空一行。 block-closing-brace-newline-after: 需要一个换行符或不允许关闭括号后的空白。 block-closing-brace-newline-before: 需要一个换行符或不允许空白关闭括号前的块。 block-closing-brace-space-after: 需要一个空间或不允许关闭括号后的空白块。 block-closing-brace-space-before: 在关闭括号前的块需要一个空格或者不允许空白。 block-no-empty: 不允许空块 block-no-single-line: 不允许单行块 block-opening-brace-newline-after: 开括号的块之后需要新的一行。 block-opening-brace-newline-before: 开括号的块之后需要一个换行符或不允许空白 block-opening-brace-space-after: 开括号的块之后需要一个空格或不允许空白。 block-opening-brace-space-before: 开括号的块之前需要一个空格或不允许空白。 Selector selector-attribute-brackets-space-inside: 在括号里的属性选择器需要一个空格或者不允许空白。 selector-attribute-operator-blacklist: 指定一个黑名单不允许属性的操作符。 selector-attribute-operator-space-after: 需要一个空间或不允许空格后运营商在属性选择器。 selector-attribute-operator-space-before: 需要一个空间或不允许空格内运营商之前属性选择器。 selector-attribute-operator-whitelist: 指定一个属性允许运营商的白名单。 selector-attribute-quotes: 需要或不允许引用属性值。 selector-class-pattern: 指定一个模式类选择符。 selector-combinator-space-after: 需要一个空间或不允许空格后的组合子选择器。 selector-combinator-space-before: 需要一个空间或不允许空格前的组合子选择器。 selector-descendant-combinator-no-non-space: 不允许的字符的后代组合子选择器进行技术改造。 selector-id-pattern: 指定一个模式,id选择器。 selector-max-compound-selectors: 在一个选择器里面限制复合选择器的数量。 selector-max-specificity: 限制的特异性选择器。 selector-nested-pattern: 指定一个模式选择器的规则嵌套规则。 selector-no-attribute: 不允许属性选择器。 selector-no-combinator: 不允许在选择器组合。 selector-no-id: 不允许id选择器。 selector-no-qualifying-type: 不允许符合条件的选择器的类型。 selector-no-type: 不允许类型选择器。 selector-no-universal: Disallow the universal selector. selector-no-vendor-prefix: 不允许选择器的前缀。 selector-pseudo-class-blacklist: 指定一个黑名单禁止伪类选择器。 selector-pseudo-class-case: 为伪类选择器指定小写或大写。 selector-pseudo-class-no-unknown: 不允许未知的伪类选择器。 selector-pseudo-class-parentheses-space-inside: 需要一个空格或不允许空格在括号里面的伪类选择器。 selector-pseudo-class-whitelist: 伪类选择器允许指定一个白名单。 selector-pseudo-element-case: 为伪元素选择器指定小写或大写。 selector-pseudo-element-colon-notation: 为适用的伪元素指定单引号或双冒号符号。 selector-pseudo-element-no-unknown: 不允许未知的伪元素选择器。 selector-root-no-composition: 在选择器不允许根的构成。 selector-type-case: 指定小写或大写类型选择器。 selector-type-no-unknown: 不允许未知类型选择器。 selector-max-empty-lines: 限制内相邻的空行选择器的数量。 Selector list selector-list-comma-newline-after: 需要一个换行符或不允许空白选择逗号后的列表。 selector-list-comma-newline-before: 逗号前需要一个换行符或不允许空白选择器列表。 selector-list-comma-space-after: 需要一个空格或者逗号后不允许空格选择器列表。 selector-list-comma-space-before: 需要一个空格或者逗号前不允许空格选择器列表。 Root rule root-no-standard-properties: 根规则内不允许标准属性。 Rule rule-nested-empty-line-before: 需要或不允许嵌套规则前空一行。 rule-non-nested-empty-line-before: 需要或不允许non-nested规则前空一行。 Media feature media-feature-colon-space-after: 需要一个空间或不允许空格在冒号之后媒体的特性。 media-feature-colon-space-before: 需要一个空间或不允许空格在冒号之前媒体的特性。 media-feature-name-case: 为媒体特性名称指定小写或大写。 media-feature-name-no-unknown: 不允许未知的媒体功能的名字。 media-feature-name-no-vendor-prefix: 不允许媒体特性名称的前缀。 media-feature-no-missing-punctuation: 不允许标点non-boolean媒体功能 media-feature-parentheses-space-inside: 需要一个空间或不允许空格在括号里面的媒体功能。 media-feature-range-operator-space-after: 需要一个空间或不允许空白范围运算符后媒体的特性。 media-feature-range-operator-space-before: 之前需要一个空间或不允许空格符范围在媒体功能。 Custom media custom-media-pattern: 为定制媒体查询名称指定一个模式。 Media query list media-query-list-comma-newline-after: 需要一个换行符或不允许空格后媒体查询的逗号分隔列表。 media-query-list-comma-newline-before: 需要一个换行符或不允许空格之前媒体查询的逗号分隔列表 media-query-list-comma-space-after: 需要一个空间或不允许空格后媒体查询的逗号分隔列表。 media-query-list-comma-space-before:需要一个空间或不允许空格之前媒体查询的逗号分隔列表。 At-rule at-rule-blacklist: 不允许at-rules指定一个黑名单。 at-rule-empty-line-before: 需要或不允许at-rules前空一行。 at-rule-name-case: 指定at-rules小写或大写的名字。 at-rule-name-newline-after: at-rule名称后需要一个换行符。 at-rule-name-space-after: 需要一个空格后at-rule名称。 at-rule-no-unknown: 不允许at-rules不明。 at-rule-no-vendor-prefix: 不允许at-rules前缀。 at-rule-semicolon-newline-after: 需要一个换行符之后at-rules的分号。 at-rule-whitelist: 指定允许at-rules的白名单。 stylelint-disable comment stylelint-disable-reason: 需要一个理由stylelint-disable之前或之后的评论发表评论。 Comment comment-empty-line-before: 需要或不允许评论之前一个空行。 comment-no-empty: 不允许空的评论。 comment-whitespace-inside:需要或不允许空格里面的注释标记。 comment-word-blacklist: 指定一个黑名单内不允许的话评论。 General / Sheet indentation: 指定缩进。 max-empty-lines: 限制数量的相邻的空行。 max-line-length: 限制线的长度。 max-nesting-depth: 限制的深度嵌套。 no-browser-hacks: 不允许浏览器黑客,无关你目标的浏览器。 no-descending-specificity: 不允许选择器之后覆盖选择器的低特异性更高的特异性。 no-duplicate-selectors: 不允许重复的选择器。 no-empty-source: 不允许空的来源。 no-eol-whitespace: 不允许行尾空白。 no-extra-semicolons: 不允许额外的分号。 no-indistinguishable-colors: 不允许产品极其接近的颜色相同。 no-invalid-double-slash-comments: 不允许双斜杠注释(/ /…)不支持CSS。 no-missing-end-of-source-newline: 不允许丢失end-of-source换行。 no-unknown-animations: 不允许动画名称不对应@keyframes声明。 no-unsupported-browser-features: 不允许功能的浏览器不支持的目标 参考文档 stylelint rules 如何为你的 Vue 项目添加配置 Stylelint 使用stylelint进行Vue项目样式检查 stylelint官网","categories":[{"name":"前端开发","slug":"前端开发","permalink":"http://www.amaoc.cn/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"css","slug":"css","permalink":"http://www.amaoc.cn/tags/css/"},{"name":"stylelint","slug":"stylelint","permalink":"http://www.amaoc.cn/tags/stylelint/"}]}],"categories":[{"name":"前端开发","slug":"前端开发","permalink":"http://www.amaoc.cn/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"js","slug":"js","permalink":"http://www.amaoc.cn/tags/js/"},{"name":"开发规范","slug":"开发规范","permalink":"http://www.amaoc.cn/tags/%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/"},{"name":"css","slug":"css","permalink":"http://www.amaoc.cn/tags/css/"},{"name":"stylelint","slug":"stylelint","permalink":"http://www.amaoc.cn/tags/stylelint/"}]}